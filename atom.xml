<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Triode Field</title>
  
  
  <link href="https://triodelzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://triodelzx.github.io/"/>
  <updated>2025-03-03T14:35:18.051Z</updated>
  <id>https://triodelzx.github.io/</id>
  
  <author>
    <name>Triode</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同源（2）——SIDH通解</title>
    <link href="https://triodelzx.github.io/2025/03/03/%E5%90%8C%E6%BA%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94SIDH%E9%80%9A%E8%A7%A3/"/>
    <id>https://triodelzx.github.io/2025/03/03/%E5%90%8C%E6%BA%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94SIDH%E9%80%9A%E8%A7%A3/</id>
    <published>2025-03-03T14:28:29.000Z</published>
    <updated>2025-03-03T14:35:18.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://eprint.iacr.org/2022/975">An efficient key recovery attack on SIDH</a></p></blockquote><p>前文再续，书接<a href="https://triodelzx.github.io/2025/02/26/同源（1）——SIDH/">上一回</a>，上一回讲到，SIDH喺2022年就被宣布畀人完全破解咗……</p><h2 id="前言">前言</h2><p>本来没想过写这一篇的，因为‘本来想着既然都有现成代码了，那用起来应该会很方便吧，但是在NSS上刷题的时候做到CryptoCTF 2023的一道题：<a href="https://www.nssctf.cn/problem/4387">[CryptoCTF 2023]Shevid | NSSCTF</a>，其实就是SIDH中已知Alice私钥以及双方公钥来恢复Bob私钥，但是在用<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>给出的代码时四处碰壁，所以想着写这篇博客记录一下如何使用这些代码。</p><h2 id="对sidh的破解">对SIDH的破解</h2><p><del>有现成代码，原理似乎也不是很重要</del> 大致扫了一眼论文和GitHub项目上的样例代码（<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath/blob/main/baby_SIDH.sage">baby_SIDH.sage</a>），发现我们要做的似乎其实仅仅是需要构造一个曲线上的自同态<span class="math inline">\([2i]\)</span>，使得<span class="math inline">\([2i]\circ[2i]=[-4]\)</span>（实际上就是<span class="math inline">\(2i\)</span>倍点映射吧，但是sage并不能直接给<span class="math inline">\(GF(p^2)\)</span>上的点乘上<span class="math inline">\(2i\)</span>），所以这个过程其实要我们自己写，但是在Github的项目里面其实是有给由方程<span class="math inline">\(y^2=x^3+6x^2+x\)</span>所定义的椭圆曲线上的<span class="math inline">\(2i\)</span>倍点映射的算法，而通过阅读论文，我们也可以写出由方程<span class="math inline">\(y^2=x^3+x\)</span>所定义的椭圆曲线上的<span class="math inline">\(2i\)</span>倍点映射：<span class="math inline">\([2i]:(x,y)\mapsto[2](-x,iy)\)</span>（其中<span class="math inline">\([2]\)</span>为二倍点映射），在论文里面也只讨论了这两种方程定义的曲线。</p><h3 id="代码使用实例">代码使用实例</h3><p>在这里通过两个例子来公式化地使用Github项目中给出的代码解决分别由<span class="math inline">\(y^2=x^3+6x^2+x\)</span>与<span class="math inline">\(y^2=x^3+x\)</span>定义的曲线上的SIDH：</p><h4 id="cryptoctf-2023shevid">[CryptoCTF 2023]Shevid</h4><p>题目给出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_param</span>(<span class="params">B</span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">       a = randint(B &gt;&gt; <span class="number">1</span>, B)  </span><br><span class="line">       b = randint(B &gt;&gt; <span class="number">2</span>, B &gt;&gt; <span class="number">1</span>)  </span><br><span class="line">       p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">       <span class="keyword">if</span> is_prime(p):  </span><br><span class="line">          <span class="keyword">return</span> a, b  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_dmap</span>(<span class="params">E</span>):  </span><br><span class="line">    <span class="keyword">return</span> E.isogeny(E.lift_x(ZZ(<span class="number">1</span>)), codomain = E)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_tpt</span>(<span class="params">E, a, b</span>):  </span><br><span class="line">    P, Q = [((p + <span class="number">1</span>) // <span class="number">2</span>**a) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    R, S = [((p + <span class="number">1</span>) // <span class="number">3</span>**b) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    <span class="keyword">return</span> P, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">EC, b, P, Q, R, S</span>):  </span><br><span class="line">    skey = randint(<span class="number">1</span>, <span class="number">3</span>**b)  </span><br><span class="line">    T = R + skey * S  </span><br><span class="line">    phi = EC.isogeny(T, algorithm = <span class="string">&quot;factored&quot;</span>)  </span><br><span class="line">    _phi_dom, _phi_P, _phi_Q = phi.codomain(), phi(P), phi(Q)  </span><br><span class="line">    <span class="keyword">return</span> skey, _phi_dom, _phi_P, _phi_Q  </span><br><span class="line">  </span><br><span class="line">a, b = gen_param(<span class="number">190</span>)  </span><br><span class="line">p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">F.&lt;x&gt; = GF(p^<span class="number">2</span>, modulus = x**<span class="number">2</span> + <span class="number">1</span>)  </span><br><span class="line">EC = EllipticCurve(F, [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])  </span><br><span class="line">P, Q, R, S = gen_tpt(EC, a, b)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;P = <span class="subst">&#123;P.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Q = <span class="subst">&#123;Q.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;R = <span class="subst">&#123;R.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;S = <span class="subst">&#123;S.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">skey, _phi_dom, _phi_P, _phi_Q = keygen(EC, b, P, Q, R, S)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_dom = <span class="subst">&#123;_phi_dom&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_P   = <span class="subst">&#123;_phi_P.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_Q   = <span class="subst">&#123;_phi_Q.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">key = md5(long_to_bytes(skey)).digest()  </span><br><span class="line">iv = md5(<span class="built_in">str</span>(skey).encode()).digest()  </span><br><span class="line">  </span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv=iv)  </span><br><span class="line">enc = cipher.encrypt(flag)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;enc = <span class="subst">&#123;enc.<span class="built_in">hex</span>()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure> 其实就是要我们通过Alice的公开点<span class="math inline">\(P,Q\)</span>和Bob的公钥<span class="math inline">\((\phi(E),\phi(P),\phi(Q))\)</span>还原Bob的秘密值<span class="math inline">\(k_B\)</span>，这里定义的曲线是由<span class="math inline">\(y^2=x^3+6x^2+x\)</span>所定义的，所以我们可以用<code>public_values_aux.py</code>中的<code>generate_distortion_map</code>函数来计算该曲线上的<span class="math inline">\([2i]\)</span>，那么可以写出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> public_values_aux <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;castryck_decru_shortcut.sage&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Fd.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(Fd, [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E.set_order((p+<span class="number">1</span>)^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">142</span></span><br><span class="line">b = <span class="number">69</span></span><br><span class="line"></span><br><span class="line">a2 = <span class="number">6</span></span><br><span class="line">a4 = <span class="number">2070374075904221348548347954672740119972290047985052548426161483408084160515</span>*i+<span class="number">896749506444795652787374405713981306103783874504413776724865996633074195878</span></span><br><span class="line">a6 = <span class="number">2497300913991521538985990865799426081199023429830552981773916386651958830387</span>*i+<span class="number">4243320791854592301388975795466391442631117041175807728844738724691845270777</span></span><br><span class="line"></span><br><span class="line">_phi_dom = EllipticCurve(Fd, [<span class="number">0</span>, a2, <span class="number">0</span>, a4, a6])</span><br><span class="line"></span><br><span class="line">_phi_P = _phi_dom(...)</span><br><span class="line">_phi_Q = _phi_dom(...)</span><br><span class="line"></span><br><span class="line">P2 = E(...)</span><br><span class="line">Q2 = E(...)</span><br><span class="line">P3 = E(...)</span><br><span class="line">Q3 = E(...)</span><br><span class="line">two_i = generate_distortion_map(E)</span><br><span class="line">check_torsion_points(E, a, b, P2, Q2, P3, Q3)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line">recovered_key = CastryckDecruAttack(E, P2, Q2, _phi_dom, _phi_P, _phi_Q, two_i, num_cores=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">key = md5(long_to_bytes(<span class="built_in">int</span>(recovered_key))).digest()</span><br><span class="line">iv = md5(<span class="built_in">str</span>(recovered_key).encode()).digest()</span><br><span class="line"></span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv=iv)</span><br><span class="line">flag = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(enc))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 注意，这里的<code>P2,Q2,P3,Q3</code>分别对应的是题目代码中的<code>P,Q,R,S</code>，我们可以修改函数<code>CastryckDecruAttack</code>中的<code>num_cores</code>参数可以改变并行进程数，从而提高运行效率，开4个线程运行结果如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503032230423.png" alt="Pasted image 20250303200634" /></p><h4 id="一道自制题">一道自制题</h4><p>找不到<span class="math inline">\(y^2=x^3+x\)</span>的题目，自己出一道举个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;Test_Flag_for_Isogeny_with_y^2=x^3+x&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_param</span>(<span class="params">B</span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">       a = randint(B &gt;&gt; <span class="number">1</span>, B)  </span><br><span class="line">       b = randint(B &gt;&gt; <span class="number">2</span>, B &gt;&gt; <span class="number">1</span>)  </span><br><span class="line">       p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">       <span class="keyword">if</span> is_prime(p):  </span><br><span class="line">          <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_tpt</span>(<span class="params">E, a, b</span>):  </span><br><span class="line">    P, Q = [((p + <span class="number">1</span>) // <span class="number">2</span>**a) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    R, S = [((p + <span class="number">1</span>) // <span class="number">3</span>**b) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    <span class="keyword">return</span> P, Q, R, S  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">shared_key, plaintext</span>):</span><br><span class="line">    key = sha256(<span class="built_in">str</span>(shared_key).encode()).digest()[:<span class="number">16</span>]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(pad(plaintext, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">a, b = gen_param(<span class="number">64</span>)</span><br><span class="line">p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">E = EllipticCurve(F, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">P1, Q1, P2, Q2 = gen_tpt(E, a, b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P1 = E<span class="subst">&#123;P1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q1 = E<span class="subst">&#123;Q1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P2 = E<span class="subst">&#123;P2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q2 = E<span class="subst">&#123;Q2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alice</span></span><br><span class="line">ka = randint(<span class="number">1</span>, <span class="number">2</span>**a)</span><br><span class="line">RA = P1 + ka * Q1</span><br><span class="line">phiA = E.isogeny(RA, algorithm=<span class="string">&#x27;factored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">phiA_P2 = phiA(P2)</span><br><span class="line">phiA_Q2 = phiA(Q2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;EA = <span class="subst">&#123;phiA.codomain()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiA_P2 = EA<span class="subst">&#123;phiA_P2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiA_Q2 = EA<span class="subst">&#123;phiA_Q2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bob</span></span><br><span class="line">kb = randint(<span class="number">1</span>, <span class="number">3</span>**b)</span><br><span class="line">RB = P2 + kb * Q2</span><br><span class="line">phiB = E.isogeny(RB, algorithm=<span class="string">&#x27;factored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">phiB_P1 = phiB(P1)</span><br><span class="line">phiB_Q1 = phiB(Q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;EB = <span class="subst">&#123;phiB.codomain()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiB_P1 = EB<span class="subst">&#123;phiB_P1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiB_Q1 = EB<span class="subst">&#123;phiB_Q1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">RA1 = phiB_P1 + ka * phiB_Q1</span><br><span class="line">shared1 = EB.isogeny(RA1, algorithm=<span class="string">&#x27;factored&#x27;</span>).codomain().j_invariant()</span><br><span class="line"></span><br><span class="line">RB1 = phiA_P2 + kb * phiA_Q2</span><br><span class="line">shared2 = EA.isogeny(RB1, algorithm=<span class="string">&#x27;factored&#x27;</span>).codomain().j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> shared1 == shared2</span><br><span class="line">shared_key = shared1</span><br><span class="line"></span><br><span class="line">enc = encrypt(shared_key, flag)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;enc = <span class="subst">&#123;enc.<span class="built_in">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p = 69007679864054552199167 </span></span><br><span class="line"><span class="string">a = 41 </span></span><br><span class="line"><span class="string">b = 22 </span></span><br><span class="line"><span class="string">P1 = E(42941883561232695204126*i + 41565179451593292417697, 32012113025288545049970*i + 67447792731782782239107) </span></span><br><span class="line"><span class="string">Q1 = E(25302850366663243334175*i + 28499745867760697777766, 45519069949265761361669*i + 38091523002955621484376) </span></span><br><span class="line"><span class="string">P2 = E(64295307603787694858622*i + 23124820300292317471971, 56390657452217097859549*i + 36392449137376185120691) </span></span><br><span class="line"><span class="string">Q2 = E(5592769293100950710186*i + 10812888045531269729601, 6826865383103204422537*i + 20863179574507545233583) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EA = Elliptic Curve defined by y^2 = x^3 + (55136237696257287853765*i+57833844773073644952221)*x + (52942153600632609877190*i+15361822390228021806871) over Finite Field in i of size 69007679864054552199167^2 </span></span><br><span class="line"><span class="string">phiA_P2 = EA(62489625132170888252802*i + 63808521833396900819332, 49433807014900669675197*i + 38317557157701506341329) </span></span><br><span class="line"><span class="string">phiA_Q2 = EA(3850966740889085851852*i + 45392830987593111886391, 14326935923982120143676*i + 32443933495898500654626) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EB = Elliptic Curve defined by y^2 = x^3 + (535570609910458761019*i+55847628242608619214131)*x + (52895838204408953951990*i+40402487899485896459107) over Finite Field in i of size 69007679864054552199167^2 </span></span><br><span class="line"><span class="string">phiB_P1 = EB(67880173178064709758833*i + 5128007695857513878729, 67090026125242047708224*i + 36228875668588115708933) </span></span><br><span class="line"><span class="string">phiB_Q1 = EB(42637972539717898085377*i + 30589197453944790040489, 62900893992599911017947*i + 53504295506770245599626) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">enc = c63958e914ecac186888aa578719cc8e21bd3f1df3eba0a36dee5a425e487db180f52502552e19495ca7fdf0071fe8cb</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure> 可以通过如下代码来获得flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> public_values_aux <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;castryck_decru_shortcut.sage&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two_i</span>(<span class="params">P</span>):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    <span class="keyword">if</span> P == E(<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> E(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y = P.xy()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*E(-x, i*y)</span><br><span class="line"></span><br><span class="line">p = <span class="number">69007679864054552199167</span></span><br><span class="line">a = <span class="number">41</span></span><br><span class="line">b = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(F, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">P2 = E(<span class="number">42941883561232695204126</span>*i + <span class="number">41565179451593292417697</span>, <span class="number">32012113025288545049970</span>*i + <span class="number">67447792731782782239107</span>)</span><br><span class="line">Q2 = E(<span class="number">25302850366663243334175</span>*i + <span class="number">28499745867760697777766</span>, <span class="number">45519069949265761361669</span>*i + <span class="number">38091523002955621484376</span>)</span><br><span class="line">P3 = E(<span class="number">64295307603787694858622</span>*i + <span class="number">23124820300292317471971</span>, <span class="number">56390657452217097859549</span>*i + <span class="number">36392449137376185120691</span>)</span><br><span class="line">Q3 = E(<span class="number">5592769293100950710186</span>*i + <span class="number">10812888045531269729601</span>, <span class="number">6826865383103204422537</span>*i + <span class="number">20863179574507545233583</span>)</span><br><span class="line">check_torsion_points(E, a, b, P2, Q2, P3, Q3)</span><br><span class="line"></span><br><span class="line">EA = EllipticCurve(F, [<span class="number">55136237696257287853765</span>*i+<span class="number">57833844773073644952221</span>, <span class="number">52942153600632609877190</span>*i+<span class="number">15361822390228021806871</span>])</span><br><span class="line">phiA_P3 = EA(<span class="number">62489625132170888252802</span>*i + <span class="number">63808521833396900819332</span>, <span class="number">49433807014900669675197</span>*i + <span class="number">38317557157701506341329</span>)</span><br><span class="line">phiA_Q3 = EA(<span class="number">3850966740889085851852</span>*i + <span class="number">45392830987593111886391</span>, <span class="number">14326935923982120143676</span>*i + <span class="number">32443933495898500654626</span>)</span><br><span class="line"></span><br><span class="line">EB = EllipticCurve(F, [<span class="number">535570609910458761019</span>*i+<span class="number">55847628242608619214131</span>, <span class="number">52895838204408953951990</span>*i+<span class="number">40402487899485896459107</span>])</span><br><span class="line">phiB_P2 = EB(<span class="number">67880173178064709758833</span>*i + <span class="number">5128007695857513878729</span>, <span class="number">67090026125242047708224</span>*i + <span class="number">36228875668588115708933</span>)</span><br><span class="line">phiB_Q2 = EB(<span class="number">42637972539717898085377</span>*i + <span class="number">30589197453944790040489</span>, <span class="number">62900893992599911017947</span>*i + <span class="number">53504295506770245599626</span>)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;c63958e914ecac186888aa578719cc8e21bd3f1df3eba0a36dee5a425e487db180f52502552e19495ca7fdf0071fe8cb&quot;</span></span><br><span class="line"></span><br><span class="line">kb = CastryckDecruAttack(E, P2, Q2, EB, phiB_P2, phiB_Q2, two_i, num_cores=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">R = phiA_P3 + kb * phiA_Q3</span><br><span class="line">R._order = <span class="number">3</span>^b</span><br><span class="line">phi = EA.isogeny(R, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">shared_key = phi.codomain().j_invariant()</span><br><span class="line"></span><br><span class="line">key = sha256(<span class="built_in">str</span>(shared_key).encode()).digest()[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">flag = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(enc))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 注意，这里的<code>P2,Q2,P3,Q3</code>对应题目代码中的<code>P1,Q1,P2,Q2</code>，运行结果如下： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503032231783.png" alt="Pasted image 20250303222653" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://eprint.iacr.org/2022/975&quot;&gt;An efficient key recovery attack on SIDH&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文再续，书接</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>同源（1）——SIDH</title>
    <link href="https://triodelzx.github.io/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/"/>
    <id>https://triodelzx.github.io/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/</id>
    <published>2025-02-26T11:55:33.000Z</published>
    <updated>2025-02-27T04:58:25.787Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://arxiv.org/pdf/1711.04062">Mathematics of Isogeny Based Cryptography</a></p></li><li><p><a href="https://eprint.iacr.org/2019/1321.pdf">Supersingular isogeny key exchange for beginners</a></p></li><li><p><a href="https://link.springer.com/book/10.1007/b97292">Elliptic Curves | SpringerLink</a></p></li><li><p><a href="https://tangcuxiaojikuai.xyz/post/e06139e7.html">Isogeny | 糖醋小鸡块的blog</a></p></li><li><p><a href="https://languag3.github.io/2025/02/04/isogeny/#sidh">isogeny | languag3</a></p></li><li><p><a href="https://huangx607087.online/2025/02/01/ECCNotes4/">ECCNotes4 - huangx607087's Blog</a></p></li></ol></blockquote><h2 id="前置知识">前置知识</h2><h3 id="超奇异supersingular椭圆曲线">超奇异（supersingular）椭圆曲线</h3><p>对于<span class="math inline">\(GF(p^r)\)</span>下的椭圆曲线<span class="math inline">\(E\)</span>，若<span class="math inline">\(|E|\equiv 1\pmod{p}\)</span>，则称该曲线为超奇异椭圆曲线</p><h3 id="j-不变量j-invariant"><span class="math inline">\(j\)</span>-不变量（<span class="math inline">\(j\)</span>-invariant）</h3><p>对于一条由方程<span class="math inline">\(y^2=x^3+ax+b\)</span>定义的椭圆曲线<span class="math inline">\(E\)</span>，其<span class="math inline">\(j\)</span>-不变量的定义为： <span class="math display">\[j(E)=1728\cdot\frac{4a^3}{4a^3+27b^2}\]</span> 当且仅当两条定义在代数闭包<span class="math inline">\(\overline{k}\)</span>上的曲线<span class="math inline">\(E\)</span>与<span class="math inline">\(E&#39;\)</span>的<span class="math inline">\(j\)</span>-不变量相同时这两条曲线同构，即存在点到点之间的双射<span class="math inline">\(\phi\)</span>使得： <span class="math display">\[\phi:E\mapsto E&#39;\]</span> 通过参考资料2我们可以知道对于SIDH，其主要作用于有限域<span class="math inline">\(GF(p)\)</span>的二次扩展（即<span class="math inline">\(GF(p^2)\)</span>，其中<span class="math inline">\(p\equiv 3\pmod{4}\)</span>），方便起见，我们通常将这个二次扩展域中的元素表示为<span class="math inline">\(u+vi\)</span>（其中<span class="math inline">\(u,v\in GF(p)\)</span>，<span class="math inline">\(i^2\equiv-1\pmod{p}\)</span>），定义在这个二次扩展域上的超奇异<span class="math inline">\(j\)</span>-不变量的个数为<span class="math inline">\(\lfloor p/12\rfloor+z\)</span>，这些超奇异<span class="math inline">\(j\)</span>-不变量每一个都对应一条同构意义下的超奇异曲线，其中<span class="math inline">\(z\in\{0,1,2\}\)</span>，<span class="math inline">\(z\)</span>的取值取决于<span class="math inline">\(p\mod 12\)</span>，具体如下（参考资料3，P264）： <span class="math display">\[z=\begin{cases}0&amp;,p\equiv1\pmod{12}\\1&amp;,p\equiv5\pmod{12}\\1&amp;,p\equiv7\pmod{12}\\2&amp;,p\equiv11\pmod{12}\\\end{cases}\]</span> 例如对于参考资料2中的例子（即<span class="math inline">\(p=431\)</span>），<span class="math inline">\(GF(p^2)\)</span>中的<span class="math inline">\(\lfloor p/12\rfloor+2=37\)</span>个<span class="math inline">\(j\)</span>-不变量分别对应一条同构意义下的超奇异曲线，这些<span class="math inline">\(j-\)</span>不变量如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006712.png" alt="image-20250226200636189" /> 关于<span class="math inline">\(j\)</span>-不变量与曲线间同构的关系，参考资料2给出了一个例子：对于<span class="math inline">\(GF(431^2)\)</span>下的两条曲线： <span class="math display">\[\begin{aligned}E_1:y^2=x^3+(208i+161)x^2+x\\E_2:y^2=x^3+(172i+162)x^2+x\\\end{aligned}\]</span> 可以计算出<span class="math inline">\(j(E_1)=j(E_2)=364i+304\)</span>，那么我们可以通过如下代码来求出<span class="math inline">\(E_1\)</span>到<span class="math inline">\(E_2\)</span>的同构映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line"></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E1 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E2 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">172</span>*i+<span class="number">162</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(E1.j_invariant())</span><br><span class="line"><span class="built_in">print</span>(E2.j_invariant())</span><br><span class="line"></span><br><span class="line">phi = E1.isomorphism_to(E2)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[\begin{aligned}\phi:&amp;E_1\mapsto E_2\\&amp;(x,y)\mapsto((66i + 182)x + (-131i + 109), (122i + 159)y)\end{aligned}\]</span></p><h3 id="蒙哥马利montgomery曲线">蒙哥马利（Montgomery）曲线</h3><p>在椭圆曲线密码学中常用的椭圆曲线为形如<span class="math inline">\(y^2=x^3+ax+b\)</span>方程所确定的曲线，这类方程一般称为魏尔斯特拉斯（Weierstrass）方程，这类方程确定的曲线一般称为魏尔斯特拉斯形式的椭圆曲线，还有另外一种形式的椭圆曲线是由方程<span class="math inline">\(y^2=x^3+Ax^2+x\)</span>所定义的，这类椭圆曲线被称为蒙哥马利曲线，对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+Ax^2+x\)</span>，其<span class="math inline">\(j\)</span>-不变量为： <span class="math display">\[j(E)=\frac{256(A^2-3)^3}{A^2-4}\]</span> 任意一条椭圆曲线都可以转换为<span class="math inline">\(j\)</span>-不变量相同（亦即同构）的蒙哥马利曲线，在sage中，我们可以通过<code>montgomery_model</code>来将一条椭圆曲线转换为蒙哥马利曲线，例如我们要将魏尔斯特拉斯形式的椭圆曲线： <span class="math display">\[E:y^2=x^3+312589632x+654443578\pmod{1912812599}\]</span> 转换为对应的蒙哥马利曲线，则可以通过如下代码进行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">1912812599</span></span><br><span class="line">a = <span class="number">312589632</span></span><br><span class="line">b = <span class="number">654443578</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line">E_M = <span class="built_in">print</span>(E.montgomery_model()</span><br></pre></td></tr></table></figure> 可以得到其对应的蒙哥马利曲线为： <span class="math display">\[E_M:y^2 = x^3 + 723347356x^2 + x\pmod{1912812599}\]</span></p><h3 id="同源">同源</h3><p>同源实际上就是一条曲线到另一条曲线或者一条曲线到自身的映射，其本质为同态，可以简单地表达为<span class="math inline">\((x,y)\mapsto(f(x,y),g(x,y))\)</span>，其中<span class="math inline">\(f,g\)</span>是两个函数。在之后的讨论中将主要以蒙哥马利曲线为主，因为蒙哥马利曲线之间的映射可以单纯通过对<span class="math inline">\(x\)</span>进行映射<span class="math inline">\(x\mapsto f(x)\)</span>来表示出曲线间完整的映射，其完整映射形式为： <span class="math display">\[(x,y)\mapsto(f(x),cyf&#39;(x))\]</span> 其中<span class="math inline">\(c\)</span>是固定常数，<span class="math inline">\(f&#39;\)</span>为<span class="math inline">\(f\)</span>的导函数. 对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，可以得到一个<span class="math inline">\(E\)</span>到<span class="math inline">\(E\)</span>的同构映射： <span class="math display">\[[2]:E\mapsto E, x\mapsto\frac{(x^2-1)^2}{4x(x^2+ax+1)}\]</span> 这个映射一般称为二倍点映射，事实上，我们令分母<span class="math inline">\(4x(x^2+ax+1)=0\)</span>，可以得到三个根<span class="math inline">\(0,\alpha,\frac{1}{\alpha}\)</span>（其中<span class="math inline">\(\alpha\)</span>满足<span class="math inline">\(\alpha^2+a\alpha+1\)</span>），我们就可以得到曲线上阶为<span class="math inline">\(2\)</span>的点：<span class="math inline">\((0,0),(\alpha,0),(\frac{1}{\alpha},0)\)</span>，这三个点的集合就是映射<span class="math inline">\([2]\)</span>的核，记为<span class="math inline">\(\ker([2])\)</span>，它是椭圆曲线群<span class="math inline">\(E\)</span>的一个子群，同构于<span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，这上面的点称为<span class="math inline">\(2\)</span>-torsion，事实上对于任意一条椭圆曲线都有其对应的<span class="math inline">\(\ker([2])\)</span> 例如对于<span class="math inline">\(GF(431^2)\)</span>下的椭圆曲线<span class="math inline">\(E:y^2=x^3+x\)</span>，可以通过如下代码得到对应的上述映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_numerator(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_denominator(<span class="number">2</span>))</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[[2]:E\mapsto E,x\mapsto\frac{x^4 + 429x^2 + 1}{4x^3 + 4x}\]</span> 我们令分母<span class="math inline">\(4x^3+4x=4(x^3+x)=0\)</span>，得到三个解<span class="math inline">\(0,i,-i\)</span>，据此我们就可以得到一个<span class="math inline">\(E\)</span>的一个子群<span class="math inline">\(\ker([2])=\{(0,0),(i,0),(-i,0),\mathcal{O}\}\)</span>，而且这三个点都可以确定一个二阶循环子群，我们可以通过sage的<code>division_points</code>方法对<span class="math inline">\(E\)</span>的零元开二次根来达到这一目的：<code>E(0).division_points(2)</code>，参考资料2中给出了这样一个图来描述<span class="math inline">\(\ker([2])\)</span>： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261959041.png" alt="image-20250226195932625" /> 在这里每个“花瓣”对应一个二阶循环子群。相应的，还有三倍点映射<span class="math inline">\([3]\)</span>，对于蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，其对应三倍点映射为： <span class="math display">\[[3]:E\mapsto E:x\mapsto\frac{x(x^4-6x^2-4ax^3-3)^2}{(3x^4+4ax^3+6x^2-1)^2}\]</span> 通过令分母等于<span class="math inline">\(0\)</span>我们可以得到四个根<span class="math inline">\(\beta,\delta,\zeta,\theta\)</span>，通过这四个根我们可以得到八个阶为<span class="math inline">\(3\)</span>的点：<span class="math inline">\((\beta,\pm\gamma),(\delta,\pm\epsilon),(\zeta,\pm\eta),(\theta,\pm\iota)\)</span>，这八个点加上无穷远点可以构成子群<span class="math inline">\(\ker([3])\simeq\mathbb{Z}_3\times\mathbb{Z}_3\)</span>，也可以叫做<span class="math inline">\(3\)</span>-torsion，<span class="math inline">\(3\)</span>-torsion的结构如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262000994.png" alt="image-20250226200054634" /></p><p>这里每个“花瓣”对应一个三阶循环子群。推广到一般情况，所有阶为<span class="math inline">\(l\)</span>的点（<span class="math inline">\(p\nmid l\)</span>）与<span class="math inline">\(\mathcal{O}\)</span>构成的子群就是<span class="math inline">\(\ker([l])\simeq \mathbb{Z}_l\times\mathbb{Z}_l\)</span>（或者称为<span class="math inline">\(l\)</span>-torsion)，而若<span class="math inline">\(l\)</span>为质数，则可以得到<span class="math inline">\(l+1\)</span>个<span class="math inline">\(l\)</span>阶循环子群</p><h4 id="可分同源">可分同源</h4><p>可分同源的定义为对于一条曲线<span class="math inline">\(E\)</span>上的椭圆曲线群以及它的一个子群<span class="math inline">\(G\)</span>，可以构造出唯一的同源<span class="math inline">\(\phi:E\mapsto E&#39;\)</span>，使得<span class="math inline">\(\ker(\phi)=G\)</span>，这样得到的曲线<span class="math inline">\(E&#39;\)</span>称为该同源的陪域（codomain），可以表示为<span class="math inline">\(E/G\)</span>。可分同源的另一种定义（Velu's formulas）是：输入一条椭圆曲线<span class="math inline">\(E\)</span>以及其子群<span class="math inline">\(G\)</span>的所有点，输出陪域<span class="math inline">\(E/G\)</span>以及对应的映射<span class="math inline">\(\phi\)</span>。</p><blockquote><p>由于<span class="math inline">\(\ker(\phi)=G\)</span>，所以对于任意点<span class="math inline">\(P\in G\)</span>，都有<span class="math inline">\(\phi(P)=\mathcal{O}\)</span></p></blockquote><p>以蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>为例，设其上一个二阶子群为<span class="math inline">\(G=\{\mathcal{O},(\alpha,0)\}\)</span>，我们可以以<span class="math inline">\(G,E\)</span>作为输入，得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{x(\alpha x-1)}{x-\alpha}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2=x^3+2(1-2\alpha^2)x^2+x\)</span>，这个映射被用于计算蒙哥马利曲线的2-同源（2-isogeny），对<span class="math inline">\(GF(431^2)\)</span>下的超奇异曲线<span class="math inline">\(E:y^2=x^3+(208i+161)x^2+x\)</span>，我们知道<span class="math inline">\(j(E)=364i+304\)</span>，则可以通过如下代码求得其一个<span class="math inline">\(2\)</span>-同源并确保其输出的陪域为蒙哥马利曲线： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">ker2 = E(<span class="number">0</span>).division_points(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [(0 : 1 : 0), (0 : 0 : 1), (350*i + 68 : 0 : 1), (304*i + 202 : 0 : 1)]</span></span><br><span class="line"></span><br><span class="line">alpha = ker2[<span class="number">2</span>]</span><br><span class="line">phi = E.isogeny(alpha, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">E_ = phi.codomain()</span><br><span class="line"><span class="built_in">print</span>(E_)</span><br><span class="line"><span class="built_in">print</span>(E_.j_invariant())</span><br></pre></td></tr></table></figure> 可以得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{(-81i + 68)x^2 - x}{x + (81i - 68)}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2 = x^3 + (102i+423)x^2 + x\)</span>，其<span class="math inline">\(j\)</span>-不变量<span class="math inline">\(j(E&#39;)=344i+190\)</span>，所以我们可以知道：同源会使其<span class="math inline">\(j\)</span>不变量发生变化。</p><h4 id="d-同源"><span class="math inline">\(d\)</span>-同源</h4><p>对于同源<span class="math inline">\(\phi\)</span>，我们称<span class="math inline">\(|\ker(\phi)|\)</span>为同源的度，度为<span class="math inline">\(d\)</span>的同源称为<span class="math inline">\(d\)</span>-同源，例如前面提到的<span class="math inline">\(2\)</span>-同源.</p><h4 id="sage上的同源">sage上的同源</h4><p>我们一般用sage的<code>isogeny</code>方法来计算同源，其函数原型如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isogeny(_kernel_, _codomain=None_, _degree=None_, _model=None_, _check=True_, _algorithm=None_, _velu_sqrt_bound=None_)</span><br></pre></td></tr></table></figure> 重要的参数如下：</p><ul><li><p><code>_kernel_</code>：就是前面提到输入的<span class="math inline">\(G\)</span>，可以是一个点，可以是点列，也可以是本原核多项式</p></li><li><p><code>codomain</code>：陪域，输入为一条椭圆曲线，这样生成的同源的陪域就是这条椭圆曲线</p></li><li><p><code>model</code>：输出的陪域的形式，有三种可选参数：</p></li></ul><ol type="1"><li><code>'minimal'</code>，输出全局最小的椭圆曲线</li><li><code>'short_weierstrass'</code>，输出short Weierstrass曲线，即由<span class="math inline">\(y^2=x^3+ax+b\)</span>形式的方程所定义的椭圆曲线</li><li><code>'montgomery'</code>输出蒙哥马利曲线</li></ol><ul><li><code>algorithm</code>：算法，有三种可选参数（均为自己的理解，可能不准确）：</li></ul><ol type="1"><li><code>'velusqrt'</code>，使用平方根Vélu算法</li><li><code>'factored'</code>，将度分解到为质因子之后再求解</li><li><code>'traditional'</code>，传统算法</li></ol><h3 id="同源图isogeny-graph">同源图（Isogeny graph）</h3><p>对于一个固定的<span class="math inline">\(p\)</span>，我们用<span class="math inline">\(GF(p^2)\)</span>中所有的超奇异<span class="math inline">\(j\)</span>-不变量各构造一条曲线，在每条曲线的<span class="math inline">\(\ker([l])\)</span>中取除了无穷远点外的所有点分别进行同源，将原来曲线的<span class="math inline">\(j\)</span>-不变量作为起点，同源得到的陪域的<span class="math inline">\(j\)</span>-不变量作为终点，就可以得到一个无向图，称为同源图，例如在参考资料2中给出的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006853.png" alt="image-20250226200558759" /> 通过同源图，我们可以知道超奇异曲线的<span class="math inline">\(j\)</span>-不变量在同源时的变化路线. 可以通过如下算法求<span class="math inline">\(GF(p^2)\)</span>下的<span class="math inline">\(\ker([l])\)</span>的同源图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">IsogenyGraph</span>(<span class="params">p, l=<span class="number">2</span>, vertex_size=<span class="number">3750</span>, size=[<span class="number">20</span>, <span class="number">20</span>]</span>):</span><br><span class="line">    R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    jlist = &#123;&#125;</span><br><span class="line">    Elist = []</span><br><span class="line"></span><br><span class="line">    E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span> E.is_supersingular()</span><br><span class="line">    jlist[E.j_invariant()] = <span class="built_in">set</span>()</span><br><span class="line">    Elist.append(E)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Elist:</span><br><span class="line">        tmp = Elist.pop()</span><br><span class="line">        kerl = tmp(<span class="number">0</span>).division_points(l)</span><br><span class="line">        <span class="keyword">for</span> P <span class="keyword">in</span> kerl:</span><br><span class="line">            <span class="keyword">if</span> P != tmp(<span class="number">0</span>):</span><br><span class="line">                phi = tmp.isogeny(P, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">                E2 = phi.codomain()</span><br><span class="line">                j = E2.j_invariant()</span><br><span class="line">                <span class="comment"># print(tmp.j_invariant(), j)</span></span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist:</span><br><span class="line">                    jlist[j] = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist[tmp.j_invariant()]:</span><br><span class="line">                    jlist[tmp.j_invariant()].add(j)</span><br><span class="line">                    Elist.append(E2)</span><br><span class="line"></span><br><span class="line">    Tab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> jlist:</span><br><span class="line">        Tab[x] = <span class="built_in">list</span>(jlist[x])</span><br><span class="line">    G = Graph(Tab)</span><br><span class="line"></span><br><span class="line">    G.set_pos(G.layout_circular())</span><br><span class="line">    G.plot(vertex_labels=<span class="literal">True</span>,vertex_size=vertex_size).show(figsize=size)</span><br></pre></td></tr></table></figure><p>通过这个算法画出来的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图长这样： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261957075.png" alt="output" /></p><h2 id="超奇异同源diffie-hellman密钥交换体系sidh">超奇异同源Diffie-Hellman密钥交换体系（SIDH）</h2><h3 id="sidh协议细节">SIDH协议细节</h3><p>首先密钥交换双方（以下称为Alice和Bob）协商选取模数<span class="math inline">\(p=2^a3^b-1\)</span>，其中<span class="math inline">\(2^a\approx 3^b\)</span>，然后选取一条<span class="math inline">\(GF(p^2)\)</span>下的超奇异椭圆曲线<span class="math inline">\(E\)</span>，在此之后，Alice选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(2^a\)</span>的两点<span class="math inline">\(P_A,Q_A\)</span>并公开，Bob选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(3^b\)</span>的两点<span class="math inline">\(P_B,Q_B\)</span>并公开（在选取的时候，需要保证<span class="math inline">\(P_A,Q_A\)</span>线性无关，<span class="math inline">\(P_B,Q_B\)</span>线性无关）。 Alice随机选取秘密值<span class="math inline">\(k_A\in\{0,1,\cdots,2^a-1\}\)</span>，计算<span class="math inline">\(S_A=P_A+k_AQ_A\)</span>，并通过<span class="math inline">\(S_A\)</span>计算同源<span class="math inline">\(\phi_A:E\mapsto E_A\)</span>，其中<span class="math inline">\(E_A=E/\langle S_A\rangle\)</span>，<span class="math inline">\(\phi_A\)</span>由<span class="math inline">\(a\)</span>个<span class="math inline">\(2\)</span>-同源组合而成，最后使用<span class="math inline">\((E_A,\phi_A(P_B),\phi_A(Q_B))\)</span>作为公钥，<span class="math inline">\((k_A,S_A)\)</span>作为私钥； 同样的，Bob随机选取秘密值<span class="math inline">\(k_B\in\{0,1,\cdots,3^b-1\}\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B\)</span>，通过<span class="math inline">\(S_B\)</span>计算同源<span class="math inline">\(\phi_B:E\mapsto E_B\)</span>，其中<span class="math inline">\(\phi_B\)</span>由<span class="math inline">\(b\)</span>个<span class="math inline">\(3\)</span>-同源组合而成，使用<span class="math inline">\((E_B,\phi_B(P_A),\phi_B(Q_A))\)</span>作为公钥，<span class="math inline">\((k_B,S_B)\)</span>作为私钥。 通过上述计算得到的公钥，Alice可以计算出<span class="math inline">\(S_{A}&#39;=\phi_B(P_A)+k_A\phi_B(Q_A)\)</span>，计算同源<span class="math inline">\(\phi_A&#39;:E_B\mapsto E_{AB}\)</span>，就可以计算出<span class="math inline">\(j_{AB}=j(E_{AB})\)</span>，同样的，Bob可以计算出<span class="math inline">\(S_{B}&#39;=\phi_A(P_B)+k_B\phi_A(Q_B)\)</span>，然后计算同源<span class="math inline">\(\phi_B&#39;:E_A\mapsto E_{BA}\)</span>，从而可以计算出<span class="math inline">\(j_{BA}=j(E_{BA})\)</span>，有<span class="math inline">\(j_{AB}=j_{BA}\)</span>，所以共享密钥值为<span class="math inline">\(j=j_{AB}=j_{BA}\)</span>.</p><h4 id="sidh实例">SIDH实例</h4><blockquote><p>本样例来源于参考资料2</p></blockquote><p>Alice和Bob协商选取模数<span class="math inline">\(p=2^43^3-1=431\)</span>，并选取<span class="math inline">\(GF(p^2)\)</span>上的一条超奇异椭圆曲线： <span class="math display">\[E:y^2=x^3+(329i+423)x^2+x\]</span> 有<span class="math inline">\(j(E)=87i+190\)</span>，Alice从中选取两个阶为<span class="math inline">\(2^4\)</span>的点： <span class="math display">\[P_A=(100i+248,304i+199),Q_A=(426i+394,51i+79)\]</span> 同时Bob从中选取两个阶为<span class="math inline">\(3^3\)</span>的点： <span class="math display">\[P_B = (358i+275, 410i+104),Q_B = (20i+185, 281i+239)\]</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">2</span>^<span class="number">4</span> * <span class="number">3</span>^<span class="number">3</span> - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, a, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span></span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure> 然后Alice从<span class="math inline">\(\{0,1,\cdots,2^4-1\}\)</span>中选择<span class="math inline">\(k_A=11\)</span>，据此计算<span class="math inline">\(S_A=P_A+k_AQ_A=(271i + 79, 153i + 430)\)</span>，我们可以通过如下算法计算同源路径从而得到<span class="math inline">\(S_A\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262005508.png" alt="image-20250226200532409" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line"></span><br><span class="line">SA_, EA_, PB_, QB_ = SA, E, PB, QB</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(a-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RA_ = SA_ * <span class="number">2</span>^e</span><br><span class="line">    phi = EA_.isogeny(-RA_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SA_, EA_, PB_, QB_ = phi(SA_), phi.codomain(), phi(PB_), phi(QB_)</span><br><span class="line"></span><br><span class="line">phiA = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiA = phiA * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_A:y^2 = x^3 + (128i+19)x^2 + x\)</span>，<span class="math inline">\(\phi_A(P_B)=(130i + 170,428i + 290)\)</span>，<span class="math inline">\(\phi_A(Q_B)=(235i+209,126i+15)\)</span>； 同理，Bob在<span class="math inline">\(\{0,1,\cdots,3^3-1\}\)</span>中选择<span class="math inline">\(k_B=2\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B=(122i +309, 291i+374)\)</span>，那么我们可以通过如下算法计算出<span class="math inline">\(S_B\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262003851.png" alt="image-20250226200334440" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line">SB_, EB_, PA_, QA_ = SB, E, PA, QA</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(b-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RB_ = SB_ * <span class="number">3</span>^e</span><br><span class="line">    phi = EB_.isogeny(RB_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SB_, EB_, PA_, QA_ = phi(SB_), phi.codomain(), phi(PA_), phi(QA_)</span><br><span class="line"></span><br><span class="line">phiB = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiB = phiB * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_B:y^2 = x^3 + (329i+8)x^2 + x\)</span>，<span class="math inline">\(\phi_B(P_A)=(160i + 421, 246i + 252)\)</span>，<span class="math inline">\(\phi_B(Q_A)=(119i+14, 246i + 138)\)</span> 这样双方的公钥均已经计算出来，最后Alice就可以通过自己的私钥计算出： <span class="math display">\[S_{A}&#39;=\phi_B(P_A)+k_A\phi{(Q_A)}\]</span> 再通过上述算法计算出Alice侧<span class="math inline">\(S_{A}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_A/\langle S_{A}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，同样的，Bob可以通过自己的私钥计算出： <span class="math display">\[S_{B}&#39;=\phi_A(P_B)+k_B\phi{(Q_A)}\]</span> 再通过上述算法计算出Bob侧<span class="math inline">\(S_{B}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_B/\langle S_{B}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，可以通过下列代码计算出共享密钥： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA_.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Bob_shared_secret)</span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB_.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 可以计算出共享密钥为<span class="math inline">\(234\)</span>，整理并优化代码后可以得到： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">p = <span class="number">2</span>^a * <span class="number">3</span>^b - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">A = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, A, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span> <span class="keyword">and</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br><span class="line"></span><br><span class="line">kA = <span class="number">11</span></span><br><span class="line">SA = PA + kA * QA</span><br><span class="line">phiA = E.isogeny(SA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">PB_ = phiA(PB)</span><br><span class="line">QB_ = phiA(QB)</span><br><span class="line"></span><br><span class="line">kB = <span class="number">2</span></span><br><span class="line">SB = PB + kB * QB</span><br><span class="line">phiB = E.isogeny(SB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">PA_ = phiB(PA)</span><br><span class="line">QA_ = phiB(QA)</span><br><span class="line"></span><br><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> Bob_shared_secret == Alice_shared_secret</span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 或者可以将封装公钥和计算私钥封装为函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_public_key</span>(<span class="params">E, P1, Q1, s, P2, Q2</span>):</span><br><span class="line">    S = P1 + s*Q1</span><br><span class="line">    phi = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi, (phi.codomain(), phi(P2), phi(Q2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_shared_secret</span>(<span class="params">E, P, Q, s</span>):</span><br><span class="line">    S = P + s*Q</span><br><span class="line">    phi1 = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi1.codomain().j_invariant()</span><br></pre></td></tr></table></figure></p><h3 id="sidh的安全性">SIDH的安全性</h3><p>理论上SIDH的安全性主要依赖于通过公钥中给出的曲线来求出它对应的同源。但是在2022年SIDH就被宣布完全破解，在Github上就有代码：<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>，<del>要用的话拔出来用就行</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1711.04062&quot;&gt;Mathematics of Isogeny Based Cryptography&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>通过狄利克雷近似解决HNP-2H</title>
    <link href="https://triodelzx.github.io/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/"/>
    <id>https://triodelzx.github.io/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/</id>
    <published>2024-11-30T11:51:16.000Z</published>
    <updated>2024-11-30T16:24:39.594Z</updated>
    
    <content type="html"><![CDATA[<p>最近在复现Crypto CTF 2024的时候碰到一道题考察了HNP-2H（Hidden Number Problem with 2 Holes，双洞隐藏数问题），在做题的时候，找到了一篇论文：<a href="https://link.springer.com/content/pdf/10.1007/978-3-540-74462-7_9.pdf?pdf=inline+link">Extended Hidden Number Problem and Its Cryptanalytic Applications</a>，并通过这篇论文了解到可以通过狄利克雷近似定理来将HNP-2H约化为我们熟悉的HNP来解决。</p><h2 id="hnp-2h的定义">HNP-2H的定义</h2><p>这里直接引用论文中的定义：</p><p>设<span class="math inline">\(N\)</span>是一个质数，并设<span class="math inline">\(x\in \mathbb{Z}_n\)</span>是一个部分未知的整数满足以下<span class="math inline">\(d\)</span>条同余式： <span class="math display">\[\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N},\ 1\le i\le d\]</span> 其中<span class="math inline">\(\alpha_i\)</span>满足<span class="math inline">\(\alpha_i\mod{N}\neq0\)</span>，<span class="math inline">\(\alpha_i,\rho_{i,1},\rho_{i,2}\)</span>以及<span class="math inline">\(\beta_i\)</span>（<span class="math inline">\(1\le i\le d\)</span>）为已知量，未知量<span class="math inline">\(k_{i,1}\)</span>与<span class="math inline">\(k_{i,2}\)</span>满足<span class="math inline">\(0\le k_{i,1}\le2^{\mu_1}\)</span>及<span class="math inline">\(0\le k_{i,2}\le2^{\mu_2}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），其中<span class="math inline">\(\mu_1,\mu_2\)</span>为已知有理常量，则双洞隐藏数问题（Hidden Number Problem with 2 Holes）就是通过以上条件求出<span class="math inline">\(x\)</span>。</p><h2 id="使用狄利克雷近似解决hnp-2h">使用狄利克雷近似解决HNP-2H</h2><p>在使用狄利克雷近似解决HNP-2H之前，我们需要先了解何谓狄利克雷近似，其阐述如下</p><h3 id="狄利克雷近似dirichlets-approximation定理以及其推论">狄利克雷近似（Dirichlet's approximation）定理以及其推论</h3><p><strong>狄利克雷近似定理：</strong>设<span class="math inline">\(\alpha\in\mathbb{R}\)</span>以及<span class="math inline">\(0&lt;\varepsilon\le1\)</span>为两已知量，那么存在<span class="math inline">\(p,q\in\mathbb{Z}\)</span>使得<span class="math inline">\(1\le q\le\frac{1}{\varepsilon}\)</span>以及<span class="math inline">\(|\alpha-\frac{p}{q}|&lt;\frac{\varepsilon}{q}\)</span>成立。</p><p>通过这个定理，我们可以得到如下推论：</p><p>假定我们已知<span class="math inline">\(A,N\in\mathbb{Z}\)</span>与<span class="math inline">\(B\in\mathbb{R}\)</span>满足<span class="math inline">\(B\ge1\)</span>且<span class="math inline">\(N&gt;0\)</span>那么存在<span class="math inline">\(\lambda\in\mathbb{Z}\)</span>满足<span class="math inline">\(1\le\lambda\le B\)</span>且<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>.（<span class="math inline">\(|a|_N\)</span>表示<span class="math inline">\(min_{k\in\mathbb{Z}}|a-kN|\)</span>）</p><p>通过狄利克雷近似定理以及其推论，我们可以知道，在已知<span class="math inline">\(B\)</span>的情况下，我们可以通过连分数在多项式时间内通过<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>求解出<span class="math inline">\(\lambda\)</span></p><h3 id="借助狄利克雷近似解决hnp-2h">借助狄利克雷近似解决HNP-2H</h3><blockquote><p>本部分摘自论文第三部分的 Theorem 3 的证明</p></blockquote><p>令<span class="math inline">\(A_i=(\rho_{i,1})^{-1}\rho_{i,2}\mod{N}\)</span>，<span class="math inline">\(\gamma_i=k_{i,1}+A_ik_{i,2}\)</span>，<span class="math inline">\(\alpha_i&#39;=(\rho_{i,1})^{-1}\alpha_i\mod{N}\)</span>以及<span class="math inline">\(\beta_i&#39;=(\rho_{i,1})^{-1}\beta_i\mod{N}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），则同余式<span class="math inline">\(\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N}\)</span>可以转化为： <span class="math display">\[\alpha_i&#39;x+\gamma_i\equiv\beta&#39;_i\pmod{N}\]</span> 我们选定一个大于1的实数<span class="math inline">\(B\)</span>，由狄利克雷近似的推论，我们可以通过连分数找到一个非零整数<span class="math inline">\(\lambda_{i,B}\)</span>满足<span class="math inline">\(|\lambda_{i,B}A_i|&lt;\frac{N}{B}\)</span>，且有<span class="math inline">\(1\le\lambda_{i,B}\le B\)</span>（<span class="math inline">\(1\le i\le d\)</span>），使得下面的关系成立： <span class="math display">\[\begin{aligned}|\lambda_{i,B}\gamma_i|_N&amp;=|\lambda_{i,B}k_{i,1}+\lambda_{i,B}A_ik_{i,2}|_N\\&amp;\le|\lambda_{i,B}|_Nk_{i,1}+|\lambda_{i,B}A_i|_Nk_{i,2}\\&amp;&lt;B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\end{aligned}\]</span> 选择<span class="math inline">\(B_{min}=N^{\frac{1}{2}}2^{\frac{\mu_2-\mu_1}{2}}\)</span>可以最大限度地减少<span class="math inline">\(B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\)</span>的上界（此时<span class="math inline">\(B_{min}2^{\mu_1}+\frac{N}{B_{min}}2^{\mu_2}=N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\)</span>）.</p><p>在此之后，我们设<span class="math inline">\(k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{N}\)</span>，可以知道：<span class="math inline">\(k_i&#39;&lt;N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}\)</span>，那么通过下述步骤，我们就可以将HNP-2H转化为HNP，从而通过一般HNP的解决方法来解决HNP-2H了： <span class="math display">\[\begin{aligned}\alpha_i&#39;x+\gamma_i&amp;\equiv\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+\lambda_{i,B_{min}}\gamma_i&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+k_i&#39;&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\pmod{N}\\\alpha_i&#39;&#39;x+k_i&#39;&amp;\equiv\beta_i&#39;&#39;\pmod{N},\ (1\le i\le d)\end{aligned}\]</span></p><h2 id="例crypto-ctf-2024-honey">例：[Crypto CTF 2024] Honey</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_params</span>(<span class="params">nbit</span>):  </span><br><span class="line">    p, Q, R, S = getPrime(nbit), [], [], []  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(nbit &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       Q.append(getRandomRange(<span class="number">1</span>, p - <span class="number">1</span>))  </span><br><span class="line">       R.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">       S.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">return</span> p, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m, params</span>):  </span><br><span class="line">    p, Q, R, S = params  </span><br><span class="line">    <span class="keyword">assert</span> m &lt; p  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(p.bit_length() &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    C = []  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       r, s = [getRandomNBitInteger(d) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&#x27;01&#x27;</span>]  </span><br><span class="line">       c = Q[_] * m + r * R[_] + s * S[_]  </span><br><span class="line">       C.append(c % p)  </span><br><span class="line">    <span class="keyword">return</span> C  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">nbit = <span class="number">512</span>  </span><br><span class="line">params = gen_params(<span class="number">512</span>)  </span><br><span class="line">m = bytes_to_long(flag)  </span><br><span class="line">C = encrypt(m, params)  </span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;params_enc.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;p = <span class="subst">&#123;params[<span class="number">0</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;Q = <span class="subst">&#123;params[<span class="number">1</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;R = <span class="subst">&#123;params[<span class="number">2</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;S = <span class="subst">&#123;params[<span class="number">3</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;C = <span class="subst">&#123;C&#125;</span>&#x27;</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>整理可得方程组： <span class="math display">\[C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\]</span> 其中<span class="math inline">\(i=1,2,\cdots,d\)</span>，而<span class="math inline">\(C_i,Q_i,R_i,S_i\)</span>以及<span class="math inline">\(p\)</span>均已知，而且知道<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，要求<span class="math inline">\(m\)</span>，显然，这是HNP-2H，那么我们可以通过上面讲的方法来将其约化为HNP来求解，有<span class="math inline">\(A_i=R_i^{-1}S_i\mod{p}\)</span>，<span class="math inline">\(\gamma_{i}=r_i+A_is_i\)</span>，<span class="math inline">\(\alpha_i&#39;= R_i^{-1}Q_i\mod{p}\)</span>，<span class="math inline">\(\beta_i&#39;=R_i^{-1}C_i\mod{p}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），可以将方程<span class="math inline">\(C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\)</span>变为： <span class="math display">\[\alpha_i&#39;m+\gamma_i\equiv \beta_i&#39;\pmod{p}\]</span> 由于<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，那么我们可以取<span class="math inline">\(\mu_1=\mu_2=32\)</span>，那么我们取<span class="math inline">\(B_{min}=p^{\frac{1}{2}}2^{\frac{\mu_2-\mu_i}{2}}=p^{\frac{1}{2}}\)</span>，则可以利用连分数计算出满足条件的<span class="math inline">\(\lambda_{i,B_{min}}\)</span>，算法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在求出<span class="math inline">\(\lambda_{i,B_{min}}\)</span>之后，我们可以得到： <span class="math display">\[k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{p}=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{33}\rfloor\right)\mod{p}\]</span> 可以得到<span class="math inline">\(\{k_1,k_2,\cdots,k_d\}\)</span>的上界<span class="math inline">\(K=p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}=p^{\frac{1}{2}}2^{34}\)</span>.这样我们就可以将这个问题约化为一般的HNP进行求解，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Q = [...]</span><br><span class="line">R = [...]</span><br><span class="line">S = [...]</span><br><span class="line">C = [...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">len</span>(Q)</span><br><span class="line">A = []</span><br><span class="line">B = p.isqrt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    a = inverse(R[i], p) * S[i] % p</span><br><span class="line">    A.append(a)</span><br><span class="line"></span><br><span class="line">alpha = []</span><br><span class="line">beta = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    lambda_i = getLambda(A[i])</span><br><span class="line">    a = inverse(R[i], p) * Q[i] * lambda_i % p</span><br><span class="line">    b = (inverse(R[i], p) * C[i] * lambda_i + floor(B * <span class="number">2</span>^<span class="number">33</span>)) % p</span><br><span class="line">    alpha.append(a)</span><br><span class="line">    beta.append(b)</span><br><span class="line"></span><br><span class="line">K = p.isqrt() * <span class="number">2</span>^<span class="number">34</span></span><br><span class="line"></span><br><span class="line">L = matrix(QQ, d+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    L[i, i] = p</span><br><span class="line">    L[-<span class="number">2</span>, i] = alpha[i]</span><br><span class="line">    L[-<span class="number">1</span>, i] = beta[i]</span><br><span class="line"></span><br><span class="line">L[-<span class="number">2</span>, -<span class="number">2</span>] = K / p</span><br><span class="line">L[-<span class="number">1</span>, -<span class="number">1</span>] = K</span><br><span class="line"></span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line">v = res[<span class="number">1</span>]</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">abs</span>(v[-<span class="number">2</span>] * p / K))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行可得flag：<code>CCTF&#123;3X7eNdED_H!dD3n_nNm8eR_pR0Bl3m_iN_CCTF!!&#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在复现Crypto CTF 2024的时候碰到一道题考察了HNP-2H（Hidden Number Problem with 2 Holes，双洞隐藏数问题），在做题的时候，找到了一篇论文：&lt;a href=&quot;https://link.springer.com/conte</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
    <category term="格密码" scheme="https://triodelzx.github.io/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>已知两质因数半数以上随机位的大整数分解</title>
    <link href="https://triodelzx.github.io/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/"/>
    <id>https://triodelzx.github.io/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/</id>
    <published>2024-11-27T14:14:30.000Z</published>
    <updated>2024-11-27T15:29:38.899Z</updated>
    
    <content type="html"><![CDATA[<p>在解决RSA问题的过程中，我们往往会需要对一个大整数<span class="math inline">\(n\)</span>进行质因数分解，在已知部分连续位的时候，我们经常会考虑使用Copper Smith方法来进行分解，但是若我们知道的是随机分散的位，Copper Smith方法将会失效，例如我们知道由两个质因数相乘得到的一个大整数<span class="math inline">\(n=pq\)</span>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span><br></pre></td></tr></table></figure><p>又已知<span class="math inline">\(p\)</span>的部分已知位（二进制表示，其中下划线为未知位，下同）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___</span><br></pre></td></tr></table></figure><p>与<span class="math inline">\(q\)</span>的部分已知位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___</span><br></pre></td></tr></table></figure><p>显然，我们不能使用Copper Smith方法进行分解。</p><p>为应对这种情况，大佬y011d4在Github上发布了一个项目：<a href="https://github.com/y011d4/factor-from-random-known-bits">y011d4/factor-from-random-known-bits</a>，我们可以使用这个项目对上述的情况进行分解。</p><p>下载方法（推荐Linux）：</p><ul><li><p>首先确保系统中有Rust环境（因为这个项目主要是由Rust语言编写的）</p></li><li>使用<code>git clone https://github.com/y011d4/factor-from-random-known-bits.git</code>从Github上将该项目拉下来</li><li><p><code>cd factor-from-random-known-bits</code>进入项目文件夹后依次运行<code>pip install -r requirements.txt</code>以及<code>python setup.py install</code></p></li></ul><p>在此之后就可以通过在Python中<code>import factor</code>后使用这个方法进行分解了。</p><blockquote><p>假若安装时报错，则有可能是系统中缺少 <code>m4</code> 这个宏处理器，可以通过<code>sudo apt-get install m4</code>来安装这个宏处理器.</p></blockquote><h2 id="适用条件">适用条件</h2><ul><li>已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位</li></ul><h2 id="使用方法">使用方法</h2><p>这个库有两种使用方法：<code>from_str</code>以及<code>from_vector</code></p><h3 id="from_str"><code>from_str</code></h3><p>以前面的数据为例，则可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = <span class="string">&quot;1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___&quot;</span></span><br><span class="line">q_known = <span class="string">&quot;110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___&quot;</span></span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">8996460061304658501483536370547552107653796408964122401908135206811298639114618429412462572834106148254319079697639081615546751035691609086377055207530819</span></span><br><span class="line">q = <span class="number">11577771027337574615881755252249566401199602697310825312674761422549781992489861876313558348484109945826438743090783573542794191930931862927421766237119653</span></span><br></pre></td></tr></table></figure><p>在这里，我们将未知的位置为下划线。</p><h3 id="from_vector"><code>from_vector</code></h3><p>以前面的数据为例，也可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">q_known = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到相同的结果。</p><p>在这种用法中，我们将未知的位设置为-1</p><blockquote><p>注意：虽然适用条件中说已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位就能使用，但是在某次测试中发现<span class="math inline">\(p\)</span>与<span class="math inline">\(q\)</span>均已知50.05%的位的时候其实是用不了的，这种时候就要通过爆破来知道尽可能多的位。</p></blockquote><h2 id="使用例bcactf-5.0-superstitious-2">使用例：[BCACTF 5.0 Superstitious 2]</h2><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myGetPrime</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = getRandomNBitInteger(<span class="number">1024</span>) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">1024</span>) - <span class="number">1</span>)//<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(x):</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">p = myGetPrime()</span><br><span class="line">q = myGetPrime()</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">m = bytes_to_long(message.read())</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;superstitious-2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>).write(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>\ne = <span class="subst">&#123;e&#125;</span>\nc = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以知道<code>((1 &lt;&lt; 1024) - 1)//3</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101</span><br></pre></td></tr></table></figure><p>所以我们可以知道<span class="math inline">\(p\)</span>以及<span class="math inline">\(q\)</span>约半数的位为0，以及最低位为1（因为<span class="math inline">\(p\)</span>,<span class="math inline">\(q\)</span>必为奇数），所以我们将除了最低位的所有1都替换为下划线后通过Cyberchef统计之后可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325392.png" alt="image-20241127232058419" /><figcaption>image-20241127232058419</figcaption></figure><p>有50.05%的位已知，显然可以利用本文说的方法来进行分解，但是实际操作发现只知道这么多位并不能直接分解<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>，所以我们需要对<span class="math inline">\(p\)</span>进行小范围爆破，所以我们可以通过如下脚本来进行求解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">550201148354755741271315125069984668413716061796183554308291706476140978529375848655819753667593579308959498512392008673328929157581219035186964125404507736120739215348759388064536447663960474781494820693212364523703341226714116205457869455356277737202439784607342540447463472816215050993875701429638490180199815506308698408730404219351173549572700738532419937183041379726568197333982735249868511771330859806268212026233242635600099895587053175025078998220267857284923478523586874031245098448804533507730432495577952519158565255345194711612376226297640371430160273971165373431548882970946865209008499974693758670929</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">12785320910832143088122342957660384847883123024416376075086619647021969680401296902000223390419402987207599720081750892719692986089224687862496368722454869160470101334513312534671470957897816352186267364039566768347665078311312979099890672319750445450996125821736515659224070277556345919426352317110605563901547710417861311613471239486750428623317970117574821881877688142593093266784366282508041153548993479036139219677970329934829870592931817113498603787339747542136956697591131562660228145606363369396262955676629503331736406313979079546532031753085902491581634604928829965989997727970438591537519511620204387132</span></span><br><span class="line"></span><br><span class="line">binlist = []</span><br><span class="line">s = <span class="string">&quot;_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_01&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    b = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    ns = <span class="built_in">list</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        ns[<span class="number">2</span>*i] = b[i]</span><br><span class="line">    binlist.append(<span class="string">&quot;&quot;</span>.join(ns))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pknown <span class="keyword">in</span> tqdm.tqdm(binlist):</span><br><span class="line">    ps = factor.from_str(n, pknown, s)</span><br><span class="line">    <span class="keyword">if</span> ps != <span class="literal">None</span>:</span><br><span class="line">        p, q = ps</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = inverse(e, phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在这里，我们通过爆破<span class="math inline">\(p\)</span>的高16位中的8个未知位将<span class="math inline">\(p\)</span>的已知位提升了8位，将补充的位全部置0再进行统计可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325083.png" alt="image-20241127232521024" /><figcaption>image-20241127232521024</figcaption></figure><p>这时候<span class="math inline">\(p\)</span>的已知部分变成了50.83%，应该可以进行有效分解了。运行脚本之后我们就可以得到flag：</p><blockquote><p>bcactf{l4zy_cHall3nG3_WRITinG_f8b335319e464}</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在解决RSA问题的过程中，我们往往会需要对一个大整数&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;进行质因数分解，在已知部分连续位的时候，我们经常会考虑使用Copper Smith方法来进行分解，但是若我们知道的是随机分散的位，Copper S</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>若尔当标准型与矩阵离散对数问题</title>
    <link href="https://triodelzx.github.io/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>https://triodelzx.github.io/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/</id>
    <published>2024-07-12T15:04:20.000Z</published>
    <updated>2025-03-07T09:45:43.017Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="79f33b54db3fc7f853c0f07ab2ee2e43a5ae848355e8756a003ea7585b7739ac">9d7b23e04ef1f7ada047aa935a403390ba20400c1e6252426b7766a05d9ac7cf850286b54f7741cd6d7d49a5d39429cc74260307b6f10815d61699123a047fdfdbbb61dfcfbc048a99e1e42cb8c2de6cf0385a82a9d8dcafaac6a66435ffb91f31aae0d1608c4a64f6940a792ce4248c96b01a919a1c6cae23a9c3160a2ccf2cca1f90b11b71605eda06ea9bde215a2824f4a799216c9c6beb931a565ba7d8dd3bf9655f1f4828a7419189cdec2a6bc70a6efcd7977453fb7694220b6cc5855a84e0579f31aefb792c8f8e8b9671567d65ff9dd77ef874738057157d5faa7c77a251002d6763109b6f4438db7f8a05770e6b114d151ba3a11f4bfe99c4e59370acf032484d20997555b3f4d0add73c75b1cc6830ba081c2b4e38a1ce22af213a28684c576a571191a99d62fdc7bf8dfe6deb8718c0a8bac29651300f5171278ed2b0bfd56033809dd703c332233404c2b05f6ec1116ace2aa6fae4ed23a830ece3a74fb432aec3a0e3f311f72a93a63f08b2b241927ebe593df7c5ee1c5ad7555c70115b0bb72da2896c4aafa40b152e09ee4ed283584a20b4d2a722b88967b104767d1bc21bccb3fe0f217f1d2cec9f4f7a38ce2c2dd5e074202aa55ef4a8abee550352e1be67f1e5c242f8a8de5faae0b329ddacf3fc23bd3ef09f40fd3903424e9827d22540aa86dd69c419aa040564625c1413312be4b79036ea5e1c912abf41f66c1d150f474868cf36a8df8219532abe361bb924599837ed4419ddf19c1254de02dcadf2e741a7baff635a84b53318727006feec47e5d502302734bf0875c8d88863730b85c736cfacfa8c9b5db5685fe50299b7f4eecde7a534b3cdf1bacb0085236485e49b4706a02758e327f7ff2ae3c81bc184239c46a1c0e65595d76c33be504c4a215eb0eb6fdb00ae61c11821b5efb9aff7fd16c0964f49e3b1680e971fdbf602346625463ff396e47637b1effbdff5d9f5e0c8355fe50c7be0a579306b3c1fead00f2237754b946c5e9e1ac2eb18b32b77752e0321a772ac3bd2fdf4149cfc42db00ba8e71afa86ebff21a15929d55ac35b22d985eaf43ecd39c9865abc6ea319f8246d0eac7075f520c6bf1672a95edadb29839d434c04e482ef7a6d2ba609e091ce9e3f12f948517018150ae5888687f328ba50d46efd3872967ef5854702b048904c5f4517ea1b19590c9bdb4818db754d8f52ae076e015515b795d7104b762bd9b595a206cab2a3fb6d45282661790f8a5e39d9215d97018403c4b1dc60a97ffde67bc21b8c40252972dd51f22d3fc8b539ad26c91fa90761feeaab9960f0b63a06f72683be6f9268ca696064bf9fa6a9e9d352af852682a254884e893f384ff7ac813d7fb439aab565dc870bc48ab03022772f2fa416f8fcf0949bee6c790e32fbff9a219a9c5c0eb0d18e1f41dfda31d07df773eea6ce073353ca60d7e032e6b5f50e960b4f325196b01ec9d39b7b77b380a456c4241c60eb8c4256f1aef3a73f92f4d085a78fb72504c6ecb7075b60d3cb65e8903ca62187e9af166859a6cd384468a397ebed3ecd127959a4ca91a8d87bc8fb8efe54640c37f01e25940fe9f9ff884bc7096b5f36c0a73609ac31a96988cfad62e51a8e1521462491721c0837aee7be87ad1bb488397d8f0b5c40496df602bf375a9c59e783f5af3a37a524e937fb1a00c4c7be1d348ab9f251df126d2c1e345eb062cfbe6f163f089a08272bdd1b9172bd17eb2ed2b591b1c651a9af187a97f9cef994b1a5ec8c4266b23331ce57705bd87e7f5bc1a65fbe6290a12cd22054696be14a0621941328480fe13fdf24566b37b63904d5da51b596d9a2c266fd4654a496467676d4448c8fc05830a7c52865087a2e19b511c6688c8f687c27da85dba230b538e0a4cc7a9fde6288c075537ea1f1191d4c08c42c20d54a2ee1c58ff872433f8a920c7386ad216c2f84ae8d616f12e1b94fc5a3e3e53ac72048ea9d39e2360afe74344b5d6a0d39f026b5034bac0121760e2e104ab6a74be31b44c82398757772df9cf7014a8a76114cbe227b1a29a5008ca8301606eab42f151009f8e31f25f1329ed2d6f5f22472b35cc62eecbadff4a9e19c92b80f0afcc833fcb762d77ed3bac5ff8592a432565a739cff191e700cc460354199040fbf2015fb73a6a3b95030b2cc1b83542d145eca21242a6fe8d310210167a2fdf32ab644db6b15f1572fb347d01521d669a6133ec9e8865622c891bc520a88e651f2ac4054fe22b6caea988476f71bbc4c6dc9496a14d3f1287fa16413cc0f2ea9fc91102fd39f997879942da848446472f5b5bac2ff6d951c823829ff9e0c5b0e95314839d07b3d11cfbcccc32a6f0d11ba69a067d4adcce79165bdd97edad8213b8f062334215a2406fa098980512bf47ad8d84ac90d5e1430ec5c67510ec796811f98d1aa33789be28209484f8e1ce721f9866e0ff494f1b463dc85c6ad758a8c1a566ac8059e14f4e1a49736f1a9a8d2d15efc390c75b998b1060ed889a41f4882fb98b03fb84eb9ba8d1d586a411e5cfafa9002dcf2f827e8a1101b6755866a9a10525776984c0db6089eb9f896b639e71cdab44676500cbfb27dfe68f1a67781eeb1c2070faa55999b8066f657bb37981e5addb42a931b8563390d36ce11b8b2802844cbd39a7d51bf47ca53574980e41b88e8ab93749156e55097178a3d80d6c88c67f95ae0ffd149f8de98fd66a94a7e8a152446b8542f9d1f4cf2fc5538009c201d8ba9e1a2af6d4c2073436f6e2d3ba42f338b8d9f399dd7cdb0634d8e09f8c5b4b4e2868554a0a02e95c8e03cd534af2f4cae9aa6e8285d40731fb9af565a0b92b00ab1cb31041bf7361b33dd9ef9fb26c980a8fd1d1643a8b86a7c192e2561203c475cb1d4acb3b3f2d693b8d93a2dac82cc86f365d238a18a665a2dc4983f65e9bc811e98fa99b5653d5e884c0f7ae39cc177914235d798685e4269b6b5b8f6dbcfb68d43131c66a5fbb45603e0e3060130a95797a322c8e800794351e7b2ac91c3301d6a1d1a908311b343595bef0eba834a168df9f920f19d02aa3cfb39689e317f3c2ec7e8c9983a9e3c7ee28c5c7271c5a1473f68f567e75ba95819e8c769f17af585a5d34cbb59808a1078e9a677c65da07a5ec39833bd5324c90940308a5da70a5aa8290670395a03fddb9248765a24a73bd4ada9cc956829fc9c33cdda52aec83f12cae72e8c49b9e64fe172076a14c20037e4ced582072703d3065b652f8a7f4c6ce0a62ecf927073b997c1bdeaf28aaaab34722cabebd42110bbfe11a88d557a06a7cd2a782f9bb4831d12f2d36210b3b69ecb832f35b2af9ebeaf0f2446fd237c6851001f8dcab26987fc91f26b214fca0789cc9190718ae5ecf565259a36caf1625b6915d98749e2ef4ec84c2d56f1e563b02ec5adf5cfc0cfbd3ca4492a26d5870db61e5553bbb4ecd4b20629622b490a2bc5bb6e6e511f6710d830f285819021274e02d09d69956d222aa04eea6b620dcbb722f5ab82663355efb281539bd1ff47ac694fbc704717a6ab76f62132ac53e70c9819b04e397741f5a430b88b918f08b9827bc1409e32f5a4a9b7eae8230d322957e3ef0b8c9f1694a616154eb0f0624c49904e9ab5ba7dd4b8f992723d7ca429180a189ab0c857fae717201bfbcfe6b8545823000b739d2a28448eacf137b071fa81befe7838551358e6effa1545701015b32bf1404272ad60cb316c059aefadb3247bda24eb9ef598ead59afcaf37382a66249a03b237f442837935949786c7abc6a75d26469802b35d945adf38f0b54a0707063706873d5e09e4529805f700cba3a34df872fad6952e9468843de485284e53a52617e2b3ac99d80bf95678b54eb326e25068456401099ab2a071612a195354e8e4dfa897b9a478a177db9d25f688636983106abef4015f85441b0490ee4932f74069316ca42ba26c131ac0fa4f7db65232c8b5ba573c892123f3c025ec33d0f06ecbf7c269f882253dc81518334d03b6ec59f2416ea9fcdc8b256716d8c3548453a4521ca727a6e2837cbe484c5e874a2df7142659fa627986c229e322efcd74dc2bc9b7292d994556690e81801b32ede360bd1fc2fd3f73fb05d0001ef3efcc90a6eb20743d1fa80df1f92a2f07a4edf6268d7bfedf0378740a8c99947cad46ef07333fb0b5146bb76aef3c4acdb07b01f345890853a603a2fd506351a36047f928ce26f5568c5dcc729d2595c8bb339230ecf683b497a9cbd0c8c4cdb276737fd5f8a50b30022e7f52db0e91fd8537914826cdfc4fcb3257adc6c642b68662376f464a58f6f1b9d9bcd4f79e89a42cb574ebab601aa8d71f514c6cde5c055963c7a53a82d2deb85fc3729fcd3f27072da7de12dcf58e618d8499a50dd4f87accfc1485265db76fbcbd40c4c6f7490d0054bb9a79274495466a9fe0333726b5c14292054327dc947185caea23b5bc2aab75dad95caada681b15b3edc5a02da318a1a472c04811c6e2140cecf34666ad6917ba647c9ee150aef7b62744e233153374191c11096c2d4a66aa631792549463034bacfb44e7827fc3332c5f7d8bc84453b738a66de26728d26582da051bd492725ea82bdeafa8d0bd680b1775a07df6998e6164b5098c8828e4d6fcf7bd8f0824d92b097fca0622eca7d948448d53abae65ab14adc04779489e960cff8196832d020c0cdd705022ba245adc164bc924f129cbce38aad840d5a532454fee6e29549051b55516b004f15e59e8fadd3b678d49dfb14c788f1b5e6612a9cad7582be6c80b3914ba38de0c1ca4975f3d95f5f27f9e17a73a7bd7fc1526cc05e4eafe3f96810019b3b9d4b22d3081d18ca3071893417ccdab865b6623708784cf9c4eec3edc9c405b1e25a6903225c229543c057db4036531f7ceb6c844ce825ff17d916d1ae7c86dc6ca1cc7dbc62c21f491743ea4ab38a14794a263a7eb502f863d05a1a6b353409d9bd531787cff14cdbb28696c0e4b8659b2e5f368b3d4d8d71174e182ffc5bcc834ab1ec224470ad880684010ada16e0a0a5ca454e0fdf77e3f1a0e0b824c4a750630e8a578a1f0a0e12b5873be3579796cc42f5cd2fd23f675bdf43c48be62452b119d6e77792d382768e636b17fa603b8c54d57da7adac6bc392ecda5ef4c7ea9be0cf8c3dd4a71246e2650ab1d2f671942c48c1d7081d5b3ba181ed4532bfaccf87fbc1bdf7d6feac78fddd9aed1bdfcb8ad13b4f83e217ccedf0b4a6b8bcf2738994a9be1c27c27111e5c80be6902fb27baa98370d51badcc249460fa7b04cbbb2f285e34cf1ca0e5e179e0df8de615de9d445138a3f40a3ece1c1c72fafb8268ed24225fb022a90349864047a92a9421f92dc4947bcf4d490b8da4a84a98caabf6855598c3893df4de55a86a4f99026389d37d085636ec4b8579279607270eb704302a86dd29c735560ee2a00441db8edaeff4904563aa138e3c0aa29dbb123e89d3d1987e8b37c202687e2b8f2846d28d43009c085efe1e42c7bf1008cda7ec439a14e3c972c6ca6129aebcc98c2f1d030e5a3c94ea2c95e2168825f3108844bfeb1f2876fecf274db530833e4a8d4e4790d2bd43c6196c0a558f48cf7f67f58bf6f5a7013fb9e6c7d64575f7d6d0c5dbb9b03632a880a304e52f0663acb1cf541dd8bd2e720ba8521b9ae8ba21134d6255b645673f9c5a2376d4d2ca5b7536bf9ce745922e1de970d154d8bb8fa60f4ffbd19c7cd264e9c79018cd2722b75d10c11eed6c9be7ba4272f90533eaf302410b3167337c67eab403dc2ee62eb287edc366e5490852f03a00fbfdbcff753f86a89d60df9aa7efe5afedb1b208f122b8399212ac24d7139875c98b99a749913401b87865f66917ec7d8b0c040704de356a0a22b8959fa8223be158964238fd2caa0fe2c1852293e49b81f1e8d1ec86a5d8984497f76cc7d9deccd4790e1feefd801f1521cffcd34cfe2bce2ab6c6c2ff6a74ea9fc29cc1b9fc9a12ad3dc2a705c8a17755847552b653a2b54a4382de8795b6d26582aba3db7392aa4ca7bf09adf045f5fb07130a96bfbec5ced37e5aab1b22144527c631bba54c6fdb8d7d6be1def11de80d975535d3ccdad82fe58478d2956ae941d169efcbd8a50b12d958aeeb0aaec79c18bd73134b05af733713d50ecfa4a677b69126652b73c21a40ca8e3d275be8d0993944f9bf1bf6f8aed498a26f872409a7d7f8f044e5ff841ee6f049202366dfb9d03f2f5bab48cf7219a529b962399d9b816071b919b75348ef49a73bc07607d8d39c06a51707af51ba41051a14f376c9e3c18a23294db3bd9fa17f688fa9fb5c382d1d99874d5742d6dd031b3dd3992e49f8165ba843d13c4cf4924dc69e3eccc8b24579c6207a0f597da612d628066d65b39f9d6a312f23750247959e5b554072428a76a5cb249dcb8bf2d722e47c428ee96e26cc3bfe7b5626535000131fb22c489f2c50544d5766dc40ae0153f92c270bd968fb0912f609967bd4241ef27f03a5e2bfe7517fbbf35f8c6858ee4b4350b3f549df9ace619daf3b5c2ceacb35cd4cdc96172bd0204f7349b229dca94d4e25ef73ccbf2054433718c5c2cbec17c96fe0c2f50af5eae83ca962ffafcf25e458a9e530eb98e4e7906142dd7951fa2411f51be79ced76cef7fef07bed34adb83a0845988dec0a1064a7304488485c9f2da46fc2256de0dc7fe233e332c784a71c205f832edb907374df2683dc7897727c41de35c81b3de331105a07e1f4ab2aa2c7e77d513572fdaa2774cab0ad2354fc3826b7fc0997b99a441b4cedbd40ba68a9ee9dd8c231397257a55101873690cda6f3c47d9facfb78f8a773f5508d033e541b441a8e259a0dc9ca85a8c3d9f0ab43e0c1e7af48d82f5602cfe78bf406839a30bd13054db433d5771ccb4160e87cc6ab5007de2907ca121bb8f0cab3c4fe5e5bea9d6b0c43a15d9b80a504b7bf2e7add5c3a0d57bd41b7cfd44e4741b14e9345bb036d861480bda88249940190f9de6611a8d561c8af95906dab35643cd1dc7fa89eed616f923ad42a628998c2c92faa756f48f79456ce826fda8e60868b067d4f73d8fc4007d55144f4878081488a438f0f18aa9a3337580b36ec9795587cd4ce62afc40584195776090d3345f3fa07f616f7a85a9f4023a283ebc71afae9eb0bb2d54b15a814c3cbac5885809120a2ffbcd820a16a9045cc04e6cfc1c5cc5f6761252a6f542d11dbd6268a0e6a46e05d82b387fec765800a20864432673998af3451aa48161bc40a73b0ff322f36f2fadace7436486fcdc8a017ce6e91f20398eea79be4a5c4a7b7b78ce2891a7c4a758fac8b70af5a0f38bd575fd39eaa04a9674f995f721652bfb675e05c93963690fff630e853be84220023d1a8b4e77e83974f3b38e00aa808b251ee8517b1bd52bbd34982b4dd2fcd3c0d53a7302b216918887717bc6affebfe4f38e7ea21b6bce8a97b5e92616a38d3ab1f541f5e7fda8fbb600b2c71da9541ae0dc63eb4369d266ea57cae00266ee1bddb5c02bec0be0bd1bf8dc47f80d1cb0df75cd07461fa0315c95965a043c30a7a9820bb6724f4534e9bf5483ff4cdc24d2e093fb9c385ee82c5048920877575751f3183a77d7b575a6f1299d91b6c3384609da458240e84c37c113061457197897c073697e38b8d5ee28bb328b6aeab44fb845c9630ddbd22b5e9e1bda85474abd7176fa70bb26e8f89257e5555a97625537cfb7f3b7e2398a703a71e7cd12f1a927a2b6e65bb3b478e8546f3dc3498e5c18d056907fa60ac3e47a965c3af0458f68475943f2b4a71e2cf14c662b94012e5f0525c82c32f70be6d4c6124009e2f48f5be06d86864c17a4e3199a7830277145c22cc01108057c9d428ef3b259d50919de834853eb59a294752f66dbc2ed87182546176ad700a697e22f515a151b37d8bb4a2730248eb27db48a31939c958e78c05a29b150045693c3492346bfd685c186563cb05a90d5c0b872980f2ed58c4abdaef37443b28c316246ff565109a2f46ed85c873d4f12b44424ad2afc8433a13f38c70f83310dc7d0dc339d094a9698926abe18e8fccd8ef8b5f98add8678bb9fdd773afcaeb132a139c0470b8a696c4b05c75ff2fa8c5af306a1067f95a2ee6b82105f6be67107503fbeb1ea08ccc70de5dbe45ea9f377373c4666875938c176ad46ec3b5b56719dac85f7e69319e04451d3b11e938f445c8431005d793ae876cc427b7702ab2111fd294cb1c2d2671c77f94b1c84cdef2b850b74f433b5d378dd4ada8500425e4ae4c8edb32b6477e3c6a53a868cb2409c5f2a1e1d082814b71e885b8276f1c907938693bcca0b4e334066b9b4092823b99ace93bf3ffaa5e2f5a606b9b550974cebb7afb5200e9a1e7f49e6f6208421d52b6688b9faef9ee792f9fe23ad0ca23e20d5c8f02033af1d0f3efda0bb091d3df1adfa633ebe22419b872b42ffe5c03461df179476951a3a422ddc106e9467fef32e40edf4010d2c00f0f58f032c9dff4fa76dc9f2587ff95e6411682040c494fab19b2aa45cb30274a7a0e4d9cc3028fb09ef21d3f7136b855644f635c74a61a053c9cd0a9707e617051d62897dc21e872325acc227486b0f82fada4c1f9c9dd0cfc1a3ca82f40e4f78869145cf4e5d7bfe4286fd301f1b9e50570309681c3f00c490348607a26759b602267296ca9ea1621166db03f67ef8980d836fa704fdeaeaf1ad6b2f6d7594ef4de1614acc8097f7685fb2ed7cdebb95bb976c893b6ce9e3f8940a3a82a0a6f009164c9d1b0765a339898bd0a5a2aade59246851936c09c594bed4d2d4844d599fc98ae5d4f7a35d1ab95814957180800a5329780c5e535d11c05333dcebc47add8a186fb111c0fd248f25db00e7d741ad54fc5645bb40753a3fec2e18a21d6231df4562f4e6ed585437c4ea0a9751e25d6495b0ac2c2313339691f8fb7123103f527e27efd49ed9791ab13caa6987a2cddffa59461b7f107104ab92c321c5b6b3baeb5679949bfe10f2f5e0c7c7ed936b8708cd4ab8e84b2289969793c71b4d5571ac59488d2c155e34edfe7374ffcec6c761505e858f8071b7f5c17ec1aab599a116d18177308ff1a3c347ac7fe144e80688f4c604917f1adba70cf580ff6492b459f2877be1db43123cd14f5c55635e971070aac857da6ce520a61973dc25fd0df9c6e14d5b221622537c7efbc0de6a425d50f8bf58c07b569cec6911d2f7ade03178e2b3b3119ef2f594090cb6b61da4c04587a06952e2fb0f85b202deab0398689c00c81fb2d70afa94da2ee173acb8fb5a71d1ffa30abc4be02105a5a414806e67fccdd0174f4f77089f75e7bd8e3de93c25f706a6608c037e815ceb46fed3e2674a523aa112f1ca2339a7d15b6b0b131dd85c578a028a7b39d9b58c17cfbd14730c29a194fc60cb3570d1893e773d65fd382608ba4f9970ab06192389d88c93e66629b2846a214a2f17c81fee05d546842fc690074176b95ffd669d5f655f220e3c850434126e62b91aa54329828392a1088f3d44b0acec8a1aa76d531c83edd2db3e25fcdd5bd96af1e7e9a4d13e7178e495bffdd5ba0e876afb2954de919b088c10c05a305694a78211b40e3d7740e4c81caab3b93913439d0a614d2e272ff333b2635f3e3a427eeda7731671c69e25f177915078e43c90072f1caaa6437acd49a7259cfa8da75b3d6fa36268ff325dc9f5b5b0ce20818694f72ff681de293fc9c1f6c81aa3a0ff12e8a29df6bd2217785befef1140ca4907fd8a2ee69870cefa96ba40010db3445ab2cdbbe2b91f0fa38ee863a58bd3d33fadab8b5c3b59107787e9bded950af7570f818d56f0cdbea47b5cdfc8151143a1159f6e22f398fe8676f967fed1899d8154381227e84120a6316177ecd8310925063af7259e7e658b51c2d9e65fd2a205173aa5c5a52ad663987d2fe062f6d61e679ed7734426918e4ab6685c0dfa4aacc58792fb12023746708a84b1b633e5906ba4dd41575e2355120ca821a505893c5c87f4b06908e70e15949fc8685a0dbdf93c05e03bffae7702dcbe1f81b2df3c1d1b0868cc9d075d2704d94083f81bda4fc7668150d6da7dc41389ae12a3f51dc92df79761cec97a3526c4063beb27a6f1864c9185ad788875bde98ffa273f0ed220d980d63297eb52ba80475189194fe951e3523cfd7181d1ad828312484fc3057e6d191bb6f1543511c35beca0d99a1f06656f70f0291a7e7f9effd9016e14af6bbefe2b134a786a575ac412a02334b9a39f7e6757dd813f6155ff498d28d93ef6477f24589710e67573408662fe2d202442959c0d42c5053230e1e9e200c64a04f9fd7f1c7b6b5d83e73e8f43f75c12704462b548b2f684cc418892188b08958aba325dfbc8db66daf25ce12c55cb5b79edb48bad496937d32e6d0473266a7b2479c6525c5152274eff8722ada7c033c3b24b28a47eb457b0e77bf619a0b5622ca6b8a9df11902cbc3259c8e06ddda0e4b7e8d296ffefbee553ef082c08ed1ce1bad040a0c4e3d25afd6ef216f649e50baee63ec49a1445c4dcdfabd6d9b15fdb1c0d443597bae8c831ee8929ba75625c33b53b0d99be8fe7ed7a44e5ddda67e7125d733a158d8c3e3a702ff2dfe9184079dd9ad52ba9f771ef5f35f9faac08abbe054b659ebde087c89b16ad8658d522ada59dc5eb034aa042afda22a49e23bc3aa2a835ce0029d0a68e60e0ea50c60f29d2f9fe7fb44beeef1867b14a13f4d9185158656fc5e529dce3b6a22c202483ef0aafb11d6640f9b20cea91ade1208f0b1d1aa6c4764f97b45920aca1d2acc1b317b124512229f465fe44f13733ab4fe497503f910072a722aa9de0f0b8787b041838a8fe05677d21eed76c65e32e8ccdcfb03176f7af4a3e7ce93ae8a5ab75516eef4bc2abbab5e9a4dbf66f3397bf7d9b330b6f041da84d5d414a748bcc1d95e1ecadf924e2c48512a88e86031b2293c8aaf263bd9c199aa21960421c536c0093bd682952daf2a6d0b3453d26b53ecb2e116bf6e16167f0a0d1a3e410262750eab1b4d462e21697ead785172b0d2a714c1b0ec3bc8106cc56bad1344a134f7a852570cb1ae129aa0d2f9bc00f56c4043d716bbfacc4cd5d86282325e05e79de818d95ea015b58f0903ab9bdf133550fc0b297812048c9a7e153e25b223acceae02440e5ab95153afa156942821d1fb22fc3a87184d1ce91e7f51637d4b0706345447f8af1f8e841a8cfd6d902085a595ebfa7078774e510bfa31d617c5a69e6d8b40900bf2b0c3f675fa38498999db045a45307e407b11594bcd9475dc61dd45e74e0632e5ab4d74f1ace21a7fcd45aabeeb2efab3c5f34e6b101122f8da877fe37dec67ab5a78c34f27d03473983cdebbeb5907e61e45c7d1782b6efb1777e7f584fd129a7cea7e567359e921b9e0406d54fbb060ccc3a05caa9449995ac070b18165900162a13f859f6d2c2e8871881dd505ed47822455fd0969d50ebc3fe0e36d3d337dbba35923c7eb0703640807ee45cc0998021bd745e902258a5fe47c576f9df3c597a8a6f4c1d98396c0cafc0ff9c855026d90bd475988da51e81a18015030f28e20e878176845108915385f404c97deb8f154906c708e83b7ba75727dafdd59fa2bfa04b710c5d33db8f001d2f663c22089ee88f23cc11d625605092720f26a97cfa2455fbb9855a7448142a4815d08255c4f954d3f87804d1a2c0b63e9a91ec55d1b1f11747eebf0dc2e058b4b6220c7e6bd3cd2dcc307389301ded754f0dc36b24b5030b7c36afda35067446b09449e642d86e087ee79dc16a2d39b59f7b353a9be71ce039fa2d2c7aa041179c1b5315cf4a30deaa43f369c1546cf36b3e6ebe7a1cebcad6abd52e307920cf1ed5bb7095d3e3f925426f5a2779f496c92312e1fd2c1e0db042d1d7168d76d9e58fa1132f922ff0e87acef236a71dfb158e892bdae9c6533932759007e06d83e13138e2cb5e92d831583521e4f757b6395100d8728a654064bbab7d9d0f8416e4cf9dc08c5e851870a7ece44c1caf142afae6e5d94dd04ac6966ae1a8795cb62024f1ba1933a803a1be9708713b0200b3e40030b687964ce89b20a521a26379688a2952c2c391bf20630fc5a038b5190b0fe80da2267675dbcf083c11e37cf9e30024013e1808cd5fb0b24a3d8aa51ff7975a7bbd126b5e755448f8196b1b444f70be99c4129b10f358b14105b1de8aee7afae964c658c4a0bc0486374079cfc72d6640b82c54fdcb70e0413da4285d00413f6b91e49f31ebbcadf511d3b085010e86377a9939d3e1ef0a9ad9eec6c96f1bb5fbb7553b82e52a5a9036a0aff17ec956e5105fe5812d74ba6a66e7fec4e891c6cd7cccb0806b648e0350ef078cfb39492974f06bc6dc5062bb0c3ebf08740bbb8a643695b6428e57009d033f794156e71635bb0a9fc13898ec712d20b87728bfc0740965b8d44e95e6976ab1501e652702f1c555a6a88b869004bb77f8966c56a5cc78cdecc8167469d19a57660969a2c6c724c74893571ce2f70af151d20f47d7707916846219ef8b8b69c4d0942be0dbbf53bdd31a4725927b999681cef9c9eadf25173e1c1980b3693904ce38f25687f3bbc56f5b078297fcb8f03ba378e2ca78d8eb859738dcccf22f37dfe43c0ad373c814bf01d133b575dc540304c78fb573bb949b53a6702de1111e2a47701676489b9ccfeb7c1d460d339dc6831a957941b2e74d691d0cd0db19483fb5af9200675de6140201edc9e3e5437535076d40ccf69ffea9ec10dae415af9c356ee3bfccd92c9814e36e7bc79cb86c5940f1f0445f58e8180b4cee046f8baae5a127216962e1d65f7622920001ccbd9c78b984ec1196cae3b71ee53fc70f72101e95806b635fb21dcaa83dbff0f447d153066c4500a9a4e39e05f3875cf80974c8eb104af91c343e883209d69fed35d031d83e92a9735d559a26d9af8e00dd95ebb9963ef8b3ba0de7c9bdb55380e0d929f37d89f2a4fb6057882d3e6ca1f931eef196522a825ad576c701d2181e381358f7fb45f05d85b6456705e9f769449c2d175df1ed95dd706729552d1728c0077420262d6ebba350d64584a793e4670edf882bf7c77d07ab37b122bf8a83866304943e1730c8036fd1281ab9cb93062384fb2e52d7bb33d7fad4dbc198c2d65f60dbeca4f09ef345d232903e0a1cda426d32c494163db059565fa0de1e00acf19bc7824d27511417eea23ae5bfa87549878f01b761f1d788b8d1b8e56ac8cd9d9db3e72d008c49670a9ba6c5c1c61ea0d0a6f0947376231aa3b69ad5d3d9978f1ce28d3f3f3a56a8471300abcacfb9234e4abe52f2107f2830cf5c8b88e38b854111086d8b80c196385dfbaccebfe1905d1bf1e1086088d022cee01e0c2814f48ee736839dbe7f993d20adfe6864ea272ad399036e23f88ec326e9fdfc5cf2d2e21b4ba2ce65db9051bf1e5d8457418776edc111ea6dc4dcc62800e8ffcfe67dd269921eace786869090d9bc0ae98fa301e3324470020e8a6442247557dd4b0573b42a54ba865860a8f9f84b96c9d626482bd0ddfd5982a53a06515603ef7fdf7dab45f82fa5e2e67f6e0477601bd51e785696b2cbe66752f2e6acee3b5562522ceedf08cc0fd3aae416c9f6ab618ef53bfa2c4de7ac7c1311811df9a154780a09bd2102375687f5a67d3dea210618271e092ea88be4ba46762153b63fa4e7121d19c0728792ce9e9d9e85dcac75acb8139826ce3ebf18d543a3749215f6548bea8fb6ad91c6a4abb80c441f45c07f0cbf1b6dc3b97e040260460600f111b00d7ae10db1299ebbacfa94e6e6073f0b17da2d2555d2a4a14cb39eb767263938cffb3704d7fccf8fe423425835838420bd844d5440dc5e7e1a4acbeb612555b8b2a9c02ea40913f0c8da41a1b0a53de28cf095e0ba2ed92893f42bef63eb1df7f80e2540df304e0e67bb7c99bfb97bf00339c90c33f06ab94b85fd8312fd11ef69e03da7d5e6f4a72d3871a76e5a20cda29dbf68e765fab65b0b287b6ecf184b76ef74e6643303ae8f5d4531005ea7270113cf4a5d4841acd86d0430ed2d75f2cb74dee901d6d4184ef2bf2953d74761d1b061947bc96d39851243e8b0bf370841f9ad5af5ccb0005c2b84fae4684cda6333b329861085b2156f811819174d075e474c9747c99cecd82257b1f4a3acc0cc4c9a7147749ef2d65c641e8110923ddb24a55aeed7cfa4bc319bb236ab129d2a22220aa69b35716b0cd3e1014909fe50cda55d9b9e27744d3664de11f2686c01527d2534169f619529e1d7251c533415363e68e1b93c1854d19626f88f60975d1d4b8f5b15a4c3f110b1c61b0ea378988879d27abff54b224e044ec4e4fa32bb4f6ff5c25fe309feadf1a14b15d0e96522734aaff9872c0a9beef16ca9b0497eb2e68a992e23273762f09c99a7a0fbddfc621c6a9f43f255aa6ec8db3e54bdc11071f4a48e6cc1061f5a21281d3f886ef6591947ca35c04efa4ee6fd9f87367f39609344618598412e006c7797fa12f334923a554ad39b96c33c862f0708a5294090e6d3cf6d0fdd2e65a758c46117a987b6b723888b33b1e6097c2f4da199f74532cd6652b40450fabc35186b83481523c3ae01eb0713b4cb1d572cade44a954e425df7a2a0b2be2cba2952f6483a937c4c952609da74740467d05f30b0fa748664f4edcdffbe401e188fa40670a13b0e9a8bbbabea2dae2452eb734c9dc10a65a8af4138fcf994283d5b2798e7f1ca30497e20762f54aaa18473af98f4db59e530f789629d6b1fd7579c56595e6a97d1ef19811ce5f51928f20fad82c73e85da1695d2502a6c02a17f77832560f6f2469ca47f825416d9081887ebe11ad4a11229f72df801de38673b9627b0d25756404d0aa9d409cb298a925a41e4e36ccdb4944636d77dbda82cd300779dd4ceacae04f1cbb2855699ab31bd9126eeebd445b5cdd8796f78cd9145e1cae6feee419c01f6e6ab824406adef92fa3dd15c185761428fdb2cfac00f4c68f0c43254cd477e953d07b8ae2dd352679a47cf9f07ad22f70995ff691bed7d5e2afa9d6e01fadadd40dcfccae6c5ba7e412bf275b24c79a54871f939921be42cc11e18b24b7960dbc12acac698c7f36b5d58956de9c8f7c9d65c86ecd72913eaa90863812574e998b9b3a9315dea4182b930e6cbcaaac32b61c71c0affaf57091c478c1259f8c20b07765b22bd7b198ed2c3583cbb01ddca48ca7ad6810ca752fb8ca8824e676d0fb7e47643cb072d4b2016fc06c52a95ac6a833c9b15d16b57915759b6f3c63ba96db349b539d1edf517625f790ad5368ff106d3948195a0fd3a82e34761935b58d83a9acf2b73d91f4fa53bd0cb1ac1d2988998b7ebaec6de82d384753c163b504589b5d16d94075870b2d3181cc78053cd15856cb15105d2b43b87641f2321806088c0cf9f40348460dcbfb9180cfb5ed10b6fff7c18b9a6b775bbdadfff742893beeaea7369a084af57009d0f07d9145fa248882b872c6b5b1bc3eb5822c6ccf77b232d16127ebc46da422fab2ddc9c8d4242402780cd34b075548ce9a23cbc91f81b4c265f62af6fe0332552f3c9ec590aa3dda184064e2b2138e83f1609ef0edbbdcf85f242ed3a0e1a8df57ac04fd712a778066ad01276328b1696a76fd9971bfa5f049f0c51f0d50f5073a2f9f625d48311386684407aa30a2c4fbbe3cd6155500adc6c2450a10ebecff90562b572359e1ff5faa58e6d8b20c8b1d18b6f22ad019f69b900715ad0125ee3a859ec97928eb82bf27c6e3680ae0d916a1ef97f792d1a76a3e9bfb18c98b7d147d3943567cf5b12844ca94b46755c50692a62004c02569bdd1fff7ab4220bf298d05c626b6508fc7d967ff932f5bcc24b74981e9674625b15e7dc906955fa133ce94defc7a8165c00a501193cddc88b4fa8895cdde2721c03d8a52999a309032641343844bc36107841dcc75b72ee70d7c6a0c1a42a11122b9f22a667de4ecd9e039e33267aacec619120f483a14d4cfc741008baa90a13dbbf278d2364ea91c7322abe7234d4af5dedd9a9995be6026f811e5ca0ea5d97b4b7d579b7c416ebcbb7ab20ae736047702f48e1c7239700c780b0c2e55149d5014f93c5b445ca0d2beef77b15a47ae8095799f492927b3579e2058252f967261219e657230762967cbbbfe48fe4f2f576e2153b35ae89cc1d045d02ad7544ef685c15b7f10253d626ec160eb99108786c09d09dffa2546ee3c53d4ae8b4149cefcaf5574a429d0e2ff975d8a40ab46b61e868b01874406a186a7fb03253373d1ee02a281ef89fb3d816c74d49f4b499c16b5cd12e78ec5754a535fb589777cc1a84d40bf79c4d0edf227f14478a13076c7e6097de4c5ee0a5e6b10c1cebec0cf88bb9dc1324b6e40de6d12c793acdd7c0d183718327e66fe887594f41c39b13a2c7fec424d44d01a2b1c1818073e1d0cbd20406f86caa312739ea51e2efc2204b9c17e95c39b74e8fc4acf0145f401bbcca679e5d3918817279016fd34d83ee7cfe876ddcd4f316e016255b1f1e6897e16014241320768c3ecf0dbacfe75d16c3ae29b4129ca1a4195436f0214467688df781079e0ce061d98912fba4a5110fb019a163a22b6b5689ce8c2b2a4034684e4f29136ff3fa347f83de266dd4c302bd47f3c922975088ac39a42c555903af9e55c815e103bf3fef158852342cf9976097fa723bf0292c2fbc9f48276daa39d8d62767c30a8a0330e9bfa4016da8745d5c537521728846e7e9761041aaec511924869e144cb8e4e0a6182d5ce5a18c334f2ecb4adedfb40bd7194f68eb987d5a667e1c363ae14bccb4695993d32b6f11c8b5de1af7c685f962cd1862050adca1f3173ebd4d59de508ecef88937263a1f2b925eb06fef05d79d862f4cda26bd16a5cf0437a9cbd5da341805f54fadc03dbcf6f7888d9183f1dc405366205cc8ef1d01779d5d6f5bcf7ac5d6c2178d353d9bb2d326bcefba0cf77b6a0aaa2417919a771ca3cf2eae3ccdd59816cdc44667afb6c29a1374de7ad654f5c2ff7cc980b1bda8abb33326b4326f5658fa5afe35cd6ef5bfb1d0cca29bc0fa9cea839947509052602fb021f77917fc44c1a4c784b7e393a8200848ab45705cd9946577e055c2ac4f079fc5445b8df6a006e98a23ff1193373614d634986e825eb73dd3f6573716b8f0b01be2916ac1794b57435ce6e880d6b287265b6a85179b4af630698fdbeb94026c8cefc99f908c4fe8fa42ab3786bcf918a96d6a82e2e3fc61e481af7ad12b725b494a01595cbb08103030beb02ce5f09d956ec77ba30092aac159ea463383ca81c7ac39c6fbb27f9f8a49a831a3655f48942c8f46e50122d8f159339ab1514e69b03e3efd2c8a155d456e40e2e8f181bea45791eea71022d23ecebe3e85b477a94f53df83a958c9989fa14595b2182234f410cb909cc266cfd70487a69990ec36375cd0ae3bdbf9124cad50bdaac0f222cc5b33027790f089303aa5e60a89766b64c193425647d8181a8869bea13ae1bff6ee4e0bb386fa470e7282bb46a366f98226dcf76806e081054274313186d355d2ae68203df98e2726063d323fd22e1caeb750294b2e625151cfd291710ac193aa5ac115b13d8cfca8da1dbe910f6406f8796f04a4bd42860650b6ecdd05066018491b847381cb4e723b83a7cbfb7ad31c6f2438b8be997ec8feedcf1b68be88e784a142f22ab2f3fb289506c481b74c4443ca5e637c18a67616afa59b7f579b8921103a3472407b6e96fecdabed264fc0c18165f848362ac5a95695cf71242fe39064e81d2a773a76c15a032b314f24316f7127aa27dd2cddd85aebc50be85d801e3addbcdbcd3a98e167669ac23631d931687e151f9c08bbcb860ff6f77d53fd0602a823341a3ab100ec21b5f9967dfc88a36081c935b61468624d402bc2185f64236501f6c3292b540221ba2e23bdd1de231b3d985f8110458cafdb1729a1df0a52500d09188b19054c725297c9b594d8a64fcd07d52556d1a7c78d9e68b0b9bf4e63cc7541142b434d377a72798a7f13b13b0de63364a3b23f49e2a1f9a593f592ee97186b8be1f4f19fce8f3cbee1bf9726b9c23327a95635b4a6dac305f6e28e382fe9f91e8a42e9da89863276457974ae2320ec582e9c73f90256184400684180c4904a7c7db91798c8a4662914e1122905bc247d9548909d29976021aa060c30d94c014797f85cc8430ea6f504c6241d83d2a404b1331dfb503b5b6d028ff9a2c98653cd06469a0c652eaf33341b3b6ca69152418a7fe785d3e3d549b42f41edd4a543d7241044776cd652c819c6f1153c8ee2c62113e0009781564a17871e0d1e08ab29c2a33da30ee7565de4f28a1cd1814187fe5637035d55886dbf12c26e37c8842317ee3c84bac4bd5b3a99e9480f93fd6c030d6e09b1445485404aa670a94ca4093353d7033af1176a97d8e3bf547e5ea69c815ad08302faeccda55f053075a831456af70ae0397e9ff277db7b696704438b3f095d3f9ceae13f5e53799815fef162b577248508398f974aabbca1ddbe69fad1361c32e7ef8dff10f05e8062ddae36e99ef1430fd0840f6729bb633b5c3e7b919a9f5366b1f848caaf271051e85bf7f5a78855e2c713daa53c4b33bbe6726ad3d3999816f95994f335596606bf116d588326e394f5132af14e7d451c92f256de2f725f3be14487213947ee85cf5b6af3fbb149737c31497412cef2cff7c10d3fbd5ad8efa397699676a24a0bcf6c0b2a577609926efa00233d3626f2910a84d16a22d941d04d2aa3e71fa38dd8be9f795e0674c95fa9ae15a7ce64577e8a5048e3284b3cc2755427f6cd7a0da54aaac5a95328c9e7416737227374bc904c5709117bec35e024a3841f50fa9840b44f1b5f2929fc518cdb0e0cae19ac74913e8f6f7334685f5d9eebc85c760475f22c3d1a25be362941433436257f623bd3f6ebf95189186c60c4b325df6d5cd99ba19d2f007a1ecb9d2a715f8532daac344c394ec2bb6eb50fad90d842927e85bee6a72dd75577f30a2b9d79d9ecf357cb39c5ce4f50caa417dbd6fadbda9e0cf8083ee0c586b244cc8a4b6711901568bd80a77bfd6b577272094c8e1e6a3e41c4ff96437719f0df9a37d00100bf73beee604a93135131cbec2d33c23dc37c6fea046643f3f23db847e5a35fb347e2d7ccb96d80980c2c4189218fadf85d0159f31f986ae3bbaf75785cda7a6e04fff06280bd68f34f29785f0087e924fa258c41d3b640709cb8ad5b4286ee0b1e515645dd8315df7428479a963fb336da4b7155b1675fa0d75479ea3054d26bcb78f7a456b939056be1e1a488a2453343f99bab6b8d3f2690c07e44f66fdf48450c5db8c49f93ef5ccd63330a71607e1b9cf97e36c20117d7c3153ef4830afc2d14779f8cd1ba96abfa5a67d0d8fe188319791b5392f4265a06562b7e4324ebcb3f67c5cca128e74bb40e577ee1d11ad8fbf047092ed11b3d3da7e1f8ab64f6f4e89986278740e4a4e73d9a4c31ddb7d12e99c3ce5f1d36782e80967ae613435495405b6dbaab705295cf32746da3e2c6b01403a0d7702e19ee07bccbe70943cd22329bf4407e59b4b7e42f7c83870b93d6bb48ac13af6aff9c717559f89f8c7a5ef66d8a0d5e685e4fa6714c18b9643b38751e62dc873d2e00882cc5e494d51aa79795cb0faf1e6a79f3b622f7fb1ab24bb88525e59b46146e0d085a92a1503ae05e761bbc3ecb2a2ade948680f562e59e8285c440c79287eb90eb16c6ab633de3245ca1316bdd749018b266c22f623e6d6544492c9617b3cc33055212c81297e7c7089b60af95e8d7f31f8412a78e1580246d7baf733b7f491f897d7c8bbb930a867cf3d9738ad5f4d1f10bf7f674ff76ddf492824d87759eb8cfd130f25c5b38ea94d6351160105aa1bc1e3958c19c032ddbd4e476fb241c10f8d7912a900e41190cac50f955f15d04cc03ec09ef8327ec29e28f7747e60a41b9e02271ac274cb473eb3a6f2ee0062ca1815f85d69b783acb9d0c659de1c031580ed20b79d787ceed3644a8ed1a0b8aa1dc38b326b9212d5525dc428e75c48b49ef735ad749d9b95b3592d47bb120fc1b53572cba9c12e9af5d9bee4adeee1f9daea31b53e0c9990398d10f8d45e59d4a9b1193a7a0eee10081ef289b376ce8178d0875f4419dd24f183021c1723222f3abb46485499b1c7df4c92188eb4c9580ff8e722d48f0e81ba09dc361fd49e584bf79bcc89d675780abaa73a4aeffa843fe9dc47f9bdcbd9c2a03099bf04164eab4e4ec6c4dc3ecb8a01cd34b71f02ff7bc6ba5837850d4bb8aa68e3c1a3d83f23c3d482ddb0933701ed10552fe0db1bd31c8badc34fc0916be7188cb3d6377dd3806ba2f9a066d76941b626d1c4220bf62a1adc0bb6ac2217f6b8c34357e99ba655acff4cbba0d8cf65bce4b178d544aece86090576d22a31fcb2e312384d2b686b38575929777969a688d8300eaca933db271673d72fec4a34e05897797abcf1779ad413c33d43ff6a8cadf09373c973dfabff3f05224cdc885abc7057d242c4816b16e139aa0b9f7c646be44156bef7bccc5fa1be9dbff6830e10e336782437fe7c3573496f81c56447bf0802757a0d5364a021dd29b9306ca8e23cc2904f6857bb104e1b3566c7bd743e9b24911e4ccc325a45009347865a2abf8bd66ce9f7d30d7fb9fc37f0687a3c8a0ae5df6577d59fdffd7b53c857ee9a3c3e7e618e266545759dad4c367f373d6febc2c775a6e3e64fb24b56fb610e87d6326064e7a597ded37965898cd139f781951cabb83993487404449a0582e9d5a3b256a72a84bd807b62cbd81ec3b57c007512060eefc3bb737345573b76728a7e1cfe870aaf5e5db9d64afdf183e52684c808ff960ecc7f6fe4a54b69ae69760a7e009e00517e1a17f0d47501ba891183386a1a3751876f059ed154bfa7d9865be134271755a828a8f0261679026a1931771c4275ecfd1da581afdee04ee02ee61846274004544fc406f9eb0de7b7f052f84aae81d4797d62698bf49212b59d1cf2b63f6c71692acf6e5cd555c1a6e7b6c8fe7f06f19f0ac8d7427b0482cd5c724f69c5c645e13e5e5869bd458b304ad4ada814e1cfd4447b8339fc4c280092d21b6c9a3d69250b01de1d9e32abba2a090739da9f6a64c8683c84d5c66c766c504f1488fd114cbb5ff641ba24266798c9f4e6d286cd0156ca75fb37ea68c559f4bd0903da1d92f7489a5bb7908a3032d230d2adf80e5fed6681a36e6153d15e8f7f2a516a50a2df6e0f8e047474d38e9e2af7d9c830df5df25b6b4b62a95969ac9c7833c7cc360d6c0b513d572579981c101e0446367959b31b69fc45dc87f98a7227e9263a28ac84acd3ee660c22acf7b04c37a29a7d36107e2f14fb73e247cfb7ca547a7c64f3a53db2869286c9f9bb61dae5aba0143038f9c2eb2f9d51df80471657ff7c60f86af0835e09e18176cfc647236125cfe899b5a733551b950d19b08e46a8451a8914741ae6703ee4d56f44101942785ed479139c5adf7beda6496404999673b4d9fb1905913b4ec3e09b102876d8835540a4c849da46e1f364c41c6ea6d3d96fa70b185949569a994743d48461a59d14814724d0cda5587f8dd936a0a24ff5d6c4d7e553c92f0df00287b2f8e6493aff444f964c9cf8e4f649e23493a35ab724157923aad42ce58c050da6059db17c93568fd3c847a534f13fe704f7b970debfb4058129187e0d23652ba95192ea68491e77782321ecd409e3f0eacc99f07812238417dce2bfc820ccdbbffd80407d0219449431248ebca3ce77feee48002d9e429e80022635fbaba89021d0c49a72cf0f45f1e819850ffff508726f814a2232491fc21ef0231fce5152916a8546b7c651e3b40bd18ef93d3062fdc4aaadc9dd994074d8d92a95b6e265b888b86e2680d29ab5ac2e2d8a935819436192c925f4326b00c5ea160ff1a19684f3603e6fd99fbf6288e086a832c9adf66d3534fa898b13e24f446d8939def588dfdaa600d5bc29884cee77e63748cc814b320a46459c74585bb441d8709ddf05db2df91c3353903208cf5494ac9b2bc9531925fb59d02dfab3f5ea813b51300f9ec54b5d3020bb94f0d38ceaa200ed9b031eeab1ee2809836d1a4079e5f30d2672ace6fd42dd00a6a2be04adae21efec686193a7937808105d6978d2ee697cdc501d3433e551e6b709d26ae47bfa7894edff979156e034087855e3ec91bae5a147723fba979a6ffc9c1aa64192f44f81b73e31432d663ce9434f097b473199e750c97522771501235aace5e1ef42a3f76866fc54b55bb01e5ea65474aba341f41a6828bdaea7b2a088122baf0d2665be7e88108015be4331ecf7da9faea598ca8b23b0ada1b82b645504be0b3aa8b66675086565d335269cb94bbc7b9facbba9de7f85febfda5992320b26bb0c86d092acf18d46a39a48813e72dd6298ec8fd58810bd2b804b2226cc8236c7f9568ef8a865f980f2f115223189718d36a8a42d9ccecd4a3db1f9339448b187a3c2dde91433b41cbd48b14ec9bf86f90ba4e310c4ff18f7de42a9c24fa28d92187131e2cda8fcd8f174811289b4dc83047c62ea8b76b00007e5ad5ed21a7bd293544b3b76996f4b1375677afb31273011eee854da2fe009afa4757833c57156b11fb62857d5e62b7f7f43f1fc747abda6c2bc0146d9afc56e98560961902c7a30f3cc8a2d7dda990d66da5a86687705238c913713e6d54665a6d6718d7c38edeb7e569b461b877574b1d79011c7b872346ee1a789c55491b22c5f02c6e38237cddd8f3c7ae1923c267e672f687a5a18e985fafcc47b15e61e81e9a0c2571cbf5df1277426bda1465afb75acd52c7ff3c6fe989d647e4abedcd26e124e846d32969a936bd9247588f92712f2a94bdedaad5e61b3a811ad7741640e2caae0287f2d940a9ab9f23aabc2f547361b235b13cf831a6b7c682d622e3aff0c442a394743026fc6c0192516a6d8343c621882b13c2b065a6230520a6d4e337cfa6d56fb8abdf5e6e4fcb68913998b047f9fae3d235f5893a1597c486b85cddb1d7939dceeb227d42abf563c61dcfc772f93962f25238c50026312aa3878279586ab803eb41d408ddca264bbc2f4e6fb207bc20c27abd6b96e25d86ffff7c10503052228e35d0a9f477a19d410db9d282b1d45926d2a06724726802549d995da7782556d613e2d1f939af65fead5a3ab8aa939380c402077499aa657cc4c0c40685093c8e7087440e11c5ff846cd24cf5b489b791be4df051296de541239c7567887d97825387b434f19dc0bdefde4c0270562d4c0dd37ff0a1c8e93e7b1ce6b024a724a5bcf879ddbfa20da9f6e27d7f0df3be1f7879fc8c5c7fe16d7a23052c3a84202c132538263933cb31005e3c3f5720692579cd4f95e83b048ea235b8a1544e2efabddea3652c95a61bb9088b57af7e9a5a35cf91fab59a829ff05d6e6daec395b3194ad72ed596009df23bb8e3cdf6ec001b8ad314ef655a390c7b59f836404e2b55e7b0bc80b019c50cc241f867bcfc32634354a79137f134c1b36acc298eb10dbed981777978503be2dcfa5df1624e532f6173783366a7979f74833a19cc1f383ee9bb810d0d134dc91e9834253e860b44ffcf1bd27236939529de99e59b3d47ba892f4232776a8b78467acfa887690abdcc4ec95728ba0a2913018cdfc66daa1aa8528d06a807c6224fa918a894f3168c7e9e3d41a508e22dfd510cc25b6b33c66a4cdac63bc6a102abd4664831d3e6cf9f6c0ac4132bae7645fb1f5505fb73e0934f0036f74d33c5680e047b709720a53fcf584e9c9dd7d08a9d7e07f2f409a01d1f6f43973ebaaae647883ce94bbbfab80a98dee9a025d82bd49eefcba7bc9ba8d9ab36bcdc7efac075055f505dad91c8055f71cca54344dfa8b17792afaf5c2da4b0184c193c2cda798e5535fc2937257413ac9984e7f36e9b546e1ce94259ef5ff8cd92a69985a0abd571542e69d9148b34317254294e4b5d5d7920c4a37b7e9dcf8a761480228289d8fd997dbfef7df05927766c349b1403ae0573a208bbd22b16096969b94872673a369e33ccbcce1626aea36c2e1321334812c29a41926a4be270936c0ab35c93108c09c5e405a6f3759661ccaa493e16215631b995dc4e3733bec42f2e178099e76c10e59569bf0c131938e81b7d88ca3e4372677f613a3061ab4b799f8f40f1dde57b4337f2e19da64a28b4fdacf9c0e9cafb727b4a2a94a188d66b60085b26d12162c875fe09230059b86b6682197752bfb402d8d920b0aedf06730ebd322136582436f4fe692fb216b0ba2e45b24a61e842b44e01471fb304c41d4a7ca063d23adfceadabccf3a52dba42289ce48d98237ff7b913ca765273e1b7d2deeea476ed304e709921cd993aaf07a13f36077e1b418a3a06d2965dde342e6aa637b1eda514659fabdd7d83ce5851457dc262f6750f7673afa0a1722396865024f7bf3f1972e142a2f3f9a646c14c8984f5d32e5b359401fdaeefc5405d0244987e7106027ba64e9ea0906c55890c6f7b82ecfad322d079dbb93e92b2b437d8aad30a203e787c47d152da6364ee25eb3dfc75f45b20f6be5188f1cd12e5b8f725127d37c80d855a48b373a27ba0dc08f0ef3b7a6056a3e083d7807400fb8c09704a10b124e2d39d6a141219dafd35c63acbf482e7a90381dd580a5f492d13fa8ccbd471819f2999c63159f13b330861c3e1eaa22c32eb3e4f1ee560a19a9a30479ade85aaf787c01856a727826631aaf7aecfe5d8740eddeb96ef1911564441e70fbdee9dff897b7f3ea3c0168ce24fb693c68c24dc8b4848c5a34aa3685a8090a5f880930c1f36effc4de6cdf8344252401903dd8116afb620f5a33ed6cc041aa945743c205536368ea6aedabbd59972f4b5973412582736584cc188bebe879e489efa4eacbaac9e549f97693082eee8a122f6064d2c26a67fe49c4e52c528fb4038f96e8da475a75232702634f5b41f396aa8bcadba4437221799c34966ca8309c765e476dc93d2c0ab9115cccfc0ca1686566d9db148f42418768755da3978790ccbe1c32006f8720c64397f18115c5231c8fbf4cda56b6d83c594a8adc8bdb12a267ddbf2c948aada2331a326e0bf6e953336d9fdfe5e1e8c98a64e69c6cc828d390e7f3831ae70b4538a2c661827fcdf13712bc04af5783f140111a9fb209963e3fa6b196064632c2cfb6b522515b788db52d459f2d60128a08196e11c4b91169c9d87c1414064afe44e018437d8f38639454b4f5b6a160d8df45de7fd11c82e7e490ce81670021f55103ee149e20d3441eff6904de58786d50d356f5ee27bb37a525648baedeeb33dd4ddf1de44377c46e2b76ec85f54febe498ca34d234e3c10d0aa1987fffe7474ecdfad642d9b3ea17cb20ac492a01f23c8f466bc712175db21d902af42bd62f03dd7b0e8c3bd2085c54268acc9cbd1cd7e72ff64022ee671aa5da6ec9a225f3f3bd385e65dbed96d1ebef958e09331dca0d1ec97dfdededb6970704b39a14a34546785b98a32252c1d404e1b4391423572a4c97596a64600a006855133590534335550ea70dbd0b693b84982b99b680b0458c6da065baef8f59199acb4ee0ac7f065a26843605606f82d3c9cfacd3af6c1526ff7c4c46e64ef5158fd53939aad677846b6312b50c919528e484a87f97f64ca92b46079b2b5aed0e0f331b104da82abc351ef9c645b5c4c3d0b69c6d29f0e0f4abe77ab66229c0c2c4aa389ec4e185f7c90d27513d7d4c0dd9234ae1a13d8039fd6181bf9c6306333f0f3393b1bb08bbe77bf1872011452f7f44790892ab36681a230e009e906a8ebed5e9eef56fa0f5b284c6b306821446c75abad63b28acc16a60e926fb9ccddf780f8453dffd50d122f71e16f1173fccddece04503ea06874e1aded1efbd22538738ff5358834474d46eebaa6ec5309f24f5a6b532a8217510f6e60c49a257f6befd0e65453f568dfa5f31f6c841aac7b0c9c44660113efaef75072beef50046c7167e899e39c45f9a1e144e3140420aab69df523b8d6f936cc5f41576ec5f0dc42a6043f53033d805b044808c88b262bebdae80589ace5ec4f578f5cde38f174bc223db4a3ca15e8800d67b37ce77b5ab3d9eae16fd8e4b76e537b452639bd136ead1fd7fcb112fe99e9e21ef17d514ea4d9333f9b1bdb39d7d9b43176b5ecb4911b0d51e0f864fd2aa0ce56d42c201ad60f4f53751ada7e964251c972806b5dde699dade93c53fc2e4917bd7b242b8093ba9162da7316d4641c1eb11c5bbb24154b471895c39e1e71ebeaa018a5ec13b35a0db527b0c462084fa7f2827c65057ff946a0d2dd5f2c40ae86f37ebb627c63c3550eef7bba93453c66c04e72efa98247f39c9feced2ebbaaa7779c70e8990b21521cac74da826e352aa3801b7d71423a5756d6adb7b9a58fbdfd7a572d78224cfd52067a9f319c25c58751ac8d84ea33afe5a85070e1cd3caaff2930677b80b3254d4319843b5b9c75696b25d1649a7c6f48bbc240eeb81d338c60b777f09d5ebf1c3e2bcacd42a34757f2ebd0b2b784f8fb8ca212ccf6d3383c8c167c14b777383eabba3f5734df925d8846a922dec300f1e740c68c0993bafdebdabf09f3500372856baf64b2966fc16e2fe3d8036412cddb8be468acd00b0b3909d06a84e5150b2d0ec2e5a9395e9d155b44d5646500aa04ea76b877879c7e3606e46958be203ea62db43373c79fbcb28b52e345f37e56eb9e51e63d32ac57a1b194b3a36ef4c5354560aada1f904bb267b3a41875b9bc9ba3a70da8310449e7de8410cd8b9bd3b9fba3bb4adc41803c677806f1fd18d6676ae8f1913c90195a5bea6d71641c42ea647333a37968519f9820b8e6d7708b40c9993f1b206db416a2fa4302ecf6c1146f975424d0294f6dc5ab98ac1aa8bc2984aaf6f65de3a37c9b04e117679b9e0a525c9e89320e8cf97914eadb2515ad56c443addc85235cd26b0b931f51972a936b80d8ec01d697b7ca954efd2ac699125e47bf66c690675c582d64b0058fea2c172dc15fcc403a05a759f175046990436dcb0b2e412202747fd5f4f4620997c9baf79439df3c645a22fb59e8699b3d391c7e3804a231691a084217ad4e9a6db012ba5f3578f67e38198f183774a96705c6340dacb3772c421ec93832c72f9c5ab2ec677b21bc5a62d8287a295f7765a1a31b9bbfe0531519488571afdc25ec0e085193f26962d01b662a72b63513dacb49dfe63bde4e422234d47927b09fa1b4ed48a9ea833abaf6101fafcb69961908fff46c8ed80edfb93d3095debc39706583a6a444aea83dffe56e4f35ed65c8ebf25c64b53711ad7d52299012408b3113b275881eb40db1332f8353060a5a4b2f392debc975382e5b23fbbcef43f4e2d9716e379a93366a8711372271a5de55672028da16b38c927ede4a36c5b717a7960160b016fa138bb4c8c74af35eab30fa9611ec3fbecbb8e0494f4e2181964f8121647ef0dc7f5692fca94b4e9c50643f05327182681a3524896dad6363b6edfdfda7cf118e119bc3e9d86162e4313620186bec915cacb7a9abdf5050d80ceb155f00dfe767937e86f6649b8552c8a980a4239e34793a9a6822d836dd7154b65d4f33a5158eff2927082a98dccc703880186c7725f0376e33d08219a44e914df85e64830193e7715576555d73ce7020087bafd8f9adfd6ea9fcab8f94ff31a65fe243a4fe34715b635642845f06efa88898a66ffde47fa1140f73e229cd360404afd9bf89fac1e568019250410f6e45cea474247e8655256308f094017d6b0e4cbee722d24b0fca0fdd34c9d6f03f553c5790f4e62045c0a36be662574e6e69ec11b29a0fedb4deb516be33abe829d4d7f3e6a2fd9dfdf548b4e149e407fda5723b8040f31d5563f47a74b21ec0dcbb401894aab18132852dc14ac800fa3efb6097eb3d3a5f3aae096a76df48fb8b76b0511e6383c3881b23bc1e1846e60f2a0fc2ea444cf3c6108ba42620c018aabe8c3b2bdaec3e069cb3f89225e7aac7323a592446b64a68bf94effaf54bde785f93b78ab2065f0cc863c76446e4f04894e4811276c9ca6a0258e0c4ab1501dfbd390516a5f18406b1d76979342f9de9453c2ab4f540383199f4391621b3840f025c3e4b6bca8e37e012887c208915ad9e40b0ca9068f20c2968b60975a15a7392f05dedec2a4e5537b1f62187c52d4384f2d8fa38360a55b0226cd01f745cdf3851d0f838f2e59700382582aedd51933b4ce1c2993af4aabc315f831f5eff5ed6559c7e342f044c292e8a2b995ba2192d0d875c86c6db7a1d3a9957d1ae8c3d52c24af9c3fecebeae19b0c384cbe09c92a35af0278d57631fa79a7656acd1be1d71cae9a8826d5c47f72ac9be31555abf8105d35636be11e13958e520066eec6a2e7eab2cd76c9813e3d66ade5f60c9fd941c3a997d9241b320e9a317bcbeca73598a68639317b393849e60f27db6a5ceab31b762dc2cdf6b058917200e13e753e09ead15631174889fb787023621bd69892b2dbfd01f0dbc79eff26049166cc3ada0d802c98bb3ba8c2af0ae9b80671ea8318bde2ab827ddfa0f615380ecb20c8a87daac9d68cb1fde27db7b3bc64184047d6b9afe5cb7b115930a009744b4b92dbe89bcded90e0c7a30b8d7eeb74e8cec023ca1283397cd2623a2f7dd6b6c5db55f555fcec1f4554f016558203400840da8552721e22c82bb1484524db819cc3185942ad581b0363055e98782f3285525b528a589879a9e3834a31c5136944837b61a619710fafa969036dbbe200aba377791715eb6a4ce674fb4bcf5cb219b414781ba8db8e8dac9492e4588644c0960f12618d8da5e6838174acf60b30ab9c0eb20750ce35b0268ffd394ea40aa60c7ac74aeb60df1cd6b1890ba1b0d524b745b88562bdd474a6e2f306904fadcafa0b698eb2c585cb12bbdf9bb54a07ab4b238d6f624d51f1c137c764ce164f24b9b76e1e230e456789fddc66953ef70c9e480b74929f28841cffe04b8b8f9b61e54d1b4f042c901399aede87034e03d2f1022794ac779b04b88105b00605d6024ff66954db0c3159e3f6918abafed4f0bd2d88ec238d930019d32788e000bf46816c899966cbea8a7eb2341588f2b233e27b41c0672091d3a3854e5ea742e6898bcca07b0f47a117e1c908cdb92a2175bb31fa85bfd38f57a50b13c5f56c483eb82874725e1b6a7a79e998da9eaa29048b09550a7d3b73b8b4af300e800bd23d871fa3549f79f48729929a558e8eef98ce5d7b375feebf90dfb2178740983f87d91ecbfd75aeee0e7cb0d3a4394d0b3a383ad7b07a68823c2fc421800c2670e9a88a46459484c53346d97409f909beda620c2d5be1af04265912d6e1602da3035e7934a616536c421618f4fd13df911b423c5c2ef1faa6c14bc761529e0478d109765a7fb9056676909280f306c2a4e5ce6f3653d5a575a9917aab41e91f2c149c22dd5ae3c72d64a4cccf9d150f62e75baa197e08c3c0593085495779903e107bfc0201d4db24f5a4b844a4ba859af7e77cae77de8e9a2469d811624016441f27a4a3d8fc58f292a151bc0d602947eca095b0ea715231d9cac7f9f016b0c5e3273edf705b6d14c87ab2b84b611ea6601c9d86700852fe4e387b1a1df19a9be6bd05c3ab5ef2b697ed393d01f153cd55246c851e4dd5beb20d6eba3a1fa65bb5ba8fd3bdc3ad3ca4320e7b68f200d2668b6ae04c8e6aec42a561e017141a881c71e5d280f11dd206a64c4652fba21cb8f523d5b5dbffdca0cb21bdcd75a3500d187fe5b664f4f5a35258c62e926041656bfe634b574d856e045205a9916ecea1f0afd06a8068731bcd89090118d003596228ef31fa15d0f82e22c1df1e031f5ef670ae205d5af7425f8509cf8dd54ff090f160e08245f646735e6364ae295b1bb591615cbdb22666638fcfeb801b0d957ac1d9f288dd099988e86f9f7dbc0045aa12f6e0ab6a919ac19b9c781b0a977e07470aafb5b29c7c3a20ddc2c2180dae98da6b93bcbe1b6c8349fdeee36f912181d581df54cb6f294e7a3f813c94bc11e7ecd195ee891664bc7b9e91e5bce72d54bef434b2a5981b2f4ae3568fea3ddd920c756113f4dce2b38f0b65a97fb129f453aa50478ce76704608bf31cb3b626b2246d12eecc1bc06b3c0069794c5da2d56730c3569613b2d8e8cb103fe2f0c785c7ded97b50e216a004d2cd9d9d032d46bbe704f3d3341ce91b3eb2e4b06adabad006950e35b55f560d1718a56888593f6fdc2074f99983fa3e221bd6883ddf05588de624ea7c1e9e616fbbcd1fbefdd2109e3a247b07903afd7ecd5b8ffd264d29095bf31df654bd415720b9092f4b8c10035949e1a592ef25c27dd88d76c157f711b1823d1f1f3b7d7faa07d70fed1aca7cbf66ee5094f2b5d6bcc4e9019ec4788325ee7cbdd1e4506073f1120b0632bc9fe1500392dd9757c6f35cc5fb671d69252c65a5779987beb4fd090074f718e6675e2ffba436ba644a204ebb8c71e91a4cdf455e7301777e1162f81fef8fcf84e6188fde883dc84dfd2d254f4d74708a3ae2407331414abbb30fff2bd8d54a61ab424657d897268511d87316686fd7ec603f92358cdc17cbff7723e5e271892feb9da7a4f6f681677298c88be87b1175ff29510bc9dd6783958780605bf786c007c7c9fe080abf7695bb9eb7fe0cc080832a6b741de2ab39e9ad8a99647d7dacd019c5985eaff2d00d7ae2f9da91244b56f4fc59d2420a4356c53c649047ac157263c0b3bba185d6fb6534ae7f9c17c1fefec2d6d64adbd8b8a51e2fcda9cf42994be7d53ac384b975173a7348f70a083f6d44838c6f19a88638c9d9c787d864165c30b0cf33addc195f185f61f4f10e4279ac4abc27ee7b753048b8a280cf47846e03019e423656a3f08242ef25bb5e98b916b798ffed53aa65079bd8223d7d1f6867b36f14efa863578a5d6640053a9033b316ba346f83735e99e475a95c2a507a64af532d077cd418c50b6e2af705ca8e235e9d7962841387634db2be7d0b107c0cb8d540f1de7be62e435b74aef35338fabb4d0b3878a8a93f41cae901ed5e06dccdeb2a2c02dea9cf39def72ba1581435d6a0ef398fbb16e8de0708ff25dcaf102ad89079d7be5343995aa06bbb7bd318bdae82007c55062da8229de4bcce65f6c152953cb5d173872bc0574d941182e60753ff4e1ef30308c5686e31f8dd6ddc873919d709fd103d0335e7d0512c2320571aae6554ef6551fc3eb5246ac5484ae02d841e4ad446e389dbb7fa5d74706bb1ac3ab1099ff52fb2debc0b49517a0f84c31a30d57144fbf78bdec008d7604859512848384d3def214b9efb396254815d5f07ad8a9a94f46135622d43650af35f923f9b4d3302e80fd5e2370dcd9fab460f149866f3e7a0b9822b05b98855d8961395f706e6ad0f6ee03880e50bc084a39c999ae937f9d54ebd36a3228836bb153a2c1420335d24c7b60f5cc0b271b73d6190cd2c1daa4baab0a1813b446a9f6492cf5312be1ad4b98aaacf5ad3063da7b88042ea5f9bbbdf74367df5a9a70bb53605afed51a08ceba3fa03e1540147270e25f658563d0140548471f90c95d11ebfe55e732018a6f7a7811e3a5beb66eb2c3dab16428d7bd93202a973a7c22b22c27405372c4af63c3249ad1a895180927bebd0d84bf66f21329d93dd9046fdb1688999a9066e63dac71e060897cd7b5be04b50a11954cbf80e811e5c29ff0934deb5e998e9ada1c1c08051f5e541093d7f1bbf447d0729a4487ba7ed003e100b81f5f9caf12ad32502c8d9eb4d95692d1c4921cecf4bef959c55afd41cb9105a7de3849ec0fef73e02070db547ecfc1d53f15c443de3e18b394d3bae2ab7acb71c9262a4e78ec0052ea18b28acd161b5b99c599489832e02a9a717032e41e68b2e235902935ff305e293e11b59a7e8307583aee06adfef5da72fdd69be0a094294f4ec82ad2b4c6e82629f8a50f02b3d399c4267c30b47d0b1ee9a1665d1f0f62b63b23b03801b32ba6f364f1fb253740b99a652d9369b260d1476884ecc60948059f8d8d01722faaedea97d56124439ab4d9db5f61c5cb373114718b5de99397cc2f78f67e9dbb540fadf941549f7c0b4d91cbdad94aa40ad0585c074c1cede8386accae47195cee685c512491acc64237137b73dcdd2d08bfaf9a93532afa41c48739d6d5760a62485a05443e23e414067c6be3493126c94a724d4c5111d8adfb68df8105d386b31ca9831155c48f1503a995520d098f24b0e84c41df49c48e0c8926934a78bc5c24589c8ce2fec7caefa12879789878565c0fc8d10704a7b35d58eed7caaf6cf5a3efb3d923883b4241fd243ec8bd92cc7635acf10aa2269746816b6353289cf4213e12b3528fbe07fb69ca5d0a36b017979dc1ac1dc7a3f763bd1a247bb6fb84540449889b90bc9bd3a80cd0a5a0fec412ba39af6a9c15415e0cbea997146929a07a03774aba2fd572fbabbeb72a3e3ef1b484a10d124700028b0380caf46a0a474e00f3e66f2b26f5e3488a5679bb91ec17623d700bfabe4d74ca9807928de78be325831646ac394ec54fcffc0a10247b6917d310a94dc2466f276e35283efef781f4b7d22efdeef733650c34218dc5436055de3581cfd8173c3995e3fa1705ad88edaff927854f230c0d992c0b61b330b6f2798b6d6ee5e6290b105feeb35bbe5f625c0914e711f2ee5cff5cea369b3c62a062a43e988d765b56b9a3e04ee652415b695832488079a4209f002c17a03cd6a3e567c1d5560ed569fe9b38409d949573d5506cc5ade29e1eb268c2c1d98571128fcaddda76282b10af5edd3752f2578b624e88155bb6699e5f21c895d4772404133ad05c857206ffc0428b51e8e056d33aad0805ccf551a4c1ddd97bf149742cff5c522b1980f33a85a460c90929a3bada21f87a2ac1a97a547cb813bd5000b2b9da70bdc3e9750194ce92e99ab04a2fda99a4868a6ce51674770138921991799f01487297a772bde6d99cc3b1c12ce52763da512a586c3dbbc0c2f0a895ecadc73503a2e540df1ab3abc7bb77412a18ed88ed8b58f90f316b1a252265c6fd1bd6f8be1ef705462e92c77d656e7c933ee686ebd80402b134e389ca709d94167e3e51be2aeb4ed5e5a0bbf87f0d3068fa05e9759b4976733de3ac2dcbefbd3dd3a318ca6391436a045565e57ac9a409ccdbe9b10b04a28498bada2b1bcb5dca58e32db01e495b9e8a9d4f61d93513d70fd14a3e605117869dde1d33f9581cb30d5ddb3736693edb92aa1d38d248360afaac59a560f0d7e40e194f3ebb10c102084222d604c956f01c612776162e0f4bf322737f3f202dc81d805409e271ada139a627824fc132ae369912f79d63845579990d81aa4690ed77bd6d36a61166a840017e43d71706261d0b8069e46cfa217182bc45f9a2f2d3408edde7a90c80962f66b3e1ed38cb75bc8c0af45082c1060375df014856d5b908dd59731d0f7033cb2e32120f581b341d8d5662d8a21ca73ba168b26d2dd67a85c2e91f253435c5c74f61ed83baf9df2b1ce968a233564bee142fb87d60faf2608835cb58f36a8eae4d907347e3311efbc403c8428456f27a095a1f712814025d8c45cff0cf7060b074e70def244908c2e2b0c8e9125dcdf46323b04dc26cb8ac1cd9aa05646fa457e69752c511a5be2a859b638ebb36c83dcc6ce8fdf0b9af42b1b8a167d1e7d371168391bdfb29aa2f99b92ef027fd761225679a9b05ae8c74209b7142ec3457a43d3a126c1d4ad0d36ac65afdf83bc1d6f94ecbcfa06704181542c768295496033d3f23ae8b3b13f301cb1b49936d90bdf44d2ac7bbaca2cdc0e4288f20514475d7af9cd540e88933d28be5b117e1c2b61f79da701eafe173d64352fdeeb5e1c43e09523cec46bb9bff485763b19221406cf3ad564fecc048b1d6a8171d496d1446ef52a9b9bc05c7de28b9ae41bab2f58212878f7d3f5d7fd4f7175415b6c70da1fcfab89ac925e729990d2927bf54a0491893ba47e135159e132f49a69b709f02399681429615f8fa54b60c7714ebe4c5a699a653fc5c4e1bd5494e3e0c0188808c6a2eb2e5f77cf7a56ce3a3ddc9b170090e5b53ac9cf43c6b22cb32659f93a6d09b4da00f6d65a111dbf1ae92e28e5d8e06ca08693b5ff140315086741960c61fa800cc300284a4eb74144e3522af79b4a53d5cf471f03411e48258ca4baad2a62f81e4cbe86d3982819c47d0cc2db5d93b8048e3bb7efd8098cc88fbaa084ae144b6a91eff4193e0747563606358f1790909bfa3a74e437c180f870e78522f0d9bf7236d682b35a32a8337a3467bea48f16ad9f4fe70ff1db27e87e6f6494039e46069160dae302da38d1fba1c11906581f05c77363b6a22fd78767ddfa091b05d12bb0d052f90be9b79b149dd2ba4d6f60d5b7360a52d6bc319dc5d6e241661771bc65509bd740a87e314e149728e1b0ab150e9044b86ba9aee31219f65bcdc8061867810ae4a918d1ed9370a2b705c97d8c49f4732d0756bd4022c7cfc0a083beac84781bab5ff418206e9e8ef740c5b5a31cbdc18f9847acd39dddf074950a86909e67d2330af13c4ca5e1aba494a716262b7558395cdb5f4c3621c5c742e864743c7259c055a5dd3ba703b36fd5563b80f3878cf667d4b6c8e25d8acda7b4863c416caae5d5615c1443171d9526b9330ff38dd25c3d9f4d92b591b93271ab7336a850b4f4dbf6c2b100b2b32c81ff64bfe8cf01ee3bec2d1f900a5b26e519fa5184c85707db9ff04075062a0bcf6a62eda4b2e93c8c6e1e48486d5078ed798d09ca370478a0d63fab316fb548f5b1b2d3c214f735293f562f067e30b7e7ccc5a11a72f0ec11d2446f5226d82bb1c59e8da39ea77d61f4ddfdf990ac833870bf1c0a5aa8ec1c4e88afbcf8cbab21bd092c653237f69392917e8238023d772b9d9812fcc901bf80aee7caec58a1202737cc13459dae01518e771367fa9216b1b64587400af460444b7a11b737eaec3537895f9f1e41a2b02a800a6a8de1a25d92216f3a925a24aa1589acf71118167c92abf422f11f4489f3078fb34e563f1d27fbbfb24d0a43d37895198b3a4f4cc9daaa6c0d23cb82b86ab842285d7b14fb888162fec793aed6f64e62292a889a144e01be83c11d6702605173e5774007052af36eeaa801260602111691b43b16ce05291d3af6bcfdf5ccc579202ce6ebf08bd82d3974327833618ea0706245f63f7029cc082c5be6a9627351909ada229163c942bfc96dd465a7fc630e4aed606130362cb0e2ddb50b8d0e1a571d33c0e68bb5e4c3d1aeb8c9f40579fc054b1751fe23d6d8d66b51fecf8f58dd6473c063f750c462eafd9f1a2f8d2b8773fa49b83e85340ff028f0710c7b05c1eb22c2697aae0fe69e16cfedebb81eb4624d668fca1de94b3a56c949e62396afd87194e44da0e27339ff28f3d44e18fbce042ceaef211df5b2507971afc8128226c6603fee170bacce527c8f04201a714ecf54195f8c2208a83b5c01366897ff193950b0eb1937cf3167dc2429f1c34b54ab5272df1a64d474f135099c48e2d77b799f3173013eed1d56154ff98cdbb21924f92d7f395b573d7c67ce4762b50bdc2b42ddb34d9a7218848a6bf044bbc0b7ef314466ec09cd4a7b8b26b3a6194e68ac8cac317474a82c599f6bfc8528b9f138f1b9a73b9d6210e9a1776319f57e52557b242570b3f54ea43611343ec88d9c9c9de295a52e83856f3289e69b46cfffeb4ea26ffb6bf90aba801c77f026d53a680928341753e4b473e55eb9edbc4159c8bec485e235fdd2e63ca80089065fcd6392c16379ed882ac4b87ede48097f6452b6e198de42fe7024026728579a9ecb70c0fdc7501c973622517d6478817fb29aaac8ed48e35cf82f8ac8b3450f8422197e6f469a61ac4adcd0c9b0c83772ce40c854a9f20598eec468a76b37edfa6edef1462152543c1a46e6327670f7ae1da5fee103c9499df1f5dec4be4d3478e01298460872a556f4083887879d83c5d8fcca3e1ab00123a5256b9eeee88a929c229187f468fba33ba39671870be2f20ac64eaf5349f32cc23af03f74e50bab371b754b061e1d658282c1b95ed847c0ae70ad1d5699de175b88970cbb6dd4cd1702f077ac532267640237f8b3cb3ea20e8a026dfe8195ac1d2ba475930f66e47bcecf46e8592638112be6e9fd5079298349955faad1083bc497a21bf907665597abadbef13c4f5f2546e02d1c182951b3207724b6ca472096368c4ed3a50fd8271307aed9414d78b771892267375cc7f2f8b4ec820a4ca52d82c396cdb81aa567c2c786fc2f73de0db125b29988686de11ecaed73131463e47c240947b5f3308496e2185d9f81608789d035400fc44a97936d0a780edacb3ce5a25ea91d0bf0be08b462321e4f5b56c0867248eaf0ff9f453e01b4165623d19bd03a70fe2507fc613ae525f8c26deea7f16ffcc4f0a61dfd5ea3bc0aa6bbf0b0d542eda7dcf1f48aedd39897240eec8ebc75905ef5bcf5e142466c2799f5a437e0cc0bb91b33185eaf7fc039f9c1425be934f0c3b6b627bdefb067935f5096e5ad9aabd0e12f48ae024bf5fe79f9aa9812aac66ddb95fdde3c3c73370f731c6b18087154599b1da15cbdfb70ecaa46ee29cdc5d5bb0a3aa621f128cb459c0d2edc332bd949e2cb8d796b63fbc9e9243ce1aedd291c4da5870f2f65448d25daccf00a209ac26f27b81f664fe9484584e80e7b4b876f00264435b864ab4f31367a561eeefd2ca356cb9dde0471deacf8bc04124e100c2332546a7e722c0b7b66f570cfef0375398c36223777daa7cccd01572e38b8b2971e931747c5f9d5a955a793d708c026befc7f5c3a0c8d234b8aa0cca69f95bd5efccda1bc59f1f7346afb5a4dd9a089378259f4c65aceaff65f6c0242febe6245d262dc7b18180a56a50feb406b7c39ca5306c3694514a62e876bbe68c754ef537cafec107b8743ad332a2511477385c1dc2aaf37cb2ec1becfd98b8d95a06359822312497dbc98474b53e3336e417643ce6e71f67e8ceb7d5eb9b600c297e0a55b834bed7823859c46c9fa92da1a81c45e4eea486e0e1f0a222836431a3025a94c31ceb741672334ab281255c7f20753176c1b4522ecc20af0d84841be57bf51113717b238996db3693402ce59393247964baae3ce919ca1ad9b086ba9d41731d2a255d9fbd7fa582f58c06235892014d54c82723e74f6335a60ca1a2adf90f95799bcf41e3d08e1619348ce05a20b66fc2b5067de6914cd68783e4df54f9ac3231b1d6bda5feb79f618f2ed59cbfd7b1aeb0d379ffad5130fb0ed0dc2da30dfa555b39a5592e0faadb2e2add0df64177300a3aaba75bb40b794a23757678ac6d6e462699689eaa9b52df14dc4320f196bde1a20d7c2b3297c7c648cc46733f736dc950a1bc254157f6264a119d978efec5b88ec14d0295632d0ee78159d2932fad93dc1775b6698833811c656b27a3bd50e3ac70d222b36f1d7336bb481d2804b0b0b76f89e49423b2ff72813aec6554b00cf48e8d03c943c10dcd5821bf86267160b5f0b72f4b40b60db1f4816306e6f2b0a498cc2a54529aef30471d354b69ff9216364371f2e29dedd52aa0b7b73994a3fc292524c73f76d7692f40272121f86bd1a52f078aeb6f7880055679711e038135753881d3c31612b98d6c76a43188889eb2fea496d174ca5498d99d3bb73f0eff139d0b296e41cc62a840d4a2513bf9eae2dfb4340b54101f4b962ec202ba18896d6564df7863a07061b1572c76d31043e55368e3b126bba4a404bede0539d482b7fcdede5c6e39de15f3a17e9f22d272c5ce23f4a6654bbb8828572691fe0e64b3b7f268b169d58063b08005ebfbf6a48ec10a5988fff081995cbe2811cb80f9d6d0bf437d83feceb3e767652a255cedcbfda1805034bf9fc3e34115bc2d675b2778b24b7a829611d3980201c4f007f8ab1ec10bb8369627af6e3d746205c9bfeed49d3cabe8791e76b9c23fb349b3f249ed6c7234ea1436ef176189426e6211e7d43e0cb572fd71b47b736e8db1ba95327566d33c517a7cf4809294eee88a58d0477a17f5532194976e5a02bc0155539016a82a95919bed2456118b0d89a4c7e06e6ecc23dedd3b1db38aac7d131511b457818229fe6b1dbe09c06ed67a474b2c01b15246d1e944656a1f694b713991ba9ddd60f95baf8061d6e184993ee19d98fcd015a74c6a41a8376eb3508c5adaf58116d3e9051986347beffaa745949664d617eda1d2bac7ad89434be611a94bf5f7d0633219ed4261f66b63f66588ef12bcb5030420c5e6169d8eb5d086f2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
    <category term="高等代数笔记" scheme="https://triodelzx.github.io/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数学" scheme="https://triodelzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>XYCTF2024-疯狂大杂烩！九转功成复现WP</title>
    <link href="https://triodelzx.github.io/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/"/>
    <id>https://triodelzx.github.io/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/</id>
    <published>2024-04-28T10:27:31.000Z</published>
    <updated>2024-04-28T10:34:04.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你能突破九大关卡修成神仙吗？</p><p>hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！</p><p>hint2：flag格式：XYCTF{md5(flag)}</p><p>hint3：第三层非夏多，看看交点</p><p>hint4：第六层键盘画图，狼蛛键盘最新版你值得拥有！</p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>由提示猜测压缩包密码XYCTF20240401</p><h1 id="炼气"><a href="#炼气" class="headerlink" title="炼气"></a>炼气</h1><p>第一层是天书加密，用随波逐流就可以解出压缩包密码。</p><p>第二层是一张图片，修改高就可以看到flag的第一部分：</p><blockquote><p>XYCTF{T3e_c0mb1nation_</p></blockquote><h1 id="筑基"><a href="#筑基" class="headerlink" title="筑基"></a>筑基</h1><p>第一层是<strong>BubbleBabble</strong>编码，<a href="http://www.hiencode.com/bubble.html">在线解码</a>就能解出压缩包密码。</p><p>第二层是一张图片，010看不出什么东西，用StegSolve通过LSB可以找到一串Base64编码，解码可得flag第二部分：</p><blockquote><p>0f_crypt0_and_</p></blockquote><h1 id="结丹（全复现）"><a href="#结丹（全复现）" class="headerlink" title="结丹（全复现）"></a>结丹（全复现）</h1><p>给出一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281730505.jpg" alt="hint3"></p><p>hint说看交点，可能跟Begin CTF 2023的下一站上岸差不多，四个交点为”-”，三个交点为空格，一个交点为”.”，可以转化为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- .... . ..--.- - .... .. .-. -..</span><br></pre></td></tr></table></figure><p>摩斯密码解码就可以得到压缩包的密码</p><p>打开压缩包发现还有一层压缩包和一个txt，文本文件里面没有有用信息，但是压缩包带密码，用010打开看看，看到末尾有一段附加信息：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828487.png" alt="image-20240428173027310"></p><p>分析特征，显然是Base64，解码之后可以得到压缩包密码，解压发现里面有一个文本文件，由特征可知是Base32，解码就可以得到flag的第三部分。</p><blockquote><p>misc_1s_re6lly_fun!!</p></blockquote><h1 id="元婴"><a href="#元婴" class="headerlink" title="元婴"></a>元婴</h1><p>hint4.txt打开一看发现是base64，解密一看salted，用这个网站解密：<a href="https://www.sojson.com/encrypt_triple_des.html">在线Triple DES加密 | Triple DES解密- 在线工具 (sojson.com)</a>（一个个试出来的），密码是2024.</p><p>拿密码打开压缩包，有个hint.txt和一个db文件，hint内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wqk：1m813onn17o040358p772q37rm137qpnqppqpn38nr704m56n2m9q22po7r05r77</span><br></pre></td></tr></table></figure><p>进行一个凯撒解密就可以得到一个key，</p><p>下面是在52上面找到的一个解密微信聊天数据库的脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> hashlib, hmac, ctypes</span><br><span class="line"></span><br><span class="line">SQLITE_FILE_HEADER = <span class="built_in">bytes</span>(<span class="string">&quot;SQLite format 3&quot;</span>,encoding=<span class="string">&#x27;ASCII&#x27;</span>) + <span class="built_in">bytes</span>(<span class="number">1</span>)<span class="comment">#文件头</span></span><br><span class="line">IV_SIZE = <span class="number">16</span></span><br><span class="line">HMAC_SHA1_SIZE = <span class="number">20</span></span><br><span class="line">KEY_SIZE = <span class="number">32</span></span><br><span class="line">DEFAULT_PAGESIZE = <span class="number">4096</span> <span class="comment">#4048数据 + 16IV + 20 HMAC + 12</span></span><br><span class="line">DEFAULT_ITER = <span class="number">64000</span></span><br><span class="line"><span class="comment">#yourkey</span></span><br><span class="line">password = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;...&quot;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="comment">#这里填入上面求出的key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\MSG0.db&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#这里填入MSG0.db的文件路径</span></span><br><span class="line">    blist = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(blist))</span><br><span class="line"></span><br><span class="line">salt = blist[:<span class="number">16</span>]<span class="comment">#微信将文件头换成了盐</span></span><br><span class="line">key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, password, salt, DEFAULT_ITER, KEY_SIZE)<span class="comment">#获得Key</span></span><br><span class="line"></span><br><span class="line">first = blist[<span class="number">16</span>:DEFAULT_PAGESIZE]<span class="comment">#丢掉salt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import struct</span></span><br><span class="line">mac_salt = <span class="built_in">bytes</span>([x^<span class="number">0x3a</span> <span class="keyword">for</span> x <span class="keyword">in</span> salt])</span><br><span class="line">mac_key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, key, mac_salt, <span class="number">2</span>, KEY_SIZE)</span><br><span class="line"></span><br><span class="line">hash_mac = hmac.new(mac_key ,digestmod = <span class="string">&#x27;sha1&#x27;</span>)<span class="comment">#用第一页的Hash测试一下</span></span><br><span class="line">hash_mac.update(first[:-<span class="number">32</span>])</span><br><span class="line">hash_mac.update(<span class="built_in">bytes</span>(ctypes.c_int(<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># hash_mac.update(struct.pack(&#x27;=I&#x27;,1))</span></span><br><span class="line"><span class="keyword">if</span> (hash_mac.digest() == first[-<span class="number">32</span>:-<span class="number">12</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Correct Password&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Wrong Password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">blist = [blist[i:i+DEFAULT_PAGESIZE] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_PAGESIZE,<span class="built_in">len</span>(blist),DEFAULT_PAGESIZE)]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\ChatMsg.db&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#解密后的路径</span></span><br><span class="line">    f.write(SQLITE_FILE_HEADER)<span class="comment">#写入文件头</span></span><br><span class="line">    t = AES.new(key ,AES.MODE_CBC ,first[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">    f.write(t.decrypt(first[:-<span class="number">48</span>]))</span><br><span class="line">    f.write(first[-<span class="number">48</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blist:</span><br><span class="line">            t = AES.new(key ,AES.MODE_CBC ,i[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">            f.write(t.decrypt(i[:-<span class="number">48</span>]))</span><br><span class="line">            f.write(i[-<span class="number">48</span>:])</span><br></pre></td></tr></table></figure><p>用打开数据库的软件打开解密之后的数据库（我用的Dbeaver），在MSG表里面就可以看到flag的第四部分：</p><blockquote><p>L1u_and_K1cky_Mu</p></blockquote><h1 id="化神（第二部分复现）："><a href="#化神（第二部分复现）：" class="headerlink" title="化神（第二部分复现）："></a>化神（第二部分复现）：</h1><p>hint5给出了一串字符和md5后的结果，进行爆破，爆破出压缩包密码，解压<code>第五层.zip</code> 看到flag.txt里面没有有用的东西.</p><p>serpent.txt文件里有东西，考虑serpent加密，用这个网站<a href="http://serpent.online-domain-tools.com/">Serpent Encryption – Easily encrypt or decrypt strings or files (online-domain-tools.com)</a></p><p>通过文件输入，从头到尾没有密钥，猜测密钥是前面爆破得到的key，解密之后下载下来塞进Cyberchef可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828521.png" alt="image-20240428172659005"></p><p>导出为txt并转换编码为UTF-8后可以得到：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726731.png" alt="image-20240428172642676"></p><p>字数比可以看到的多很多，考虑零宽字符隐写：</p><p>将文本转化为unicode编码后：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726082.png" alt="image-20240428172606982"></p><p>筛选发现，里面包含零宽unicode字符\u200A,\u200B,\u200C,\u202C,\uFEFF</p><p>用<a href="https://www.mzy0.com/ctftools/zerowidth1/">Unicode Steganography with Zero-Width Characters (mzy0.com)</a>解码即可得出flag的第五部分：</p><blockquote><p>_3re_so_sm4rt!</p></blockquote><h1 id="炼虚（第二部分复现）："><a href="#炼虚（第二部分复现）：" class="headerlink" title="炼虚（第二部分复现）："></a>炼虚（第二部分复现）：</h1><p>第一层是键盘画图，是一个句子，不确定的字母可以掩码爆破。</p><p>用上面得到的密码打开压缩包，可以看到一个压缩包，一个word文档，一个Excel文档，一个PPT，一个文本文件还有一张图片。除了图片之外，都没有看到有什么有用的，直接用steghide提取一下，发现要密码，发现上面几个文件名称都是数字，倒着来输一遍（98641）就是密码（纯猜谜），提取出来就可以得到flag的第六部分：</p><blockquote><p>In_just_a_few_m1nutes_</p></blockquote><h1 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h1><p>第一层UTF-7加维吉尼亚，密钥是字母表。</p><p>解开压缩包可以看到一个图片：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281724825.png" alt="flag"></p><p>就一个八进制，按颜色填数字就行，八进制转换之后就可以得到flag的第七部分：</p><blockquote><p>they_were_thr0ugh!</p></blockquote><h1 id="大乘"><a href="#大乘" class="headerlink" title="大乘"></a>大乘</h1><p>这一层的第一部分是一个RSA，显然是p^q泄露，加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line">flag=<span class="string">b&quot;password&#123;xxxxx&#125;&quot;</span></span><br><span class="line">p,q= getPrime(<span class="number">1024</span>),getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p^q=&quot;</span>,p^q)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n= 22424440693845876425615937206198156323192795003070970628372481545586519202571910046980039629473774728476050491743579624370862986329470409383215065075468386728605063051384392059021805296376762048386684738577913496611584935475550170449080780985441748228151762285167935803792462411864086270975057853459586240221348062704390114311522517740143545536818552136953678289681001385078524272694492488102171313792451138757064749512439313085491407348218882642272660890999334401392575446781843989380319126813905093532399127420355004498205266928383926087604741654126388033455359539622294050073378816939934733818043482668348065680837</span></span><br><span class="line"><span class="string">c= 1400352566791488780854702404852039753325619504473339742914805493533574607301173055448281490457563376553281260278100479121782031070315232001332230779334468566201536035181472803067591454149095220119515161298278124497692743905005479573688449824603383089039072209462765482969641079166139699160100136497464058040846052349544891194379290091798130028083276644655547583102199460785652743545251337786190066747533476942276409135056971294148569617631848420232571946187374514662386697268226357583074917784091311138900598559834589862248068547368710833454912188762107418000225680256109921244000920682515199518256094121217521229357</span></span><br><span class="line"><span class="string">p^q= 14488395911544314494659792279988617621083872597458677678553917360723653686158125387612368501147137292689124338045780574752580504090309537035378931155582239359121394194060934595413606438219407712650089234943575201545638736710994468670843068909623985863559465903999731253771522724352015712347585155359405585892</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)<span class="comment">#随便设置，但是不能不设置，增大递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_high_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp0 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq0 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tp1 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq1 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp0 * tq0 &gt; n <span class="keyword">or</span> tp1 * tq1 &lt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp0)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[lp] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_low_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp = <span class="built_in">int</span>(p, <span class="number">2</span>) <span class="keyword">if</span> p <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    tq = <span class="built_in">int</span>(q, <span class="number">2</span>) <span class="keyword">if</span> q <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp * tq % <span class="number">2</span>**lp != n % <span class="number">2</span>**lp:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[-lp-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line">mask = (<span class="number">1</span>&lt;&lt;<span class="number">1024</span>)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">leak_bits = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">leak = ...</span><br><span class="line">xor = <span class="built_in">bin</span>(leak)[<span class="number">2</span>:].zfill(<span class="number">1024</span>)</span><br><span class="line">pq = []</span><br><span class="line">pq_low_xor()</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pq:</span><br><span class="line">    <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">        q = n // p</span><br><span class="line">        phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">        d = inverse(<span class="number">65537</span>,phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>得到密码解开压缩包，可以见到一个txt，打开看到一堆no和yes，将no替换为0，yes替换为1，通过下述脚本转换为图片：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">    pic = Image.new(<span class="string">&quot;L&quot;</span>,(<span class="number">548</span>,<span class="number">72</span>))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">72</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">548</span>):</span><br><span class="line">            <span class="keyword">if</span> s[h * <span class="number">548</span> + w] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">255</span>)</span><br><span class="line">    pic.save(<span class="string">&quot;out.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828921.png" alt="out"></p><p>是须弥沙漠文，对字母表换就行，下附字母表</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281829364.png" alt="fcd8e8310bde689198d4be3e6b749f15_9129134670435119053"></p><p>换完就可以得到flag的第八部分：</p><blockquote><p>sm3rty0ucando</p></blockquote><h1 id="渡劫（第二部分复现）"><a href="#渡劫（第二部分复现）" class="headerlink" title="渡劫（第二部分复现）"></a>渡劫（第二部分复现）</h1><p>这一层的第一部分是一个RSA，很简单，加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    a, b = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">8</span>), randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">    <span class="built_in">list</span>.append(a * p + b * q)</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&quot;xxxxx&quot;</span></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(password), e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;c = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">list</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#n = 107803636687595025440095910573280948384697923215825513033516157995095253288310988256293799364485832711216571624134612864784507225218094554935994320702026646158448403364145094359869184307003058983513345331145072159626461394056174457238947423145341933245269070758238088257304595154590196901297344034819899810707</span></span><br><span class="line"><span class="comment">#c = 46049806990305232971805282370284531486321903483742293808967054648259532257631501152897799977808185874856877556594402112019213760718833619399554484154753952558768344177069029855164888168964855258336393700323750075374097545884636097653040887100646089615759824303775925046536172147174890161732423364823557122495</span></span><br><span class="line"><span class="comment">#list = [618066045261118017236724048165995810304806699407382457834629201971935031874166645665428046346008581253113148818423751222038794950891638828062215121477677796219952174556774639587782398862778383552199558783726207179240239699423569318, 837886528803727830369459274997823880355524566513794765789322773791217165398250857696201246137309238047085760918029291423500746473773732826702098327609006678602561582473375349618889789179195207461163372699768855398243724052333950197]</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line"><span class="built_in">list</span> = [..., ...]</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">for</span> a2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=<span class="number">1</span> <span class="keyword">and</span> gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=n):</span><br><span class="line">            <span class="built_in">print</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n))<span class="comment">#这里求出来是q</span></span><br><span class="line"><span class="comment">#--------part2--------</span></span><br><span class="line">q = ...</span><br><span class="line">p = n // q</span><br><span class="line"><span class="keyword">assert</span> p*q == n</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>解开压缩包就是一个带图片的压缩包和一个txt，txt内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">压缩包里的图片真的有东西吗？不如看向外面</span><br></pre></td></tr></table></figure><p>图片里面确实没有东西，由压缩包名字“我们的小秘密嘿嘿”猜测是oursecret隐写，猜测密码是上面解出来的，尝试发现是正确的，就可以得到flag的第九部分：</p><blockquote><p>_nine_turns?}</p></blockquote><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>组合之后：</p><blockquote><p>XYCTF{T3e_c0mb1nation_0f_crypt0_and_misc_1s_re6lly_fun!!L1u_and_K1cky_Mu_3re_so_sm4rt!In_just_a_few_m1nutes_they_were_thr0ugh!Sm3rt_y0u_can_do_nine_turns?}</p></blockquote><p>注意，第八段开头大写，然后要按词加下划线得到flag之后要整体用md5加密之后再包上XYCTF{}才是flag。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;你能突破九大关卡修成神仙吗？&lt;/p&gt;
&lt;p&gt;hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！&lt;/p&gt;
&lt;p&gt;h</summary>
      
    
    
    
    <category term="Write up" scheme="https://triodelzx.github.io/categories/Write-up/"/>
    
    
    <category term="Misc" scheme="https://triodelzx.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>PicoCTF2024 Crypto部分WP</title>
    <link href="https://triodelzx.github.io/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/"/>
    <id>https://triodelzx.github.io/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/</id>
    <published>2024-03-29T14:02:04.000Z</published>
    <updated>2024-03-29T14:11:27.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.</p><h2 id="interencdec"><a href="#interencdec" class="headerlink" title="interencdec"></a>interencdec</h2><p>签到题</p><p>密文如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YidkM0JxZGtwQlRYdHFhR3g2YUhsZmF6TnFlVGwzWVROclgyZzBOMm8yYXpZNWZRPT0nCg==</span><br></pre></td></tr></table></figure><p>显然是Base64编码，解码得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;d3BqdkpBTXtqaGx6aHlfazNqeTl3YTNrX2g0N2o2azY5fQ==&#x27;</span><br></pre></td></tr></table></figure><p>去除<strong>b’’</strong>之后进行Base64解码结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wpjvJAM&#123;jhlzhy_k3jy9wa3k_h47j6k69&#125;</span><br></pre></td></tr></table></figure><p>进行一次偏移量为7的凯撒解密可以得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;caesar_d3cr9pt3d_a47c6d69&#125;</span><br></pre></td></tr></table></figure><h2 id="Custom-encryption"><a href="#Custom-encryption" class="headerlink" title="Custom encryption"></a>Custom encryption</h2><p>题目给出加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">g, x, p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(g, x) % p<span class="comment">#实际上就是pow(g,x,p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    cipher = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> plaintext:</span><br><span class="line">        cipher.append(((<span class="built_in">ord</span>(char) * key*<span class="number">311</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">p</span>):</span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, p + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p % i == <span class="number">0</span>:</span><br><span class="line">            v = v + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_xor_encrypt</span>(<span class="params">plaintext, text_key</span>):</span><br><span class="line">    cipher_text = <span class="string">&quot;&quot;</span></span><br><span class="line">    key_length = <span class="built_in">len</span>(text_key)</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(plaintext[::-<span class="number">1</span>]):<span class="comment">#将字符串反转后异或加密</span></span><br><span class="line">        key_char = text_key[i % key_length]</span><br><span class="line">        encrypted_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="built_in">ord</span>(key_char))</span><br><span class="line">        cipher_text += encrypted_char</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">plain_text, text_key</span>):</span><br><span class="line">    p = <span class="number">97</span></span><br><span class="line">    g = <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_prime(p) <span class="keyword">and</span> <span class="keyword">not</span> is_prime(g):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enter prime numbers&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a = randint(p-<span class="number">10</span>, p)</span><br><span class="line">    b = randint(g-<span class="number">10</span>, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line">    u = generator(g, a, p)</span><br><span class="line">    v = generator(g, b, p)</span><br><span class="line">    key = generator(v, a, p)</span><br><span class="line">    b_key = generator(u, b, p)</span><br><span class="line">    shared_key = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> key == b_key:</span><br><span class="line">        shared_key = key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)</span><br><span class="line">    cipher = encrypt(semi_cipher, shared_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;cipher is: <span class="subst">&#123;cipher&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    test(message, <span class="string">&quot;trudeau&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目给出的另一个附件如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 89</span><br><span class="line">b = 27</span><br><span class="line">cipher is: [33588, 276168, 261240, 302292, 343344, 328416, 242580, 85836, 82104, 156744, 0, 309756, 78372, 18660, 253776, 0, 82104, 320952, 3732, 231384, 89568, 100764, 22392, 22392, 63444, 22392, 97032, 190332, 119424, 182868, 97032, 26124, 44784, 63444]</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析代码可以知道有一个<code>share_key</code>，把它求出来（很简单，不知道他为什么要把<code>pow(a,b,p)</code>包装成一个新的函数）然后通过<code>cipher</code>里面每一个元素除以<code>share_key</code>和311得到一个串，跟<code>text_key</code>进行一个异或（<code>dynamic_xor_encrypt</code>）再对得到的<code>plaintext</code>进行反转。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>先求<code>share_key</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br></pre></td></tr></table></figure><p>求出<code>share_key</code>之后就可以将<code>cipher</code>除以<code>share_key</code>和311得到一个串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = [x//shared_key//<span class="number">311</span> <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br></pre></td></tr></table></figure><p>将<code>temp</code>与<code>text_key</code>进行一个异或，其中<code>text_key=&quot;trudeau&quot;</code>得到一字符串后反转就可以得到flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>总体代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">97</span></span><br><span class="line">g = <span class="number">31</span></span><br><span class="line">a = <span class="number">89</span></span><br><span class="line">b = <span class="number">27</span></span><br><span class="line">cipher = [<span class="number">33588</span>, <span class="number">276168</span>, <span class="number">261240</span>, <span class="number">302292</span>, <span class="number">343344</span>, <span class="number">328416</span>, <span class="number">242580</span>, <span class="number">85836</span>, <span class="number">82104</span>, <span class="number">156744</span>, <span class="number">0</span>, <span class="number">309756</span>, <span class="number">78372</span>, <span class="number">18660</span>, <span class="number">253776</span>, <span class="number">0</span>, <span class="number">82104</span>, <span class="number">320952</span>, <span class="number">3732</span>, <span class="number">231384</span>, <span class="number">89568</span>, <span class="number">100764</span>, <span class="number">22392</span>, <span class="number">22392</span>, <span class="number">63444</span>, <span class="number">22392</span>, <span class="number">97032</span>, <span class="number">190332</span>, <span class="number">119424</span>, <span class="number">182868</span>, <span class="number">97032</span>, <span class="number">26124</span>, <span class="number">44784</span>, <span class="number">63444</span>]</span><br><span class="line"></span><br><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br><span class="line"></span><br><span class="line">temp = [<span class="built_in">chr</span>(x//shared_key//<span class="number">311</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;custom_d2cr0pt6d_dc499538&#125;</span><br></pre></td></tr></table></figure><h2 id="C3"><a href="#C3" class="headerlink" title="C3"></a>C3</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">  chars += line</span><br><span class="line"></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">  cur = lookup1.index(char)</span><br><span class="line">  out += lookup2[(cur - prev) % <span class="number">40</span>]</span><br><span class="line">  prev = cur</span><br><span class="line"></span><br><span class="line">sys.stdout.write(out)</span><br></pre></td></tr></table></figure><p>题目给出的另外一个附件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl</span><br></pre></td></tr></table></figure><p>可以知道附件是<code>chars</code>加密得到的，分析代码后写出解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br></pre></td></tr></table></figure><p>运行代码可得：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#asciiorder</span></span><br><span class="line"><span class="comment">#fortychars</span></span><br><span class="line"><span class="comment">#selfinput</span></span><br><span class="line"><span class="comment">#pythontwo</span></span><br><span class="line"></span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">    chars += line</span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span> chars[i] <span class="comment">#prints</span></span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>会发现解出来是一串缺少参数<code>chars</code>内容的代码，猜测这里的<code>chars</code>就是上面求解出来的<code>chars</code>，拼接上一条代码再进行修改后得到如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span>(chars[i],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行得到的字符串包裹上<code>picoCTF&#123;&#125;</code>即可得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;adlibs&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa-oracle"><a href="#rsa-oracle" class="headerlink" title="rsa_oracle"></a>rsa_oracle</h2><p>这道题考点较多，但是算是模板题，所以难度不算高.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先题目给了个预言机（Oracle），通过交互我们可以发现可以通过这个Oracle对一些东西进行加密或者解密，而文件中给出了一个password.enc文件，从题目描述中的“<strong>After some intensive reconassainance they found out that the bank has an oracle that was used to encrypt the password</strong>”可以知道password.enc里面的数据是通过Oracle中内置的RSA的参数进行加密的，但是我们并不能将password.enc的数据直接丢进Oracle里面得到password，故我们考虑使用选择密文攻击得到password。得到password之后，我们通过<strong>hint2：OpenSSL can be used to decrypt the message. e.g <code>openssl enc -aes-256-cbc -d ...</code></strong> （或者通过message.enc里面的格式）可以知道需要通过OpenSSL解密message.enc得到flag，而密码就是password.enc解密得到的。</p><h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><h4 id="第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数"><a href="#第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数" class="headerlink" title="第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数"></a>第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数</h4><p>由RSA的原理，我们可以得到以下式子：</p><script type="math/tex; mode=display">2^e\equiv c_2\pmod{n}\\4^e\equiv c_4\pmod{n}\\8^e\equiv c_8\pmod{n}</script><p>可得：</p><script type="math/tex; mode=display">c_2^2\equiv c_4\pmod{n}\\c_2^3\equiv c_8\pmod{n}</script><p>即：</p><script type="math/tex; mode=display">c_2^2-c_4=k_1n\\c_2^3-c_8=k_2n</script><p>在一般情况下，有$(c_2^2-c_4,c_2^3-c_8)=n$</p><p>自此，我们得到了$n$，现在要得到$e$，猜测$e$小于$100000$，使用上面求出的$c_2$（或者$c_4,c_8$）进行爆破，就得到了$e$。</p><p>该步代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;地址&quot;</span>,端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(2,e,n)</span></span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">2</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c2 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(4,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">4</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c4 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(8,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">8</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c8 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line">n = gmpy2.gcd(c2**<span class="number">2</span>-c4,c2**<span class="number">3</span>-c8)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">2</span>,e,n)==c2:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h4 id="第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）"><a href="#第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）" class="headerlink" title="第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）"></a>第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）</h4><p>由于不能直接解密password（后面将里面的数记为$c$），而从一般通过Oracle选择密文攻击的题目，我们可以知道他应该也不能解密$c+kn,k\in Z$，我们考虑通过解密$c*s^e\ mod\ n$来得到我们需要的东西。</p><p>解密之后可以得到$s$倍的$m$（这里$m$就是解密后的<code>password</code>），乘上$inv(s,n)$再模$n$（这里$inv(a,b)$表示$a$模$b$的乘法逆元）就可以还原出<code>password</code>了（需要<code>long_to_bytes</code>）</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(<span class="built_in">str</span>(c*<span class="built_in">pow</span>(<span class="number">2</span>,e,n)%n).encode())</span><br></pre></td></tr></table></figure><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>通过OpenSSL对message.enc通过<code>aes_256_cbc</code>算法进行解密，命令大致如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl enc <span class="literal">-aes-256-cbc</span> <span class="literal">-d</span> <span class="operator">-in</span> (这里是message.enc的路径) <span class="literal">-out</span> flag.txt <span class="literal">-k</span> (这里是password)</span><br></pre></td></tr></table></figure><p>就可以得到flag了.</p><h2 id="flag-printer"><a href="#flag-printer" class="headerlink" title="flag_printer"></a>flag_printer</h2><p>算法优化题，卡了好久，感觉这题不应该出现在Cryptography里面.</p><p>题目给出了一个30.8MB的文本文件，里面有1769611组数，还给出了一个python源码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> galois</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">MOD = <span class="number">7514777789</span></span><br><span class="line"></span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;encoded.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read().strip().split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    x, y = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    points.append((<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)))</span><br><span class="line"></span><br><span class="line">GF = galois.GF(MOD)</span><br><span class="line"></span><br><span class="line">matrix = []</span><br><span class="line">solution = []</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    x, y = point</span><br><span class="line">    solution.append(GF(y % MOD))</span><br><span class="line"></span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        row.append(GF(x**i%MOD))</span><br><span class="line"></span><br><span class="line">    matrix.append(GF(row))</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.bmp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="built_in">bytearray</span>(np.linalg.solve(GF(matrix), GF(solution)).tolist()[:-<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由代码可以知道我们需要求解如下方程：</p><script type="math/tex; mode=display">\left[\begin{matrix}x_0^0&x_0^1&x_0^2&\cdots&x_0^{n-1}\\x_1^0&x_1^1&x_1^2&\cdots&x_1^{n-1}\\x_2^0&x_2^1&x_2^2&\cdots&x_2^{n-1}\\\vdots&\vdots&\vdots&\ddots&\vdots\\x_{n-1}^0&x_{n-1}^1&x_{n-1}^2&\cdots&x_{n-1}^{n-1}\\\end{matrix}\right]\left[\begin{matrix}\alpha_0\\\alpha_1\\\alpha_2\\\vdots\\\alpha_{n-1}\end{matrix}\right]=\left[\begin{matrix}y_0\\y_1\\y_2\\\vdots\\y_{n-1}\end{matrix}\right]</script><p>可以看到，左式的$n\times n$矩阵是一个范德蒙德矩阵，所以优先考虑范德蒙德方程组求解，找到<strong>Björck-Pereyra算法</strong>，后面发现在Python中需要分配11.4TB的内存，并不能解决问题。</p><p>再观察矩阵可以发现对于任意$x_i(i=0,1,2,\cdots,n-1)$，有：$\alpha_0x_i^0+\alpha_1x_i^1+\alpha_2x_i^2+\cdots+\alpha_{n-1}x_i^{n-1}=y_i$</p><p>可以知道，这显然可以利用拉格朗日插值法，得到的函数应为：$f(x)=\alpha_0x^0+\alpha_1x^1+\alpha_2x^2+\cdots+\alpha_{n-1}x^{n-1}$</p><p>但是一般的拉格朗日插值法时间复杂度太高，不能达到我想要的效果（实际上如果是硬跑的话还是可以跑出flag的），故考虑FFT（快速傅里叶变换），但是可惜的是我对算法的学习不深，并不知道怎么写FFT.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;感想&quot;&gt;&lt;a href=&quot;#感想&quot; class=&quot;headerlink&quot; title=&quot;感想&quot;&gt;&lt;/a&gt;感想&lt;/h2&gt;&lt;p&gt;这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.&lt;/p</summary>
      
    
    
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>向量空间（Vector Space）学习笔记</title>
    <link href="https://triodelzx.github.io/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://triodelzx.github.io/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-24T15:26:39.000Z</published>
    <updated>2024-03-24T15:32:56.535Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期高等代数课程正在讲向量空间，所以想着结合一下高中对于向量空间的学习整理一下一些知识点和笔记。</p><p><strong>参考书籍：《高等代数（第五版）》（北京大学数学系前代数小组 编，高等教育出版社）（以下简称北大版），《高等代数（第五版）》（张禾瑞、郝鈵新 编，高等教育出版社）（以下简称北师大版）</strong></p><h2 id="向量空间的定义"><a href="#向量空间的定义" class="headerlink" title="向量空间的定义"></a>向量空间的定义</h2><p>设$V$是一个非空集合，$F$为一个数域.在集合$V$的元素之间定义一代数运算，称为<strong>加法</strong>，即给出一个法则，对于$V$中任意两个元素$\pmb{\alpha}$与$\pmb{\beta}$，在$V$中都有唯一的一个元素$\pmb{\gamma}$，称为$\pmb{\alpha}$与$\pmb{\beta}$的和，记为$\pmb{\gamma}=\pmb{\alpha}+\pmb{\beta}$，在数域$F$与集合$V$的元素之间还定义了一种运算，称为数量乘法，即对于数域$F$中任一数$k$与$V$中任意元素$\pmb{\alpha}$，在$V$中都有唯一的一个元素$\pmb{\delta}$与它们对应，称为$k$与$\pmb{\alpha}$的<strong>数量乘积</strong>（简称<strong>数乘</strong>），记为$\pmb{\delta}=k\pmb{\alpha}$.若加法与数乘满足下述规则，那么$V$称为数域$P$上的<strong>向量空间</strong>（或称<strong>线性空间</strong>）（向量空间或集合$V$中的元素用小写黑体希腊字母表示，数域中元素用小写拉丁字母表示）：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \pmb{\alpha}+\pmb{\beta}=\pmb{\beta}+\pmb{\alpha};\\&(2)\ (\pmb{\alpha}+\pmb{\beta})+\pmb{\gamma}=\pmb{\alpha}+(\pmb{\beta}+\pmb{\gamma});\\&(3)\ 在V中有一元素\pmb{0}，对于V中任一元素\pmb{\alpha} 都有\ \pmb{0}+\pmb{\alpha}=\pmb{\alpha}\\&(具有该性质的元素\pmb{0}称为V的零元素);\\&(4)\ 对于V中每一元素\pmb{\alpha} ,都有V中的元素\pmb{\beta},使得\ \pmb{\alpha}+\pmb{\beta}=0\\&(\pmb{\beta} 称为\pmb{\alpha} 的负元素);\\&(5)1\pmb{\alpha} = \pmb{\alpha};\\&(6)k(l\pmb{\alpha})=(kl)\pmb{\alpha}\ (k,l\in F,下同);\\&(7)(k+l)\pmb{\alpha} = k\pmb{\alpha}+l\pmb{\alpha};\\&(8)k(\pmb{\alpha}+\pmb{\beta})=k\pmb{\alpha}+k\pmb{\beta}.\end{flalign}</script><h2 id="向量空间的一些简单的性质"><a href="#向量空间的一些简单的性质" class="headerlink" title="向量空间的一些简单的性质"></a>向量空间的一些简单的性质</h2><p>1.零元素是唯一的.</p><p>2.负元素是唯一的.</p><p>3.$0\pmb{\alpha}=\pmb{0},k\pmb{0}=\pmb{0},(-1)\pmb{\alpha}=-\pmb{\alpha}$</p><p>4.若$k\pmb{\alpha}=\pmb{0}$，则有$k=0$或$\pmb{\alpha}=\pmb{0}$</p><h2 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h2><p><strong>子空间的定义：</strong>令$W$是数域$F$上向量空间$V$的一个非空子集.若$W$对于$V$的加法以及标量与向量的乘法来说是封闭的，那么就称$W$是$V$的一个<strong>子空间</strong>.</p><p><strong>定理1：</strong>数域$F$上向量空间$V$的一个非空子集$W$是$V$的一个子空间，当且仅当对于任意$a,b\in F,\pmb{\alpha}$及任意$\pmb{\beta}\in W$，都有$a\pmb{\alpha}+b\pmb{\beta}\in W$</p><h2 id="子空间的和与直和"><a href="#子空间的和与直和" class="headerlink" title="子空间的和与直和"></a>子空间的和与直和</h2><p><strong>子空间和的定义：</strong>设$W_1,W_2$为向量空间$V$的两个子空间.那么$W_1,W_2$的<strong>和</strong>是指由所有能表示为$\pmb{\alpha_1}+\pmb{\alpha_2}$，而$\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2$的向量组成的子集合，记作$V_1+V_2$.</p><p>在子空间的和中，有一种特殊的情形，被称为<strong>直和(direct sum)</strong>，定义如下：</p><p><strong>直和的定义：</strong>设设$W_1,W_2$为向量空间$V$的两个子空间，若和$W_1+W_2$中每个向量$\pmb{\alpha}$的分解式$\pmb{\alpha}=\pmb{\alpha_1}+\pmb{\alpha_2}\ (\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2)$是唯一的，则称这个和为<strong>直和</strong>，记为$V_1\oplus V_2$.</p><p><strong>余子空间的定义：</strong>设$W$为向量空间$V$的一个子空间，若对于$V$的一个子空间$W’$，满足$W\oplus W’=V$，则称$W’$是$W$的一个<strong>余子空间</strong>.</p><p>由定义我们可以知道：</p><p>（1）和$V_1+V_2$是直和的充分必要条件为等式$\pmb{\alpha_1}+\pmb{\alpha_2}=\pmb{0}$(其中$\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2)$只有在$\pmb{\alpha_1},\pmb{\alpha_2}$全为零向量时才成立；</p><p>（2）和$V_1+V_2$是直和的充分必要条件为$V_1\cap V_2=\{\pmb{0}\}$；</p><h2 id="向量的线性相关性、向量组的等价及向量组的极大线性无关组"><a href="#向量的线性相关性、向量组的等价及向量组的极大线性无关组" class="headerlink" title="向量的线性相关性、向量组的等价及向量组的极大线性无关组"></a>向量的线性相关性、向量组的等价及向量组的极大线性无关组</h2><p> <strong>线性组合的定义：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$是向量空间$V$的$r$个向量，$a_1,a_2,\cdots,a_r$是数域$F$中任意$r$个数.我们将和$\pmb{\alpha}=a_1\pmb{\alpha_1}+a_2\pmb{\alpha_2}+\cdots+a_r\pmb{\alpha_r}$称为向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$的一个<strong>线性组合</strong>，而称向量$\pmb{\alpha}$被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$<strong>线性表示</strong>.</p><p><strong>线性相关的定义：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$是向量空间$V$的$r$个向量，若存在$F$中不全为零的数$a_1,a_2,\cdots,a_r$，使得：$a_1\pmb{\alpha_1}+a_2\pmb{\alpha_2}+\cdots+a_r\pmb{\alpha_r}=\pmb{0}$，则称$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性相关.</p><p>若向量组不线性相关，则称它们<strong>线性无关</strong>.</p><p><strong>向量组等价的定义：</strong>设$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$和$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$是向量空间$V$的两个向量组. 若每一$\pmb{\alpha_i}$都可以由$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}$线性表示，而每一$\pmb{\beta_j}$也可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示，那么就说这两个向量组<strong>等价</strong>.</p><p><strong>极大线性无关组的定义：</strong>对于向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$的一个部分向量组$\{\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}\}$，若$\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}$线性无关且对于每一$\pmb{\alpha_j}\ (j=1\cdots,n)$都可以由$\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}$线性表示，则称部分向量组$\{\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}\}$为$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$的一个<strong>极大线性无关部分组</strong>（简称<strong>极大线性无关组</strong>）.</p><p>实际上，在解析几何中，我们已经接触过线性相关与线性无关的概念，在高等代数中，将“向量”这一概念泛化之后，我们可以知道：在向量空间$F\left[x\right]$（数域$F$中一元多项式环）中，对于任意非负整数$n$，有$1,x,x^2,\cdots,x^n$线性无关.</p><p>下面是几个有用的定理：</p><p><strong>定理2：</strong>若向量$\pmb{\gamma}$可以由$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_r}$线性表示，而每一$\pmb{\beta_i}$又可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示，那么$\pmb{\gamma}$可以被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示.</p><p><strong>定理3：</strong>若向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$线性无关，而向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta}\}$线性相关，则$\pmb{\beta}$可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示.</p><p><strong>定理4：</strong>向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}(r\ge2)$线性相关，当且仅当其中某一个向量是其余向量的线性组合.</p><p><strong>定理5（替换定理）：</strong>设向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$线性无关，并且每一$\pmb{\alpha_i}$都可以由向量组$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$线性表示.那么$r\le s$，且必要时可以对$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$中向量重新编号，使得用$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$替换$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_r}$后，所得的向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_{r+1}},\pmb{\beta_{r+2}},\cdots,\pmb{\beta_s}\}$与$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$等价.</p><p><strong>替换定理推论1：</strong>两个等价的线性无关的向量组含有相同个数的向量.</p><p><strong>替换定理推论2：</strong>等价的向量组的极大无关组含有相同个数的向量，特别的，一个向量组的任意两个极大无关组含有相同个数的向量.</p><p>下面是一个求$F^n$中列向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$的一个极大线性无关组的方法：</p><p>（1）首先将列向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$拼接为一个矩阵$\pmb{A}=\left(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\right)$，</p><p>（2）将其化为行最简形式，并得出矩阵$\pmb{A}$的秩$r(\pmb{A})$，</p><p>（3）从中挑选非零数最少的$r(\pmb{A})$个列向量（一般只有一个元素是$1$而其余是$0$），这些变换后的列向量对应的原向量组成的向量组即为向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$的一个极大线性无关组.</p><p>举个例子：</p><p>已知向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\}$，其中$\pmb{\alpha_1}=(1,1,2,3)^T,\pmb{\alpha_2}=(-1,-1,1,1)^T,\pmb{\alpha_3}=(1,3,3,5)^T,\pmb{\alpha_4}=(4,-2,5,6)^T, \pmb{\alpha_5}=(-3,-1,-5,-7)$，求这个向量组的一个极大线性无关组.</p><script type="math/tex; mode=display">\begin{flalign}解:&将这5个向量拼接为一个矩阵如下:\\&\left(\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\right)=\left(\begin{matrix}1&-1&1&4&-3\\1&-1&3&-2&-1\\2&1&3&5&-5\\3&1&5&6&-7\end{matrix}\right)→\left(\begin{matrix}1&0&0&7&-4\\0&1&0&0&0\\0&0&1&-3&1\\0&0&0&0&0\end{matrix}\right)\\&取第1，2，3列向量对应的原向量即\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3}，可得到向量组\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\}的一个极大线性无关组为\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3}\}.\end{flalign}</script><h2 id="基和维数"><a href="#基和维数" class="headerlink" title="基和维数"></a>基和维数</h2><p><strong>生成元和生成子空间的定义：</strong>设$V$为数域$F$上一个向量空间，$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\in V$，由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$的一切线性组合所成的集合显然是$V$的一个子空间，称这个子空间为<strong>由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$所生成的子空间</strong>，并用符号$\mathscr{L}(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n})$表示.向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$叫做这个子空间的一组<strong>生成元</strong>.</p><p><strong>基的定义：</strong>设$V$是数域$F$上一个向量空间.对于$V$中一向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$，若$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$线性无关且$V$中的每一向量都可以被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$线性表示，则称向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$为$V$的一个<strong>基</strong>.</p><p>根据定义，我们很容易可以知道向量空间$V$的一个基就是$V$的一组线性无关的生成元.</p><p>而对数域$F^n$中的$n$个向量：$\pmb{\varepsilon_i}=(0,\cdots,0,1,0,\cdots,0)$，这里$\pmb{\varepsilon_i}$除第$i$为$1$外，其余位置元素均为零，显然向量组$\{\pmb{\varepsilon_1},\pmb{\varepsilon_2},\cdots,\pmb{\varepsilon_n}\}$是$F^n$的一个基，这个基称为$F^n$的<strong>标准基</strong>（或称<strong>标准正交基</strong>）.</p><p><strong>维的定义：</strong>一个向量空间$V$的基所含向量个数称为$V$的<strong>维数</strong>，记作$\dim V$，特别的，我们定义<strong>零空间</strong>的维数为$0$.</p><p>几个常见向量空间的维数：</p><p>（1）$F^n$的维数为$n$；</p><p>（2）$F$上一切$m×n$的矩阵所成的向量空间的维数为$mn$；</p><p>（3）$F[x]$是无限维的.</p><p>下面是关于基和维数的几个定理：</p><p><strong>定理6：</strong>设$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$是向量空间$V$的一个基.那么$V$中的每一个向量可以<strong>唯一</strong>地被表成基向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$的线性组合.</p><p><strong>定理7：</strong>$n$维向量空间中任意多于$n$个向量一定线性相关.</p><p><strong>定理8：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\in V$为$n$维向量空间$V$中一组线性无关向量.那么总可以添加$n-r$个向量$\pmb{\alpha_{r+1}},\cdots,\pmb{\alpha_n}$使得$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\alpha_{r+1}},\cdots,\pmb{\alpha_n}\}$作成$V$的一组基.特别的，$n$维向量空间中任意$n$个线性无关的向量都可以取作基.</p><p><strong>定理9（维数定理）：</strong>设$W_1$和$W_2$都是数域$F$上向量空间$V$的有限维子空间.那么$W_1+W_2$也是有限维的，且</p><script type="math/tex; mode=display">\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)</script><p>对于向量空间$V_1,V_2$，$V_1+V_2$的基即为$V_1,V_2$的生成元构成的向量组的一个极大线性无关组.</p><p>在对$n$维列向量组成的向量空间$W_1,W_2$使用维数定理时，我们常常需要求$W_1+W_2$与$W_1\cap W_2$，下面是求它们的方法：</p><p>设$W_1=\mathscr{L}(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}),W_2=\mathscr{L}(\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})$</p><p>（1）将$W_1,W_2$的生成元拼接为矩阵</p><script type="math/tex; mode=display">\pmb{A}=(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})</script><p>（2）求出向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$的一个极大线性无关组，设为$\{\pmb{\gamma_1},\pmb{\gamma_2},\cdots,\pmb{\gamma_t}\}$，则$W_1+W_2=\mathscr{L}(\pmb{\gamma_1},\pmb{\gamma_2},\cdots,\pmb{\gamma_t})$，且$\dim (W_1+W_2)=t$</p><p>（3）求出矩阵$(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})$所表示的齐次线性方程组的<strong>基础解系</strong>$\{\pmb{\delta_1},\pmb{\delta_2},\cdots,\pmb{\delta_u}\}$，那么我们可以得到$W_1\cap W_2=\mathscr{L}(\pmb{\delta_1},\pmb{\delta_2},\cdots,\pmb{\delta_u})$，且有$\dim (W_1\cap W_2)=u$.</p><p>（基础解系相关定义将会在后面给出）</p><p>显然有$t=r(\pmb{A}),\dim W_1=r,\dim W_1=s$，而由基础解系的概念，显然有$u=(r+s)-t$，所以可以得到$\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)$.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于近期高等代数课程正在讲向量空间，所以想着结合一下高中对于向量空间的学习整理一下一些知识点和笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考书籍：《高等代数（第五版）》（北京大学数学系前代数小组 编，高等教育出版社）（以下简称北大版），《高等代数（第五版）》（张禾瑞、郝鈵新 编</summary>
      
    
    
    
    
    <category term="高等代数笔记" scheme="https://triodelzx.github.io/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>连分数（Continued Fractions）笔记</title>
    <link href="https://triodelzx.github.io/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
    <id>https://triodelzx.github.io/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-09T04:23:07.000Z</published>
    <updated>2024-03-19T06:19:57.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）</em></p></blockquote><h2 id="连分数的定义"><a href="#连分数的定义" class="headerlink" title="连分数的定义"></a>连分数的定义</h2><p>形如：</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+\frac{1}{\begin{matrix}a_3+\\&&\ddots\\&&&&+\frac{1}{a_n}\end{matrix}}}\tag{1}</script><p>的分数被称作连分数。</p><p>在平常的使用中，为了节省篇幅，我们一般使用以下符号来表示上述连分数：</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+}\frac{1}{a_3+}\frac{1}{a_4+}\cdots\frac{1}{a_n}或[a_1,a_2,\cdots ,a_n]</script><p>其中第二种表示方式最常用。</p><h2 id="有关连分数的一些定理-amp-定义"><a href="#有关连分数的一些定理-amp-定义" class="headerlink" title="有关连分数的一些定理&amp;定义"></a>有关连分数的一些定理&amp;定义</h2><h3 id="定义1（连分数的渐进分数）："><a href="#定义1（连分数的渐进分数）：" class="headerlink" title="定义1（连分数的渐进分数）："></a>定义1（连分数的渐进分数）：</h3><p>$[a_1,a_2,\cdots ,a_k]=\frac{p_k}{q_k}\ (1\le k\le n)$叫做连分数$(1)$的第$k$个<strong>渐进分数</strong></p><h3 id="定义2（简单连分数）："><a href="#定义2（简单连分数）：" class="headerlink" title="定义2（简单连分数）："></a>定义2（简单连分数）：</h3><p>若$a_1$是整数，$a_2,a_3,\cdots,a_k,\cdots$是正整数，则连分数</p><script type="math/tex; mode=display">[a_1,a_2,\cdots,a_k,\cdots]</script><p>称为<strong>简单连分数</strong>，若$a$的个数有限，则称为<strong>有限简单连分数</strong>，若$a$的个数无限，则称为<strong>无限简单连分数</strong>.</p><p>对于无限连分数，若当$k→∞$时$[a_1,a_2,\cdots,a_n,\cdots]$的渐进分数$\frac{p_k}{q_k}$存在极限，则称这个极限为<strong>连分数$[a_1,a_2,\cdots,a_n,\cdots]$的值.</strong></p><h3 id="定义3（循环连分数）："><a href="#定义3（循环连分数）：" class="headerlink" title="定义3（循环连分数）："></a>定义3（循环连分数）：</h3><p>对于一个无限连分数$[a_1,a_2,\cdots,a_n,\cdots]$，如果能找到两个整数$s\ge0,t&gt;0$使得</p><script type="math/tex; mode=display">a_{s+i}=a_{s+kt+i},\ \ \ i=1,2,\cdots,t;\ \ \ \ k=0,1,2,\cdots</script><p>这个无限简单连分数就叫<strong>循环连分数</strong>，并简单地把它记作</p><script type="math/tex; mode=display">[a_1,a_2, \cdots ,a_s,a_{s+1},\cdots ,a_{s+t}]</script><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a>定理1：</h3><p>若连分数$[a_1,a_2,\cdots ,a_n]$的渐进分数是$\frac{p_1}{q_1},\frac{p_2}{q_2},\cdots ,\frac{p_n}{q_n}$，则在这些渐进分数之间，下列关系成立：</p><script type="math/tex; mode=display">\begin{matrix}p_1=a_1,p_2=a_2a_1+1&p_k=a_kp_{k-1}+p_{k-2},\\ q_1=1,q_2=a_2\ \ \ \ \ \ \ \ \ \ \ \ \ &q_k=a_kq_{k-1}+q_{k-2},\end{matrix}\cdots,\ \ \ 3\le k\le n</script><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a>定理2：</h3><p>若连分数$[a_1,a_2,\cdots ,a_n]$的$n$个渐进连分数是$\frac{p_k}{q_k},k=1,2,\cdots,n$，则下列两关系成立：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \ p_kq_{k-1}-p_{k-1}q_k=(-1)^k,\ \ \ \ \ \ \ \ \ \ k\ge 2\\ &(2)\ \ p_kq_{k-2}-p_{k-2}q_k=(-1)^{k-1}a_k,\ \ k\ge3\end{flalign}</script><h3 id="定理3："><a href="#定理3：" class="headerlink" title="定理3："></a>定理3：</h3><p>设$[a_1,a_2,\cdots,a_n,\cdots]$是简单连分数，$\frac{p_k}{q_k}(k=1,2,\cdots)$是它的渐进分数，则：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \ 当k\ge 3时，q_k\ge q_{k-1}+1，因而对任何k来说,q_k\ge k-1\\ &(2)\ \ \frac{p_{2(k-1)}}{q_{2(k-1)}}>\frac{p_{2k}}{q_{2k}},\frac{p_{2k-1}}{q_{2k-1}}>\frac{p_{2k-3}}{q_{2k-3}},\frac{p_{2k}}{q_{2k}}>\frac{p_{2k-1}}{q_{2k-1}}\\ &(3)\frac{p_k}{q_k}(k=1,2,\cdots)都是既约分数\end{flalign}</script><h3 id="定理4："><a href="#定理4：" class="headerlink" title="定理4："></a>定理4：</h3><p>每一简单连分数表示一个实数.</p><h3 id="定理5："><a href="#定理5：" class="headerlink" title="定理5："></a>定理5：</h3><p>任一实无理数可以表成无限简单连分数.</p><h4 id="定理5的推论："><a href="#定理5的推论：" class="headerlink" title="定理5的推论："></a>定理5的推论：</h4><p>对于实无理数$\alpha$，有</p><script type="math/tex; mode=display">\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta_k}{q_kq_{k+1}}或\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta'_k}{q_k^2},其中0<\delta_k<1,0<\delta'_k<1</script><h3 id="定理6："><a href="#定理6：" class="headerlink" title="定理6："></a>定理6：</h3><p>每一实无理数只有一种唯一的方法表成无限简单连分数.</p><h3 id="定理7："><a href="#定理7：" class="headerlink" title="定理7："></a>定理7：</h3><script type="math/tex; mode=display">\begin{flalign}&(1)若\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[b_1,b_2,\cdots,b_n],且a_n>1,b_m>1，则m=n,a_i=b_i\ \ (i=1,2,\cdots,n)\\ &(2)任一有理数\frac{a}{b}有且仅有两种方法表成简单连分数，即\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[a_1,a_2,\cdots,a_n-1,1]\end{flalign}</script><h3 id="定理8："><a href="#定理8：" class="headerlink" title="定理8："></a>定理8：</h3><p>若$\alpha$是任一实数，$\frac{p_k}{q_k}$是$\alpha$的第$k$个渐进分数，则在分母小于等于$q_k$的一切有理数中，$\frac{p_k}{q_k}$是$\alpha$最好的有理近似值，即若$0&lt;q\le q_k$，则</p><script type="math/tex; mode=display">|{\alpha-\frac{p_k}{q_k}}|\le|{\alpha-\frac{p}{q}}|</script><h3 id="定理9："><a href="#定理9：" class="headerlink" title="定理9："></a>定理9：</h3><p>每一循环连分数一定是某一整系数二次不可约方程的实根.</p><h3 id="定理10："><a href="#定理10：" class="headerlink" title="定理10："></a>定理10：</h3><p>若$f(x)=ax^2+bx+c$是一个整系数二次不可约多项式，$\alpha$是$f(x)=0$的一个实根，则表示$\alpha$的简单连分数是一循环连分数.</p><h3 id="定理11（Legendre定理）："><a href="#定理11（Legendre定理）：" class="headerlink" title="定理11（Legendre定理）："></a>定理11（Legendre定理）：</h3><p>对于有理数$\alpha$，若整数$c,d$满足</p><script type="math/tex; mode=display">|{\alpha-\frac{c}{d}}|<\frac{1}{2d^2}</script><p>那么$\frac{c}{d}$就是$\alpha$的一个有理近似.</p><h2 id="连分数的应用实例"><a href="#连分数的应用实例" class="headerlink" title="连分数的应用实例"></a>连分数的应用实例</h2><h3 id="佩尔方程-Pell-equation"><a href="#佩尔方程-Pell-equation" class="headerlink" title="佩尔方程(Pell equation)"></a>佩尔方程(Pell equation)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>形如$x^2-dy^2=1$的不定方程被称为<strong>佩尔方程</strong></p><p>现求佩尔方程有正整数解的条件：</p><p>在实数域对方程$x^2-dy^2=1$进行分解有$(x+\sqrt{d}y)(x-\sqrt{d}y)=1$</p><p>(1)当$d$为完全平方数</p><p>则有$x+\sqrt{d}y,x-\sqrt{d}y$均为整数，那么若$(x+\sqrt{d}y)(x-\sqrt{d}y)=1$，则必有$x+\sqrt{d}y=x-\sqrt{d}y=1$</p><p>而满足这种情况的非负整数对$(x,y)=(1,0)$所以方程$x^2-dy^2=1$并不存在正整数解.</p><p>(2)当$d$为非完全平方数</p><h3 id="定理12："><a href="#定理12：" class="headerlink" title="定理12："></a>定理12：</h3><p>对任何正整数$n$，都存在两个整数$P_n,Q_n$，使得</p><script type="math/tex; mode=display">\alpha_n=\frac{\sqrt{d}+P_n}{Q_n},且P_n^2\equiv d\ (mod\ Q_n)</script><p>成立.</p><h3 id="定理13："><a href="#定理13：" class="headerlink" title="定理13："></a>定理13：</h3><p>若$d$是一个非平方的正整数，$Q_n$为<strong>定理12</strong>中所定义，则二次不定方程$x^2-dy^2=(-1)^nQ_n$有正整数解$x,y$且$(x,y)=1$.</p><h3 id="定理14："><a href="#定理14：" class="headerlink" title="定理14："></a>定理14：</h3><p>若有$\sqrt{d}=[a_1,a_2, \cdots ,a_s,a_{s+1}, \cdots ,a_{s+t}],n&gt;s$而$Q_n$为<strong>定理12</strong>所定义，则方程$x^2-dy^2=(-1)^nQ_n$有无穷多个正整数解 $|{p_{m+lt}}|,q_n+lt,2\ |\ l,l\ge0$ .（其中 $\frac {p_{m+lt}}{q_{m+lt}}$ 为 $\sqrt {d}$ 的第 $m+lt$ 个渐进分数）.</p><p>由<strong>定理14</strong>可知存在一正整数$Q$（取$Q=(-1)^nQ_n,n&gt;s$）使得不定方程$x^2-dy^2=Q$有无穷多组正整数解，则在这些解中必存在两组不同的正整数$x_1y_1;x_2y_2$使得</p><script type="math/tex; mode=display">x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)</script><p>成立.由于$x^2_1-dy^2_1=x^2_2-dy^2_2=Q$，故有</p><script type="math/tex; mode=display">Q^2=(x_1^2-dy_1^2)(x_2^2-dy_2^2)=(x_1x_2-dy_1y_2)^2-d(x_1y_2-x_2y_1)^2</script><p>由$x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)$可得：</p><script type="math/tex; mode=display">x_1x_2-dy_1y_2\equiv x_1^2-dy_1^2\equiv 0\ (mod\ |{Q}|),\\ x_1y_2-x_2y_1\equiv x_1y_1-x_1y_1\equiv 0\ (mod\ |{Q}|)</script><p>故若令$|{\frac{x_1x_2-dy_1y_2}{Q}}|=x,|{\frac{x_1y_2-x_2y_1}{Q}}|=y$，可知$x,y$均为非负整数且为方程$x^2-dy^2=1$的一解.</p><p>显然有$x\neq0$，否则有$-dy^{2}=1$，与$d&gt;0$矛盾；且有$y\neq0$否则有$x_1y_2-x_2y_1=0$，由引理2知$(x_1,y_1)=(x_2,y_2)=1$，所以有$x_1\ |\ x_2,x_2\ |\ x_1$，由于$x_1,x_2$均为正整数，所以有$x_1=x_2,y_1=y_2$，与$x_1,y_1;x_2;y_n$不同的定义相悖.故可知$x,y$为方程$x^2-dy^2=1$的一组正整数解.</p><p>综上所述，当$d$为完全平方数时，不定方程$x^2-dy^2=1$有正整数解.</p><h4 id="现在求不定方程-x-2-dy-2-1-的正整数解："><a href="#现在求不定方程-x-2-dy-2-1-的正整数解：" class="headerlink" title="现在求不定方程$x^2-dy^2=1$的正整数解："></a>现在求不定方程$x^2-dy^2=1$的正整数解：</h4><h3 id="定理15："><a href="#定理15：" class="headerlink" title="定理15："></a>定理15：</h3><p>若$x_0,y_0$是方程$x^2-dy^2=1$的一组正整数解，且$x_0+\sqrt{d}y_0$是形如$x+\sqrt{d}y$（$x,y$是方程$x^2-dy^2=1$的正整数解）的最小数，则方程$x^2-dy^2=1$的一切正整数解$x,y$可以由</p><script type="math/tex; mode=display">x\pm\sqrt{d}y=\big(x_0+\sqrt{d}y_0\big)^n,n=1,2,\cdots</script><p>确定.</p><p>有了<strong>定理15</strong>，我们可以通过一个佩尔方程的最小正整数解求出这个佩尔方程的所有解.现在我们的目标就成为找到如何求佩尔方程的最小正整数解.</p><p> 实际上，对于不为完全平方数的$\sqrt{d}=[a_1,a_2,\cdots,a_n,\cdots]$我们总能找到$a_{n+1}$满足$a_i=2a_1(i=2,3,\cdots,n)$，则$\frac{x}{y}=[a_1,a_2,\cdots,a_{n}]$可能为$d$定义的佩尔方程的一组解.</p><p>求佩尔方程最小整数解的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line">d = ...</span><br><span class="line">cf = continued_fraction(sqrt(d))</span><br><span class="line">a0 = cf[<span class="number">0</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> cf[i] == <span class="number">2</span>*a0:</span><br><span class="line">        c = cf.convergent(i-<span class="number">1</span>)</span><br><span class="line">        x, y = c.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> - d*y**<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>((x,y))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这里扩展地提一下广义佩尔方程：</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>形如$x^2-dy^2=c$的方程称为广义佩尔方程.</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>通过连分数求出广义佩尔方程的最小正整数解$(x_0,y_0)$后，可以知道$(x_0r+Dy_0s,x_0s+y_0r)$也是该方程的整数解（其中$r,s$为方程$r^2-ds^2=1$的整数解）</p><h4 id="求解代码"><a href="#求解代码" class="headerlink" title="求解代码"></a>求解代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell_roots</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    intervals = <span class="number">2</span>**<span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_a_root</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span></span>):</span><br><span class="line">        cf = continued_fraction(sqrt(D))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            c = cf.convergent(i - <span class="number">1</span>)</span><br><span class="line">            x, y = c.as_integer_ratio()</span><br><span class="line">            <span class="keyword">if</span> x**<span class="number">2</span> - D * y**<span class="number">2</span> == C:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            x2 = C + D * y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x2 &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x = isqrt(x2)</span><br><span class="line">            <span class="keyword">if</span> x ** <span class="number">2</span> == x2:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    r, s = get_a_root(D, <span class="number">1</span>)</span><br><span class="line">    x, y = get_a_root(D, C)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x, y</span><br><span class="line">        x, y = x * r + D * y * s, r * y + s * x</span><br><span class="line">D = ...</span><br><span class="line">C = ...</span><br><span class="line">x, y = <span class="built_in">next</span>(pell_roots(D, C))</span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span> - D * y**<span class="number">2</span> == C)</span><br><span class="line"><span class="built_in">print</span>((x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RSA的维纳攻击"><a href="#RSA的维纳攻击" class="headerlink" title="RSA的维纳攻击"></a>RSA的维纳攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>考虑一般的RSA，$c\equiv m^e\ (mod\ n),n=pq$，$p,q$均为质数，在这里$e$非常大，这也是适用维纳攻击的RSA的明显特征，有$\varphi(n)=(p-1)(q-1)$，则有</p><script type="math/tex; mode=display">\varphi(n)=(p-1)(q-1)=pq-p-q+1=N-p-\frac{n}{p}+1</script><p>故有$p^2+p\big[\varphi(n)-n-1\big]+n=0$</p><p>故若我们已知$n$和$\varphi(n)$，我们就可以对$n$进行分解.</p><p>又由于在RSA中，有$ed\equiv1\ (mod\ \varphi(n))$，所以存在整数$k$使得$ed=k\varphi(n)+1$</p><p>即有</p><script type="math/tex; mode=display">|{\frac{e}{\varphi(n)}-\frac{k}{d}}|=\frac{1}{d\varphi(n)}</script><p>由<strong>定理11（Legendre定理）</strong>可知：$\frac{k}{d}$是$\frac{e}{\varphi(n)}$的一个有理近似，故我们可以通过$\frac{e}{\varphi(n)}$的有理近似获得$\frac{k}{d}$，当$n=pq$且$q&lt;p&lt;2q$时，若满足$d&lt;\frac{1}{3}n^\frac{1}{4}$，则$\frac{k}{d}$为$\frac{e}{n}$的一个有理近似.</p><h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4><p>(1)估测是否满足$d&lt;\frac{1}{3}n^\frac{1}{4}$</p><p>(2)求$\frac{e}{n}$的连分数展开</p><p>(3)迭代连分数$\frac{k_i}{d_i}$：先使用$k_i,d_i$求出$\varphi_i(n)$，再通过$\varphi_i(n)$计算出$n$，验证$\varphi_i(n)$是否正确</p><h4 id="解密脚本："><a href="#解密脚本：" class="headerlink" title="解密脚本："></a>解密脚本：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">n, e</span>):</span><br><span class="line">    cf = continued_fraction(e / n)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pkd <span class="keyword">in</span> convers:</span><br><span class="line">        pk, pd = pkd.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> pk == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * pd - <span class="number">1</span>) % pk != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pphi = (e * pd - <span class="number">1</span>) // pk</span><br><span class="line">        p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">        roots = solve(p ** <span class="number">2</span> + (pphi - n - <span class="number">1</span>) * p + n, p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">            pp, pq = roots</span><br><span class="line">            <span class="keyword">if</span> pp * pq == n:</span><br><span class="line">                <span class="keyword">return</span> pp, pq, pd</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">n = ...</span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line">p, q, d = wienerAttack(n, e)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;连分数的定义&quot;&gt;&lt;a href=&quot;#连分数的定义&quot; class=&quot;headerlink&quot; title=&quot;连分数的定义&quot;&gt;</summary>
      
    
    
    
    <category term="数论笔记" scheme="https://triodelzx.github.io/categories/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
    <category term="数学" scheme="https://triodelzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LCG笔记</title>
    <link href="https://triodelzx.github.io/2023/12/17/LCG%E7%AC%94%E8%AE%B0/"/>
    <id>https://triodelzx.github.io/2023/12/17/LCG%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-17T14:13:59.000Z</published>
    <updated>2023-12-17T14:44:56.723Z</updated>
    
    <content type="html"><![CDATA[<p>LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义：</p><script type="math/tex; mode=display">X_{n+1}\equiv aX_n+b\ (mod\ p)</script><p>在CTF中，一般有以下题型：</p><h2 id="一-求逆"><a href="#一-求逆" class="headerlink" title="一.求逆"></a>一.求逆</h2><p>所谓求逆，其实即为已知a,b,p,c后求解方程：</p><script type="math/tex; mode=display">c\equiv(ax+b)\ (mod\ p)</script><p>由数论知识我们很容易可以知道：</p><script type="math/tex; mode=display">x\equiv(c-b)a^{-1}\ (mod\ p)</script><p>对于这类题目，我们只需利用以上公式即可快速解出。</p><h2 id="二-求参数a-b后求逆"><a href="#二-求参数a-b后求逆" class="headerlink" title="二.求参数a,b后求逆"></a>二.求参数a,b后求逆</h2><p>这类题型一般都会给出一列连续经过几次线性同余的数据后得出的数据和p，我们需要通过这些有限的数据来求解原来的数据，在此之前我们需要先求解a和b，大致过程如下：</p><p>假设已知<script type="math/tex">x_{n},x_{n+1},x_{n+2}</script>，我们有：</p><script type="math/tex; mode=display">x_{n+1}\equiv ax_n+b\ (mod\ p)\\ x_{n+2}\equiv ax_{n+1}+b\ (mod\ p)</script><p>所以我们有：</p><script type="math/tex; mode=display">x_{n+2}-x_{n+1}\equiv a(x_{n+1}-x_n)\ (mod\ p)</script><p>所以：</p><script type="math/tex; mode=display">a\equiv (x_{n+2}-x_{n+1})(x_{n+1}-x_n)^{-1}\ (mod\ p)(假定(x_{n+1}-x_n)与p互质)</script><p>那么我们有：</p><script type="math/tex; mode=display">b\equiv x_{n+1}-ax_n\ (mod\ p)</script><p>这样我们就可以得到a,b，再通过求逆得出原来的数据即可。</p><h3 id="例：-Newstar-CTF2023-Week3-babyrandom"><a href="#例：-Newstar-CTF2023-Week3-babyrandom" class="headerlink" title="例：[Newstar  CTF2023]Week3    babyrandom"></a>例：[Newstar  CTF2023]Week3    babyrandom</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line"></span><br><span class="line">a = randrange(<span class="number">2</span>, p)</span><br><span class="line">b = randrange(<span class="number">2</span>, p)</span><br><span class="line">x = bytes_to_long(flag)</span><br><span class="line">menu = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Random as a Service with LCG backend</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter your option</span></span><br><span class="line"><span class="string">1. Reset</span></span><br><span class="line"><span class="string">2. Get</span></span><br><span class="line"><span class="string">3. Exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetRandom</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    nx = (a*x + b) % p</span><br><span class="line">    <span class="built_in">print</span>(nx)</span><br><span class="line">    x = nx</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(menu)</span><br><span class="line">    opt = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opt = <span class="built_in">int</span>(opt)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="number">1</span>:</span><br><span class="line">            x = bytes_to_long(flag)</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">2</span>:</span><br><span class="line">            GetRandom()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;invalid option&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oh no, something wrong!&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这道题提供了靶机，可以通过靶机得出三个连续加密后数据，解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = []</span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line">io = pwn.remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25624</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    data = io.recvline()</span><br><span class="line">    io.recv()</span><br><span class="line">    x.append(<span class="built_in">int</span>(data))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">x = (x[<span class="number">0</span>]-b)*gmpy2.invert(a,p)%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><blockquote><p>flag{lcg_1s_n0t_s3cur3#fb528ba5}</p></blockquote><h2 id="三-求参数a-b-p后求逆"><a href="#三-求参数a-b-p后求逆" class="headerlink" title="三.求参数a,b,p后求逆"></a>三.求参数a,b,p后求逆</h2><p>与上一种形式相似，但是多了个p要求，我们假设一个数列：</p><script type="math/tex; mode=display">\{x_0,x_1,x_2,\cdots,x_{n-1},x_{n},\cdots\}</script><p>其满足：</p><script type="math/tex; mode=display">x_{n+1}\equiv ax_n+b\ (mod\ p)</script><p>假设有一个数列 <script type="math/tex">\{t_n\}</script> 有：</p><script type="math/tex; mode=display">t_n\equiv x_{n+1}-x_n\equiv a(x_n-x_{n-1})\equiv at_{n-1}\ (mod\ p)</script><p>所以：</p><script type="math/tex; mode=display">t_{n+1}t_{n-1}\equiv a^{2}t_{n-1}^2\equiv t_n^2\ (mod\ p)</script><p>也就是说：</p><script type="math/tex; mode=display">t_{n+1}t_{n-1}-t_n^{2}=kp\ (k\in Z)</script><p>同理，有：</p><script type="math/tex; mode=display">t_{n+2}t_{n}-t_{n+1}^{2}=k'p\ (k'\in Z)</script><p>所以：</p><script type="math/tex; mode=display">p=gcd(t_{n+2}t_{n}-t_{n+1}^{2},t_{n+1}t_{n-1}-t_n^{2})</script><p>求出p后我们就可以由上种类型继续求解。</p><p>但是要注意，上面求出的p不一定就是实际要求的p，所以需要综合多组数据求解。</p><h3 id="例：-PCTF2023-cgl"><a href="#例：-PCTF2023-cgl" class="headerlink" title="例：[PCTF2023]cgl"></a>例：[PCTF2023]cgl</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag,hint,key_number</span><br><span class="line"></span><br><span class="line">hint=bytes_to_long(hint)</span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">256</span>)</span><br><span class="line">b = getPrime(<span class="number">256</span>)</span><br><span class="line">n = getPrime(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">state = hint</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    state = (state * a + b) % n</span><br><span class="line">    result.append(state)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc=<span class="built_in">list</span>(base64.b64encode(flag))</span><br><span class="line">seed(key_number)</span><br><span class="line">shuffle(enc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(enc))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[64808739969023370119048821688797617211776674130654821075486774236651303382814, </span></span><br><span class="line"><span class="string">79259085906502785899793009961165414442137337544515472474317826031734962148580, </span></span><br><span class="line"><span class="string">47572752582229256276978761367590954300620113464013293239765792280017260371290, </span></span><br><span class="line"><span class="string">38491979589561565391093783861378040494484383004914878495301417593240442882761, </span></span><br><span class="line"><span class="string">58955289126482266943455593731576872529828229203595014577711629479455475819111]</span></span><br><span class="line"><span class="string">b&#x27;QkiTMMx3St9IYTLMN2DmR0t53zd1MhmJT1hZ2YiwMZETVhwhOGYVZYcD&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题很明显要通过上述方法来求解hint，在这里我们只求解hint，求解代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = [<span class="number">64808739969023370119048821688797617211776674130654821075486774236651303382814</span>, </span><br><span class="line"><span class="number">79259085906502785899793009961165414442137337544515472474317826031734962148580</span>, </span><br><span class="line"><span class="number">47572752582229256276978761367590954300620113464013293239765792280017260371290</span>, </span><br><span class="line"><span class="number">38491979589561565391093783861378040494484383004914878495301417593240442882761</span>, </span><br><span class="line"><span class="number">58955289126482266943455593731576872529828229203595014577711629479455475819111</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.append(x[i+<span class="number">1</span>]-x[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    p = gmpy2.gcd(t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>],t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i])</span><br><span class="line">    a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">    b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">    x = (x[<span class="number">0</span>] - b) * gmpy2.invert(a, p) % p</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可以得出hint：</p><blockquote><p>key_number=randrange(999999)</p></blockquote><p>要注意的是：在这种情况下，<script type="math/tex">\{x_n\}</script>的元素数量应该至少要有5个才能求解出p。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
X_{n+1}&#92;equiv aX_n+b&#92; (m</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Anshel–Anshel–Goldfeld 密钥交换体系(Anshel–Anshel–Goldfeld key exchange)</title>
    <link href="https://triodelzx.github.io/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/"/>
    <id>https://triodelzx.github.io/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/</id>
    <published>2023-12-15T12:50:27.000Z</published>
    <updated>2024-09-28T15:32:58.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）"><a href="#原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）" class="headerlink" title="原理（代数密钥建立协议，The algebraic key establishment protocol）"></a>原理（代数密钥建立协议，The algebraic key establishment protocol）</h3><p>​    We now present an algebraic key establishment protocol which, in its most general form consists of a five–tuple </p><script type="math/tex; mode=display">(U, V,\beta,\gamma_1, \gamma_2)</script><p>where $U$ and $V$ are feasibly computable monoids, and</p><script type="math/tex; mode=display">\beta:U× U\rightarrow V,\ \ \ \gamma_i:U× V\rightarrow V\ \ (i=1,2)</script><p>are feasibly computable functions satisfying the following properties.</p><p>​    (i) For all elements $x, y_1, y_2 \in U$ ,</p><script type="math/tex; mode=display">\beta(x,y_1\cdot y_2)=\beta(x,y_1)\cdot \beta(x,y_2)</script><p>​    (ii) For all elements $x, y \in U$ ,</p><script type="math/tex; mode=display">\gamma_1(x,\beta(y,x))=\gamma_2(x,\beta(x,y))</script><p>​    (iii) Suppose $y_1, y_2, \cdots ,y_k \in U$ and $\beta(x, y_1), \beta(x, y_2), \cdots ,\beta(x, y_k)$ are publicly known for some secret element $x \in U$. Then, in general, it is infeasible to determine the secret element $x$ .</p><p>​    The users $A$ and $B$ are publicly assigned submonoids, $S_A, T_B \subseteq U$, respectively. Suppose that $S_A$ is generated by the elements</p><script type="math/tex; mode=display">\{s_1,\cdots ,s_m\}</script><p>and $S_B$ is generated by $\{t_1,\cdots,t_n\}$.The protocol begins with user A choosing a secret element a in $S_A$ and transmitting the elements</p><script type="math/tex; mode=display">\beta(a,t_i)\ \ \ \ \ \ i=1,\cdots,n.</script><p>Likewise, user $B$ chooses a secret element $b$ in $T$, transmits</p><script type="math/tex; mode=display">\beta(b,s_i)\ \ \ \ \ \ i=1,\cdots,m.</script><p>It follows from property (iii) that even though the transmission is over a public channel, the secret elements $a$ and $b$ are secure. Property (i) above insures that user $A$ can compute the element</p><script type="math/tex; mode=display">\beta(b,a),</script><p>and</p><script type="math/tex; mode=display">\gamma_1(a,\beta(b,a)).</script><p>Likewise user $B$ can compute $\beta(a, b)$ and $\gamma_2(b, \beta(a, b))$. Recalling property (ii) above we see that</p><script type="math/tex; mode=display">\kappa=\gamma_1(a,\beta(b,a))=\gamma_2(b,\beta(a,b))</script><p>can serve as an established key.</p><h3 id="具体例子（群论协议，A-group-theoretic-protocol）"><a href="#具体例子（群论协议，A-group-theoretic-protocol）" class="headerlink" title="具体例子（群论协议，A group theoretic protocol）"></a>具体例子（群论协议，A group theoretic protocol）</h3><p>In this illustration the monoid $U = V$ is a group, denoted $G$, and the users $A$ and $B$ are publicly assigned subgroups</p><script type="math/tex; mode=display">S_A=\langle s_1,s_2,\cdots ,s_m\rangle,\ \ \ \ S_B=\langle t_1,t_2,\cdots ,t_n\rangle.</script><p>Here the function $\beta:G× G\rightarrow G$ is chosen to be conjugation,</p><script type="math/tex; mode=display">\gamma_1(u,v)=u^{-1}v,\ \ \ \ \ \ \gamma_2(u,v)=v^{-1}u.</script><p>Users A and B choose secret elements $a \in S_A$ and $b \in S_B$ respectively, and user $A$ begins the protocol by computing, rewriting, and transmitting the collection of elements</p><script type="math/tex; mode=display">a^{-1}t_1a,a^{-1}t_2a,\cdots ,a^{-1}t_na.</script><p>Similarly, user $B$ computes, rewrites, and transmits</p><script type="math/tex; mode=display">b^{-1}s_1b,b^{-1}s_2b,\cdots,b^{-1}s_mb.</script><p>An adversary observing these transmissions is unable to determine $a$ or $b$ unless $(s)$ he can solve a set of simultaneous conjugacy equations over the base group. </p><p>​    Multiplying two elements in the group can be accomplished by simply concatenating the two expressions representing the elements. The process of rewriting, while not unique, must be chosen so that no adversary can determine the conjugating element from viewing the publicly transmitted conjugates.</p><p>​    Recalling that the conjugate of the product of two elements is the product of the conjugates of those elements (i.e., property (i) of $\beta$), users $A$ and $B$ are now in a position to compute, respectively, the elements</p><script type="math/tex; mode=display">\beta(b,a)=b^{-1}ab,\ \ \ \ \ \ \ \ \beta(a,b)=a^{-1}ba.</script><p>In order to attain a common key, user $A$ computes</p><script type="math/tex; mode=display">\kappa=\gamma_1(a,\beta(b,a))=a^{-1}b^{-1}ab=[a,b],</script><p>and user $B$ computes</p><script type="math/tex; mode=display">\kappa=\gamma_2(a,\beta(b,a))=[a,b].</script><p>（上文摘自<em>Mathematical Research Letters 6, 287–291 (1999),AN ALGEBRAIC METHOD FOR PUBLIC-KEY CRYPTOGRAPHY</em>,Iris Anshel, Michael Anshel, and Dorian Goldfeld著）</p><h4 id="应用例"><a href="#应用例" class="headerlink" title="应用例"></a>应用例</h4><h5 id="UTCTF2020-Cube-Crypto"><a href="#UTCTF2020-Cube-Crypto" class="headerlink" title="[UTCTF2020]Cube Crypto"></a>[UTCTF2020]Cube Crypto</h5><p>Mr. Anshel and Mr. Goldfeld were trying to exchange some asymmetric keys to get a shared key. They aren’t very good at math, so they decided to use a Rubik’s Cube instead to do the crypto. I don’t think it’s very secure though, I think you might be able to guess some of their keys :hmm:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mr. A public key: [B&#x27; U&#x27;, F B F, R&#x27; D, B D&#x27;]</span><br><span class="line">Mr. G public key: [R D L&#x27;, D U&#x27; B, U F&#x27;, L&#x27; F]</span><br><span class="line"></span><br><span class="line">Mr. A sends: [B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;, B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;]</span><br><span class="line">Mr. G sends: [U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;]</span><br></pre></td></tr></table></figure><p><strong>NOTE: The flag is the shared key that they generate, so it is NOT in <code>utflag&#123;&#125;</code> format</strong></p><p>显然的，这道题需要应用Anshel–Anshel–Goldfeld 密钥交换体系，在这里，密钥是由魔方转动记号呈现的，而我们知道，魔方的转动操作群是非阿贝尔群，在这里，我们可以从Mr.A和Mr.G提供的公钥中提取出：</p><script type="math/tex; mode=display">S_A=\langle s_1,s_2,s_3,s_4\rangle\ \ \ \ \ \ \ S_G=\langle t_1,t_2,t_3,t_4\rangle</script><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1=B&#x27; U&#x27;</span><br><span class="line">s_2=F B F</span><br><span class="line">s_3=R&#x27; D</span><br><span class="line">s_4=B D&#x27;</span><br><span class="line">t_1=R D L&#x27;</span><br><span class="line">t_2=D U&#x27; B</span><br><span class="line">t_3=U F&#x27;</span><br><span class="line">t_4=L&#x27; F</span><br></pre></td></tr></table></figure><p>又设在交换后得出的密文的集合分别为：</p><script type="math/tex; mode=display">C_G=\langle s_1',s_2',s_3',s_4'\rangle\ \ \ \ \ \ \ C_A=\langle t_1',t_2',t_3',t_4'\rangle</script><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1&#x27;=U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_2&#x27;=U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_3&#x27;=U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_4&#x27;=U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">t_1&#x27;=B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_2&#x27;=B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;</span><br><span class="line">t_3&#x27;=B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_4&#x27;=B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;</span><br></pre></td></tr></table></figure><p>我们假设共享密钥为$a^{-1}g^{-1}ag$，所以我们有：</p><script type="math/tex; mode=display">a^{-1}t_ia=t_i'\ \ \ \ \ g^{-1}s_ig=s_i'\ \ \ \ \ (i=1,2,3,4)</script><p>通过观察我们很容易可以得到：</p><script type="math/tex; mode=display">a=D' R D B'\\g=L D' R' F U'</script><p>所以我们可以得出共享密钥：</p><script type="math/tex; mode=display">a^{-1}g^{-1}ag=B D' R' DU F' R D L'D' R D B'L D' R' F U'</script><p>这样我们就得到了flag：</p><blockquote><p>utflag{B D’ R’ D U F’ R D L’ D’ R D B’ L D’ R’ F U’}</p></blockquote><p>至此，对于Anshel–Anshel–Goldfeld 密钥交换体系的介绍就到此结束了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）&quot;&gt;&lt;a href=&quot;#原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Triode的RSA学习笔记（1）</title>
    <link href="https://triodelzx.github.io/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://triodelzx.github.io/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2023-11-17T05:20:03.000Z</published>
    <updated>2024-09-27T07:03:17.529Z</updated>
    
    <content type="html"><![CDATA[<p>在进行RSA解密之前，我们先要理解RSA的加密原理：</p><p>已知明文$a$，公钥对$(n,e)$，加密过程如下:</p><script type="math/tex; mode=display">b\equiv a^e\ (mod\ n)</script><p>若要对已知的密文进行解密，我们就需要得到私钥(Private Key)：</p><p>设对于上述加密过程所得出的私钥为$d$，则：</p><script type="math/tex; mode=display">a\equiv b^d\ (mod\ n)</script><p>很明显：</p><script type="math/tex; mode=display">b^{ed}\equiv a^e\equiv b\ (mod\ n)</script><p>所以：</p><script type="math/tex; mode=display">b^{ed-1}\equiv 1\ (mod\ n)</script><p>一般情况下，$gcd(n,b)=1$，故先对这种情况进行考虑</p><p>由欧拉定理：我们知道</p><script type="math/tex; mode=display">b^{\varphi(n)}\equiv 1\ (mod\ n)</script><p>很显然：</p><script type="math/tex; mode=display">ed-1=k\varphi(n)</script><p>可以看出：</p><script type="math/tex; mode=display">ed\equiv1\ (mod\ \varphi(n))</script><p>所以：</p><script type="math/tex; mode=display">d=inv(e,\varphi(n))\ (inv(e,\varphi(n))为e模\varphi(n)的乘法逆元)</script><hr><h3 id="已知n-e-c在一般情况下（n可通过软件进行质因数分解）的解密"><a href="#已知n-e-c在一般情况下（n可通过软件进行质因数分解）的解密" class="headerlink" title="已知n,e,c在一般情况下（n可通过软件进行质因数分解）的解密"></a>已知n,e,c在一般情况下（n可通过软件进行质因数分解）的解密</h3><p>此时，我们有：</p><script type="math/tex; mode=display">n=p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}(p_1,p_2,p_3,\cdots ,p_k为k个不同质数)</script><p>此时，由欧拉函数的性质，我们有：</p><p>$\varphi(n)=\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}=n)$</p><p>由欧拉函数的计算公式我们可以知道：</p><script type="math/tex; mode=display">\varphi(p^k)=p^k\prod_{i=1}^{k}\bigg(1-\frac{1}{p^i}\bigg)</script><p>所以对于$n$，有：</p><script type="math/tex; mode=display">\varphi(n)=\prod_{i=1}^{k}p_i^{\alpha_i}\prod_{j = 1}^{\alpha_i}\bigg(1-\frac{1}{p_i^j}\bigg)</script><p>特别的，对于质数$p$，有：</p><script type="math/tex; mode=display">\varphi(p)=p\bigg(1-\frac{1}{p}\bigg)=p-1</script><p>若$n$为$k$个不相同质数相乘，即：</p><script type="math/tex; mode=display">n=p_1p_2p_3\cdots p_k</script><p>有：</p><script type="math/tex; mode=display">\varphi(n)=(p_1-1)(p_2-1)(p_3-1)\cdots(p_k-1)</script><p>在一般情况下$n$只有两个质因数$p$和$q$，例如下题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long,long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd,invert</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">p=<span class="number">274327862430236019688316864082249987313</span></span><br><span class="line">q=<span class="number">206961224895267889099693426679050192439</span></span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"><span class="comment"># c = 54831930044859946955044417597501651143196043923856762253170140444376354297816</span></span><br></pre></td></tr></table></figure><p>这题直接给出了$p$和$q$，故我们只需要写出如下代码即可解决：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = <span class="number">274327862430236019688316864082249987313</span></span><br><span class="line">q = <span class="number">206961224895267889099693426679050192439</span></span><br><span class="line">c = <span class="number">54831930044859946955044417597501651143196043923856762253170140444376354297816</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)<span class="comment">#求e模phi的乘法逆元</span></span><br><span class="line">m = gmpy2.powmod(c,d,n)<span class="comment">#等价于c^d mod n</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行即可得出flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;how_excellent_you_are!&#125;</span><br></pre></td></tr></table></figure><p>这就是最基本的RSA类型了。</p><h3 id="在已知e以及e组-n-c-的广播攻击"><a href="#在已知e以及e组-n-c-的广播攻击" class="headerlink" title="在已知e以及e组(n,c)的广播攻击"></a>在已知e以及e组(n,c)的广播攻击</h3><p>此类型攻击属于CRT（Chinese remainder theorem，中国剩余定理，又称孙子定理）类型。</p><p>原理不赘述，实质上即为已知$e$组$(n,c)$时利用CRT在不对任何一个$n$进行分解的情况下求解明文</p><p>在这里，我们设明文为$m$，有：</p><script type="math/tex; mode=display">\begin{cases}m^e\equiv c_1\ (mod\ n_1)\\m^e\equiv c_1\ (mod\ n_1)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\m^e\equiv c_e\ (mod\ n_e)\end{cases}\\\ \ \ (其中(n_1,c_1),(n_2,c_2),\cdots,(n_e,c_e)为e组不同的n与c)</script><p>再通过CRT求解出$m^e$后对其开$e$次方根即可得到明文$m$</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><h6 id="鹤城杯-2021-Crazy-Rsa-Tech"><a href="#鹤城杯-2021-Crazy-Rsa-Tech" class="headerlink" title="[鹤城杯 2021]Crazy_Rsa_Tech"></a>[鹤城杯 2021]Crazy_Rsa_Tech</h6><p>题目代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">FLAG = bytes_to_long(pad(<span class="string">b&quot;flag&#123;??????&#125;&quot;</span>,<span class="number">64</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_key</span>():</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">    n = p*q</span><br><span class="line">    e = <span class="number">9</span></span><br><span class="line">    <span class="keyword">while</span>(GCD((p-<span class="number">1</span>)*(q-<span class="number">1</span>),e)!=<span class="number">1</span>):</span><br><span class="line">        p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">        n = p*q</span><br><span class="line">    d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> n,e,d</span><br><span class="line"></span><br><span class="line">n_list=<span class="built_in">list</span>()</span><br><span class="line">c_list=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    N,e,d=init_key()</span><br><span class="line">    n_list.append(N)</span><br><span class="line">    c=<span class="built_in">pow</span>(FLAG,e,N)</span><br><span class="line">    c_list.append(<span class="built_in">pow</span>(FLAG,e,N))</span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">pow</span>(c,d,N)==FLAG)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n_list:&quot;</span>,n_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c_list:&quot;</span>,c_list)</span><br><span class="line"><span class="comment">#n_list= [71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799, 92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949, 100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919, 59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847, 66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147, 120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377, 72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281, 69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951, 76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581]</span></span><br><span class="line"><span class="comment">#c_list=[62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585, 46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900, 85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198, 14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656, 1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839, 2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981, 16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376, 31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996, 25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里很容易可以知道$e=9$（显而易见，$n$和$c$也有九组），所以很显然，这题要用到$e=9$的广播攻击</p><p>将上面给出的n_list和c_list用sagemath利用CRT求解得出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m9=<span class="number">3678337284039442047026947312380394506988284605153398380909870598085147736828709178219597429308046538374273111663234962853201175297522552444068549756304348183089003998584929250444862897734669616839072634559776823068102560978738392642133409979083241310818961120830565330801827594023873873703163937572703881578432281109467318674533265052430906776650900523035132668203491899352234368836316318216812572637893433384928785981896373747430646617935503364537613820302679656375356094380483213814869276308187497478084540603362678580814022322799191778371368875742773945120383365613028633102737056410926701477700008313642639347163933146129361496566648131161287075292980980083166106192999528561889437021539352391671756010617540361596164032486633114877739259434431765044242037641759566659268290619705700083536966807192023377334915872207418596226819579720241509860110741821630775501873143209229299530346706612248414951753383716954165108266753409813119293227854442685830689203424064786691447734948037502729127922328149002842971722645909768174575776908113523451541199095073733017029558396658874593357205426105429760517295964966905772455366037986657671195106462661190327510507460112791663031458690187525393979689469548319821181450874331998372947479866557921497942728807505035932385939931524294822439633516457845581452433022749099648076725811489217888688273759202726271093237450290814247396662589614216704</span><span class="comment">#m9为m的9次方</span></span><br></pre></td></tr></table></figure><p>再对$m9$开9次方根可得：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=<span class="number">5364346700993245916083351542951836466599376039702798829478182513243184146028312538778801523615449405915572188751896617305936540801999004614344621214275094</span></span><br></pre></td></tr></table></figure><p>再通过Crypto库中long_to_bytes函数可得：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;H0w_Fun_13_HAstads_broadca5t_AtTack!&#125;</span><br></pre></td></tr></table></figure><h3 id="gcd类型"><a href="#gcd类型" class="headerlink" title="gcd类型"></a>gcd类型</h3><p>这种类型主要考察数学推导的能力，直接上例题。</p><h4 id="GKCTF-2021-RRRRsa-1（部分）"><a href="#GKCTF-2021-RRRRsa-1（部分）" class="headerlink" title="[GKCTF 2021]RRRRsa 1（部分）"></a>[GKCTF 2021]RRRRsa 1（部分）</h4><p>题目代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pbits = <span class="number">512</span></span><br><span class="line">p, q = getPrime(pbits), getPrime(pbits)</span><br><span class="line">n = p * q</span><br><span class="line">hint1 = <span class="built_in">pow</span>(<span class="number">2020</span> * p + q, <span class="number">202020</span>, n)</span><br><span class="line">hint2 = <span class="built_in">pow</span>(<span class="number">2121</span> * p + <span class="number">212121</span>, q, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint1 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint2 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n =</span></span><br><span class="line"><span class="string">72480597722768310802103225074022304502987810353239303491995392556828592827312126864102279719480413772239054950810362120660174703790228376146053986053171930937388580526219104498648291397309599209554202670080978901954049943834889894306222459711036629282482760872552358198065124168348275611897584923869319730917</span></span><br><span class="line"><span class="string">hint1 =</span></span><br><span class="line"><span class="string">70685159982753618117937078087626553902610663214529331305611406765104333038200912863267956767277081926123480288270862897047313253820275507292683667878994502600957911694615683337770022569861106230373836250952155917286151237134316356851059293688768775787985566372022900108303136666429150678266857778726967849907</span></span><br><span class="line"><span class="string">hint2 =</span></span><br><span class="line"><span class="string">59397395285145715354919882069200896861665631746130494855994590508589325004636436593048816842106180115714527211321251497281171549276111388361451000025849056493942252398618018816656979043710894623882099581494083699322411790446784391932055982624616996747139852037848608960801937270797966812928286289985647495610</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以知道：</p><script type="math/tex; mode=display">hint1\equiv (2020p+q)^{202020}\ (mod\ n)\\hint2\equiv (2121p+212121)^{q}\ (mod\ n)</script><p>我们要从上面两个方程中求解$p$和$q$，下面进行数学推导：</p><p>首先观察hint1，由二项式定理有：</p><script type="math/tex; mode=display">(2020p+q)^{202020}=(2020p)^{202020}+(2020p)^{202019}q+\cdots+2020pq^{202019}+q^{202020}</script><p>显然的，右式除$(2020p)^{202020}$与$q^{202020}$两项外均能被$n$整除</p><p>所以有：</p><script type="math/tex; mode=display">hint1\equiv (2020p)^{202020}+q^{202020}\ (mod\ n)</script><p>进一步的，有：</p><script type="math/tex; mode=display">hint1\equiv(2020p)^{202020}\ (mod\ q)</script><p>现在看到hint2，有：</p><script type="math/tex; mode=display">hint2\equiv (2121p+212121)^q\ (mod\ q)</script><p>由费马小定理，可以得到：</p><script type="math/tex; mode=display">hint2\equiv 2121p+212121\ (mod\ q)</script><p>所以：</p><script type="math/tex; mode=display">(hint2-212121)^{202020}(2020)^{202020}\equiv (2020\cdot2021p)^{202020}\ (mod\ q)</script><p>对于hint1：</p><script type="math/tex; mode=display">hint1(2121)^{202020}\equiv (2020\cdot2021p)^{202020}\ (mod\ q)</script><p>故：</p><script type="math/tex; mode=display">hint1(2121)^{202020}-(hint2-212121)^{202020}(2020)^{202020}\equiv 0\ (mod\ q)</script><p>所以有：</p><script type="math/tex; mode=display">kq=hint1(2121)^{202020}-(hint2-212121)^{202020}(2020)^{202020}</script><p>由于$n=pq$</p><p>所以$gcd(kq,n)=$</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n = <span class="number">72480597722768310802103225074022304502987810353239303491995392556828592827312126864102279719480413772239054950810362120660174703790228376146053986053171930937388580526219104498648291397309599209554202670080978901954049943834889894306222459711036629282482760872552358198065124168348275611897584923869319730917</span></span><br><span class="line">hint1 = <span class="number">70685159982753618117937078087626553902610663214529331305611406765104333038200912863267956767277081926123480288270862897047313253820275507292683667878994502600957911694615683337770022569861106230373836250952155917286151237134316356851059293688768775787985566372022900108303136666429150678266857778726967849907</span></span><br><span class="line">hint2 = <span class="number">59397395285145715354919882069200896861665631746130494855994590508589325004636436593048816842106180115714527211321251497281171549276111388361451000025849056493942252398618018816656979043710894623882099581494083699322411790446784391932055982624616996747139852037848608960801937270797966812928286289985647495610</span></span><br><span class="line">kq = gmpy2.powmod(<span class="number">2121</span>,<span class="number">202020</span>,n)*hint1-gmpy2.powmod((hint2-<span class="number">212121</span>)*<span class="number">2020</span>,<span class="number">202020</span>,n)</span><br><span class="line">q = gmpy2.gcd(kq,n)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure><p>这样就得出了$q$，由此我们就可以顺带求出$p$了。</p><p>（还有道题是Geek Challenge 2023的Poly_RSA，但是在写笔记的时候比赛还没结束，就不放出来了，后面写wp的时候再讲推导过程）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在进行RSA解密之前，我们先要理解RSA的加密原理：&lt;/p&gt;
&lt;p&gt;已知明文$a$，公钥对$(n,e)$，加密过程如下:&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
b&#92;equiv a^e&#92; (mod&#92; n)&lt;/script&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
</feed>
