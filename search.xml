<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同源（1）——SIDH</title>
      <link href="/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/"/>
      <url>/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://arxiv.org/pdf/1711.04062">Mathematics of Isogeny Based Cryptography</a></p></li><li><p><a href="https://eprint.iacr.org/2019/1321.pdf">Supersingular isogeny key exchange for beginners</a></p></li><li><p><a href="https://link.springer.com/book/10.1007/b97292">Elliptic Curves | SpringerLink</a></p></li><li><p><a href="https://tangcuxiaojikuai.xyz/post/e06139e7.html">Isogeny | 糖醋小鸡块的blog</a></p></li><li><p><a href="https://languag3.github.io/2025/02/04/isogeny/#sidh">isogeny | languag3</a></p></li><li><p><a href="https://huangx607087.online/2025/02/01/ECCNotes4/">ECCNotes4 - huangx607087's Blog</a></p></li></ol></blockquote><h2 id="前置知识">前置知识</h2><h3 id="超奇异supersingular椭圆曲线">超奇异（supersingular）椭圆曲线</h3><p>对于<span class="math inline">\(GF(p^r)\)</span>下的椭圆曲线<span class="math inline">\(E\)</span>，若<span class="math inline">\(|E|\equiv 1\pmod{p}\)</span>，则称该曲线为超奇异椭圆曲线</p><h3 id="j-不变量j-invariant"><span class="math inline">\(j\)</span>-不变量（<span class="math inline">\(j\)</span>-invariant）</h3><p>对于一条由方程<span class="math inline">\(y^2=x^3+ax+b\)</span>定义的椭圆曲线<span class="math inline">\(E\)</span>，其<span class="math inline">\(j\)</span>-不变量的定义为： <span class="math display">\[j(E)=1728\cdot\frac{4a^3}{4a^3+27b^2}\]</span> 当且仅当两条定义在代数闭包<span class="math inline">\(\overline{k}\)</span>上的曲线<span class="math inline">\(E\)</span>与<span class="math inline">\(E&#39;\)</span>的<span class="math inline">\(j\)</span>-不变量相同时这两条曲线同构，即存在点到点之间的双射<span class="math inline">\(\phi\)</span>使得： <span class="math display">\[\phi:E\mapsto E&#39;\]</span> 通过参考资料2我们可以知道对于SIDH，其主要作用于有限域<span class="math inline">\(GF(p)\)</span>的二次扩展（即<span class="math inline">\(GF(p^2)\)</span>，其中<span class="math inline">\(p\equiv 3\pmod{4}\)</span>），方便起见，我们通常将这个二次扩展域中的元素表示为<span class="math inline">\(u+vi\)</span>（其中<span class="math inline">\(u,v\in GF(p)\)</span>，<span class="math inline">\(i^2\equiv-1\pmod{p}\)</span>），定义在这个二次扩展域上的超奇异<span class="math inline">\(j\)</span>-不变量的个数为<span class="math inline">\(\lfloor p/12\rfloor+z\)</span>，这些超奇异<span class="math inline">\(j\)</span>-不变量每一个都对应一条同构意义下的超奇异曲线，其中<span class="math inline">\(z\in\{0,1,2\}\)</span>，<span class="math inline">\(z\)</span>的取值取决于<span class="math inline">\(p\mod 12\)</span>，具体如下（参考资料3，P264）： <span class="math display">\[z=\begin{cases}0&amp;,p\equiv1\pmod{12}\\1&amp;,p\equiv5\pmod{12}\\1&amp;,p\equiv7\pmod{12}\\2&amp;,p\equiv11\pmod{12}\\\end{cases}\]</span> 例如对于参考资料2中的例子（即<span class="math inline">\(p=431\)</span>），<span class="math inline">\(GF(p^2)\)</span>中的<span class="math inline">\(\lfloor p/12\rfloor+2=37\)</span>个<span class="math inline">\(j\)</span>-不变量分别对应一条同构意义下的超奇异曲线，这些<span class="math inline">\(j-\)</span>不变量如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006712.png" alt="image-20250226200636189" /> 关于<span class="math inline">\(j\)</span>-不变量与曲线间同构的关系，参考资料2给出了一个例子：对于<span class="math inline">\(GF(431^2)\)</span>下的两条曲线： <span class="math display">\[\begin{aligned}E_1:y^2=x^3+(208i+161)x^2+x\\E_2:y^2=x^3+(172i+162)x^2+x\\\end{aligned}\]</span> 可以计算出<span class="math inline">\(j(E_1)=j(E_2)=364i+304\)</span>，那么我们可以通过如下代码来求出<span class="math inline">\(E_1\)</span>到<span class="math inline">\(E_2\)</span>的同构映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line"></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E1 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E2 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">172</span>*i+<span class="number">162</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(E1.j_invariant())</span><br><span class="line"><span class="built_in">print</span>(E2.j_invariant())</span><br><span class="line"></span><br><span class="line">phi = E1.isomorphism_to(E2)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[\begin{aligned}\phi:&amp;E_1\mapsto E_2\\&amp;(x,y)\mapsto((66i + 182)x + (-131i + 109), (122i + 159)y)\end{aligned}\]</span></p><h3 id="蒙哥马利montgomery曲线">蒙哥马利（Montgomery）曲线</h3><p>在椭圆曲线密码学中常用的椭圆曲线为形如<span class="math inline">\(y^2=x^3+ax+b\)</span>方程所确定的曲线，这类方程一般称为魏尔斯特拉斯（Weierstrass）方程，这类方程确定的曲线一般称为魏尔斯特拉斯形式的椭圆曲线，还有另外一种形式的椭圆曲线是由方程<span class="math inline">\(y^2=x^3+Ax^2+x\)</span>所定义的，这类椭圆曲线被称为蒙哥马利曲线，对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+Ax^2+x\)</span>，其<span class="math inline">\(j\)</span>-不变量为： <span class="math display">\[j(E)=\frac{256(A^2-3)^3}{A^2-4}\]</span> 任意一条椭圆曲线都可以转换为<span class="math inline">\(j\)</span>-不变量相同（亦即同构）的蒙哥马利曲线，在sage中，我们可以通过<code>montgomery_model</code>来将一条椭圆曲线转换为蒙哥马利曲线，例如我们要将魏尔斯特拉斯形式的椭圆曲线： <span class="math display">\[E:y^2=x^3+312589632x+654443578\pmod{1912812599}\]</span> 转换为对应的蒙哥马利曲线，则可以通过如下代码进行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">1912812599</span></span><br><span class="line">a = <span class="number">312589632</span></span><br><span class="line">b = <span class="number">654443578</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line">E_M = <span class="built_in">print</span>(E.montgomery_model()</span><br></pre></td></tr></table></figure> 可以得到其对应的蒙哥马利曲线为： <span class="math display">\[E_M:y^2 = x^3 + 723347356x^2 + x\pmod{1912812599}\]</span></p><h3 id="同源">同源</h3><p>同源实际上就是一条曲线到另一条曲线或者一条曲线到自身的映射，其本质为同态，可以简单地表达为<span class="math inline">\((x,y)\mapsto(f(x,y),g(x,y))\)</span>，其中<span class="math inline">\(f,g\)</span>是两个函数。在之后的讨论中将主要以蒙哥马利曲线为主，因为蒙哥马利曲线之间的映射可以单纯通过对<span class="math inline">\(x\)</span>进行映射<span class="math inline">\(x\mapsto f(x)\)</span>来表示出曲线间完整的映射，其完整映射形式为： <span class="math display">\[(x,y)\mapsto(f(x),cyf&#39;(x))\]</span> 其中<span class="math inline">\(c\)</span>是固定常数，<span class="math inline">\(f&#39;\)</span>为<span class="math inline">\(f\)</span>的导函数. 对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，可以得到一个<span class="math inline">\(E\)</span>到<span class="math inline">\(E\)</span>的同构映射： <span class="math display">\[[2]:E\mapsto E, x\mapsto\frac{(x^2-1)^2}{4x(x^2+ax+1)}\]</span> 这个映射一般称为二倍点映射，事实上，我们令分母<span class="math inline">\(4x(x^2+ax+1)=0\)</span>，可以得到三个根<span class="math inline">\(0,\alpha,\frac{1}{\alpha}\)</span>（其中<span class="math inline">\(\alpha\)</span>满足<span class="math inline">\(\alpha^2+a\alpha+1\)</span>），我们就可以得到曲线上阶为<span class="math inline">\(2\)</span>的点：<span class="math inline">\((0,0),(\alpha,0),(\frac{1}{\alpha},0)\)</span>，这三个点的集合就是映射<span class="math inline">\([2]\)</span>的核，记为<span class="math inline">\(\ker([2])\)</span>，它是椭圆曲线群<span class="math inline">\(E\)</span>的一个子群，同构于<span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，这上面的点称为<span class="math inline">\(2\)</span>-torsion，事实上对于任意一条椭圆曲线都有其对应的<span class="math inline">\(\ker([2])\)</span> 例如对于<span class="math inline">\(GF(431^2)\)</span>下的椭圆曲线<span class="math inline">\(E:y^2=x^3+x\)</span>，可以通过如下代码得到对应的上述映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_numerator(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_denominator(<span class="number">2</span>))</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[[2]:E\mapsto E,x\mapsto\frac{x^4 + 429x^2 + 1}{4x^3 + 4x}\]</span> 我们令分母<span class="math inline">\(4x^3+4x=4(x^3+x)=0\)</span>，得到三个解<span class="math inline">\(0,i,-i\)</span>，据此我们就可以得到一个<span class="math inline">\(E\)</span>的一个子群<span class="math inline">\(\ker([2])=\{(0,0),(i,0),(-i,0),\mathcal{O}\}\)</span>，而且这三个点都可以确定一个二阶循环子群，我们可以通过sage的<code>division_points</code>方法对<span class="math inline">\(E\)</span>的零元开二次根来达到这一目的：<code>E(0).division_points(2)</code>，参考资料2中给出了这样一个图来描述<span class="math inline">\(\ker([2])\)</span>： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261959041.png" alt="image-20250226195932625" /> 在这里每个“花瓣”对应一个二阶循环子群。相应的，还有三倍点映射<span class="math inline">\([3]\)</span>，对于蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，其对应三倍点映射为： <span class="math display">\[[3]:E\mapsto E:x\mapsto\frac{x(x^4-6x^2-4ax^3-3)^2}{(3x^4+4ax^3+6x^2-1)^2}\]</span> 通过令分母等于<span class="math inline">\(0\)</span>我们可以得到四个根<span class="math inline">\(\beta,\delta,\zeta,\theta\)</span>，通过这四个根我们可以得到八个阶为<span class="math inline">\(3\)</span>的点：<span class="math inline">\((\beta,\pm\gamma),(\delta,\pm\epsilon),(\zeta,\pm\eta),(\theta,\pm\iota)\)</span>，这八个点加上无穷远点可以构成子群<span class="math inline">\(\ker([3])\simeq\mathbb{Z}_3\times\mathbb{Z}_3\)</span>，也可以叫做<span class="math inline">\(3\)</span>-torsion，<span class="math inline">\(3\)</span>-torsion的结构如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262000994.png" alt="image-20250226200054634" /></p><p>这里每个“花瓣”对应一个三阶循环子群。推广到一般情况，所有阶为<span class="math inline">\(l\)</span>的点（<span class="math inline">\(p\nmid l\)</span>）与<span class="math inline">\(\mathcal{O}\)</span>构成的子群就是<span class="math inline">\(\ker([l])\simeq \mathbb{Z}_l\times\mathbb{Z}_l\)</span>（或者称为<span class="math inline">\(l\)</span>-torsion)，而若<span class="math inline">\(l\)</span>为质数，则可以得到<span class="math inline">\(l+1\)</span>个<span class="math inline">\(l\)</span>阶循环子群</p><h4 id="可分同源">可分同源</h4><p>可分同源的定义为对于一条曲线<span class="math inline">\(E\)</span>上的椭圆曲线群以及它的一个子群<span class="math inline">\(G\)</span>，可以构造出唯一的同源<span class="math inline">\(\phi:E\mapsto E&#39;\)</span>，使得<span class="math inline">\(\ker(\phi)=G\)</span>，这样得到的曲线<span class="math inline">\(E&#39;\)</span>称为该同源的陪域（codomain），可以表示为<span class="math inline">\(E/G\)</span>。可分同源的另一种定义（Velu's formulas）是：输入一条椭圆曲线<span class="math inline">\(E\)</span>以及其子群<span class="math inline">\(G\)</span>的所有点，输出陪域<span class="math inline">\(E/G\)</span>以及对应的映射<span class="math inline">\(\phi\)</span>。</p><blockquote><p>由于<span class="math inline">\(\ker(\phi)=G\)</span>，所以对于任意点<span class="math inline">\(P\in G\)</span>，都有<span class="math inline">\(\phi(P)=\mathcal{O}\)</span></p></blockquote><p>以蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>为例，设其上一个二阶子群为<span class="math inline">\(G=\{\mathcal{O},(\alpha,0)\}\)</span>，我们可以以<span class="math inline">\(G,E\)</span>作为输入，得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{x(\alpha x-1)}{x-\alpha}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2=x^3+2(1-2\alpha^2)x^2+x\)</span>，这个映射被用于计算蒙哥马利曲线的2-同源（2-isogeny），对<span class="math inline">\(GF(431^2)\)</span>下的超奇异曲线<span class="math inline">\(E:y^2=x^3+(208i+161)x^2+x\)</span>，我们知道<span class="math inline">\(j(E)=364i+304\)</span>，则可以通过如下代码求得其一个<span class="math inline">\(2\)</span>-同源并确保其输出的陪域为蒙哥马利曲线： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">ker2 = E(<span class="number">0</span>).division_points(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [(0 : 1 : 0), (0 : 0 : 1), (350*i + 68 : 0 : 1), (304*i + 202 : 0 : 1)]</span></span><br><span class="line"></span><br><span class="line">alpha = ker2[<span class="number">2</span>]</span><br><span class="line">phi = E.isogeny(alpha, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">E_ = phi.codomain()</span><br><span class="line"><span class="built_in">print</span>(E_)</span><br><span class="line"><span class="built_in">print</span>(E_.j_invariant())</span><br></pre></td></tr></table></figure> 可以得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{(-81i + 68)x^2 - x}{x + (81i - 68)}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2 = x^3 + (102i+423)x^2 + x\)</span>，其<span class="math inline">\(j\)</span>-不变量<span class="math inline">\(j(E&#39;)=344i+190\)</span>，所以我们可以知道：同源会使其<span class="math inline">\(j\)</span>不变量发生变化。</p><h4 id="d-同源"><span class="math inline">\(d\)</span>-同源</h4><p>对于同源<span class="math inline">\(\phi\)</span>，我们称<span class="math inline">\(|\ker(\phi)|\)</span>为同源的度，度为<span class="math inline">\(d\)</span>的同源称为<span class="math inline">\(d\)</span>-同源，例如前面提到的<span class="math inline">\(2\)</span>-同源.</p><h4 id="sage上的同源">sage上的同源</h4><p>我们一般用sage的<code>isogeny</code>方法来计算同源，其函数原型如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isogeny(_kernel_, _codomain=None_, _degree=None_, _model=None_, _check=True_, _algorithm=None_, _velu_sqrt_bound=None_)</span><br></pre></td></tr></table></figure> 重要的参数如下：</p><ul><li><p><code>_kernel_</code>：就是前面提到输入的<span class="math inline">\(G\)</span>，可以是一个点，可以是点列，也可以是本原核多项式</p></li><li><p><code>codomain</code>：陪域，输入为一条椭圆曲线，这样生成的同源的陪域就是这条椭圆曲线</p></li><li><p><code>model</code>：输出的陪域的形式，有三种可选参数：</p></li></ul><ol type="1"><li><code>'minimal'</code>，输出全局最小的椭圆曲线</li><li><code>'short_weierstrass'</code>，输出short Weierstrass曲线，即由<span class="math inline">\(y^2=x^3+ax+b\)</span>形式的方程所定义的椭圆曲线</li><li><code>'montgomery'</code>输出蒙哥马利曲线</li></ol><ul><li><code>algorithm</code>：算法，有三种可选参数（均为自己的理解，可能不准确）：</li></ul><ol type="1"><li><code>'velusqrt'</code>，使用平方根Vélu算法</li><li><code>'factored'</code>，将度分解到为质因子之后再求解</li><li><code>'traditional'</code>，传统算法</li></ol><h3 id="同源图isogeny-graph">同源图（Isogeny graph）</h3><p>对于一个固定的<span class="math inline">\(p\)</span>，我们用<span class="math inline">\(GF(p^2)\)</span>中所有的超奇异<span class="math inline">\(j\)</span>-不变量各构造一条曲线，在每条曲线的<span class="math inline">\(\ker([l])\)</span>中取除了无穷远点外的所有点分别进行同源，将原来曲线的<span class="math inline">\(j\)</span>-不变量作为起点，同源得到的陪域的<span class="math inline">\(j\)</span>-不变量作为终点，就可以得到一个无向图，称为同源图，例如在参考资料2中给出的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006853.png" alt="image-20250226200558759" /> 通过同源图，我们可以知道超奇异曲线的<span class="math inline">\(j\)</span>-不变量在同源时的变化路线. 可以通过如下算法求<span class="math inline">\(GF(p^2)\)</span>下的<span class="math inline">\(\ker([l])\)</span>的同源图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">IsogenyGraph</span>(<span class="params">p, l=<span class="number">2</span>, vertex_size=<span class="number">3750</span>, size=[<span class="number">20</span>, <span class="number">20</span>]</span>):</span><br><span class="line">    R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    jlist = &#123;&#125;</span><br><span class="line">    Elist = []</span><br><span class="line"></span><br><span class="line">    E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span> E.is_supersingular()</span><br><span class="line">    jlist[E.j_invariant()] = <span class="built_in">set</span>()</span><br><span class="line">    Elist.append(E)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Elist:</span><br><span class="line">        tmp = Elist.pop()</span><br><span class="line">        kerl = tmp(<span class="number">0</span>).division_points(l)</span><br><span class="line">        <span class="keyword">for</span> P <span class="keyword">in</span> kerl:</span><br><span class="line">            <span class="keyword">if</span> P != tmp(<span class="number">0</span>):</span><br><span class="line">                phi = tmp.isogeny(P, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">                E2 = phi.codomain()</span><br><span class="line">                j = E2.j_invariant()</span><br><span class="line">                <span class="comment"># print(tmp.j_invariant(), j)</span></span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist:</span><br><span class="line">                    jlist[j] = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist[tmp.j_invariant()]:</span><br><span class="line">                    jlist[tmp.j_invariant()].add(j)</span><br><span class="line">                    Elist.append(E2)</span><br><span class="line"></span><br><span class="line">    Tab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> jlist:</span><br><span class="line">        Tab[x] = <span class="built_in">list</span>(jlist[x])</span><br><span class="line">    G = Graph(Tab)</span><br><span class="line"></span><br><span class="line">    G.set_pos(G.layout_circular())</span><br><span class="line">    G.plot(vertex_labels=<span class="literal">True</span>,vertex_size=vertex_size).show(figsize=size)</span><br></pre></td></tr></table></figure><p>通过这个算法画出来的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图长这样： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261957075.png" alt="output" /></p><h2 id="超奇异同源diffie-hellman密钥交换体系sidh">超奇异同源Diffie-Hellman密钥交换体系（SIDH）</h2><h3 id="sidh协议细节">SIDH协议细节</h3><p>首先密钥交换双方（以下称为Alice和Bob）协商选取模数<span class="math inline">\(p=2^a3^b-1\)</span>，其中<span class="math inline">\(2^a\approx 3^b\)</span>，然后选取一条<span class="math inline">\(GF(p^2)\)</span>下的超奇异椭圆曲线<span class="math inline">\(E\)</span>，在此之后，Alice选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(2^a\)</span>的两点<span class="math inline">\(P_A,Q_A\)</span>并公开，Bob选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(3^b\)</span>的两点<span class="math inline">\(P_B,Q_B\)</span>并公开（在选取的时候，需要保证<span class="math inline">\(P_A,Q_A\)</span>线性无关，<span class="math inline">\(P_B,Q_B\)</span>线性无关）。 Alice随机选取秘密值<span class="math inline">\(k_A\in\{0,1,\cdots,2^a-1\}\)</span>，计算<span class="math inline">\(S_A=P_A+k_AQ_A\)</span>，并通过<span class="math inline">\(S_A\)</span>计算同源<span class="math inline">\(\phi_A:E\mapsto E_A\)</span>，其中<span class="math inline">\(E_A=E/\langle S_A\rangle\)</span>，<span class="math inline">\(\phi_A\)</span>由<span class="math inline">\(a\)</span>个<span class="math inline">\(2\)</span>-同源组合而成，最后使用<span class="math inline">\((E_A,\phi_A(P_B),\phi_A(Q_B))\)</span>作为公钥，<span class="math inline">\((k_A,S_A)\)</span>作为私钥； 同样的，Bob随机选取秘密值<span class="math inline">\(k_B\in\{0,1,\cdots,3^b-1\}\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B\)</span>，通过<span class="math inline">\(S_B\)</span>计算同源<span class="math inline">\(\phi_B:E\mapsto E_B\)</span>，其中<span class="math inline">\(\phi_B\)</span>由<span class="math inline">\(b\)</span>个<span class="math inline">\(3\)</span>-同源组合而成，使用<span class="math inline">\((E_B,\phi_B(P_A),\phi_B(Q_A))\)</span>作为公钥，<span class="math inline">\((k_B,S_B)\)</span>作为私钥。 通过上述计算得到的公钥，Alice可以计算出<span class="math inline">\(S_{A}&#39;=\phi_B(P_A)+k_A\phi_B(Q_A)\)</span>，计算同源<span class="math inline">\(\phi_A&#39;:E_B\mapsto E_{AB}\)</span>，就可以计算出<span class="math inline">\(j_{AB}=j(E_{AB})\)</span>，同样的，Bob可以计算出<span class="math inline">\(S_{B}&#39;=\phi_A(P_B)+k_B\phi_A(Q_B)\)</span>，然后计算同源<span class="math inline">\(\phi_B&#39;:E_A\mapsto E_{BA}\)</span>，从而可以计算出<span class="math inline">\(j_{BA}=j(E_{BA})\)</span>，有<span class="math inline">\(j_{AB}=j_{BA}\)</span>，所以共享密钥值为<span class="math inline">\(j=j_{AB}=j_{BA}\)</span>.</p><h4 id="sidh实例">SIDH实例</h4><blockquote><p>本样例来源于参考资料2</p></blockquote><p>Alice和Bob协商选取模数<span class="math inline">\(p=2^43^3-1=431\)</span>，并选取<span class="math inline">\(GF(p^2)\)</span>上的一条超奇异椭圆曲线： <span class="math display">\[E:y^2=x^3+(329i+423)x^2+x\]</span> 有<span class="math inline">\(j(E)=87i+190\)</span>，Alice从中选取两个阶为<span class="math inline">\(2^4\)</span>的点： <span class="math display">\[P_A=(100i+248,304i+199),Q_A=(426i+394,51i+79)\]</span> 同时Bob从中选取两个阶为<span class="math inline">\(3^3\)</span>的点： <span class="math display">\[P_B = (358i+275, 410i+104),Q_B = (20i+185, 281i+239)\]</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">2</span>^<span class="number">4</span> * <span class="number">3</span>^<span class="number">3</span> - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, a, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span></span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure> 然后Alice从<span class="math inline">\(\{0,1,\cdots,2^4-1\}\)</span>中选择<span class="math inline">\(k_A=11\)</span>，据此计算<span class="math inline">\(S_A=P_A+k_AQ_A=(271i + 79, 153i + 430)\)</span>，我们可以通过如下算法计算同源路径从而得到<span class="math inline">\(S_A\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262005508.png" alt="image-20250226200532409" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line"></span><br><span class="line">SA_, EA_, PB_, QB_ = SA, E, PB, QB</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(a-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RA_ = SA_ * <span class="number">2</span>^e</span><br><span class="line">    phi = EA_.isogeny(-RA_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SA_, EA_, PB_, QB_ = phi(SA_), phi.codomain(), phi(PB_), phi(QB_)</span><br><span class="line"></span><br><span class="line">phiA = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiA = phiA * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_A:y^2 = x^3 + (128i+19)x^2 + x\)</span>，<span class="math inline">\(\phi_A(P_B)=(130i + 170,428i + 290)\)</span>，<span class="math inline">\(\phi_A(Q_B)=(235i+209,126i+15)\)</span>； 同理，Bob在<span class="math inline">\(\{0,1,\cdots,3^3-1\}\)</span>中选择<span class="math inline">\(k_B=2\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B=(122i +309, 291i+374)\)</span>，那么我们可以通过如下算法计算出<span class="math inline">\(S_B\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262003851.png" alt="image-20250226200334440" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line">SB_, EB_, PA_, QA_ = SB, E, PA, QA</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(b-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RB_ = SB_ * <span class="number">3</span>^e</span><br><span class="line">    phi = EB_.isogeny(RB_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SB_, EB_, PA_, QA_ = phi(SB_), phi.codomain(), phi(PA_), phi(QA_)</span><br><span class="line"></span><br><span class="line">phiB = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiB = phiB * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_B:y^2 = x^3 + (329i+8)x^2 + x\)</span>，<span class="math inline">\(\phi_B(P_A)=(160i + 421, 246i + 252)\)</span>，<span class="math inline">\(\phi_B(Q_A)=(119i+14, 246i + 138)\)</span> 这样双方的公钥均已经计算出来，最后Alice就可以通过自己的私钥计算出： <span class="math display">\[S_{A}&#39;=\phi_B(P_A)+k_A\phi{(Q_A)}\]</span> 再通过上述算法计算出Alice侧<span class="math inline">\(S_{A}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_A/\langle S_{A}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，同样的，Bob可以通过自己的私钥计算出： <span class="math display">\[S_{B}&#39;=\phi_A(P_B)+k_B\phi{(Q_A)}\]</span> 再通过上述算法计算出Bob侧<span class="math inline">\(S_{B}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_B/\langle S_{B}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，可以通过下列代码计算出共享密钥： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA_.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Bob_shared_secret)</span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB_.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 可以计算出共享密钥为<span class="math inline">\(234\)</span>，整理并优化代码后可以得到： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">p = <span class="number">2</span>^a * <span class="number">3</span>^b - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">A = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, A, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span> <span class="keyword">and</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br><span class="line"></span><br><span class="line">kA = <span class="number">11</span></span><br><span class="line">SA = PA + kA * QA</span><br><span class="line">phiA = E.isogeny(SA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">PB_ = phiA(PB)</span><br><span class="line">QB_ = phiA(QB)</span><br><span class="line"></span><br><span class="line">kB = <span class="number">2</span></span><br><span class="line">SB = PB + kB * QB</span><br><span class="line">phiB = E.isogeny(SB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">PA_ = phiB(PA)</span><br><span class="line">QA_ = phiB(QA)</span><br><span class="line"></span><br><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> Bob_shared_secret == Alice_shared_secret</span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 或者可以将封装公钥和计算私钥封装为函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_public_key</span>(<span class="params">E, P1, Q1, s, P2, Q2</span>):</span><br><span class="line">    S = P1 + s*Q1</span><br><span class="line">    phi = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi, (phi.codomain(), phi(P2), phi(Q2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_shared_secret</span>(<span class="params">E, P, Q, s</span>):</span><br><span class="line">    S = P + s*Q</span><br><span class="line">    phi1 = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi1.codomain().j_invariant()</span><br></pre></td></tr></table></figure></p><h3 id="sidh的安全性">SIDH的安全性</h3><p>理论上SIDH的安全性主要依赖于通过公钥中给出的曲线来求出它对应的同源。但是在2022年SIDH就被宣布完全破解，在Github上就有代码：<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>，<del>要用的话拔出来用就行</del></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过狄利克雷近似解决HNP-2H</title>
      <link href="/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/"/>
      <url>/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/</url>
      
        <content type="html"><![CDATA[<p>最近在复现Crypto CTF 2024的时候碰到一道题考察了HNP-2H（Hidden Number Problem with 2 Holes，双洞隐藏数问题），在做题的时候，找到了一篇论文：<a href="https://link.springer.com/content/pdf/10.1007/978-3-540-74462-7_9.pdf?pdf=inline+link">Extended Hidden Number Problem and Its Cryptanalytic Applications</a>，并通过这篇论文了解到可以通过狄利克雷近似定理来将HNP-2H约化为我们熟悉的HNP来解决。</p><h2 id="hnp-2h的定义">HNP-2H的定义</h2><p>这里直接引用论文中的定义：</p><p>设<span class="math inline">\(N\)</span>是一个质数，并设<span class="math inline">\(x\in \mathbb{Z}_n\)</span>是一个部分未知的整数满足以下<span class="math inline">\(d\)</span>条同余式： <span class="math display">\[\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N},\ 1\le i\le d\]</span> 其中<span class="math inline">\(\alpha_i\)</span>满足<span class="math inline">\(\alpha_i\mod{N}\neq0\)</span>，<span class="math inline">\(\alpha_i,\rho_{i,1},\rho_{i,2}\)</span>以及<span class="math inline">\(\beta_i\)</span>（<span class="math inline">\(1\le i\le d\)</span>）为已知量，未知量<span class="math inline">\(k_{i,1}\)</span>与<span class="math inline">\(k_{i,2}\)</span>满足<span class="math inline">\(0\le k_{i,1}\le2^{\mu_1}\)</span>及<span class="math inline">\(0\le k_{i,2}\le2^{\mu_2}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），其中<span class="math inline">\(\mu_1,\mu_2\)</span>为已知有理常量，则双洞隐藏数问题（Hidden Number Problem with 2 Holes）就是通过以上条件求出<span class="math inline">\(x\)</span>。</p><h2 id="使用狄利克雷近似解决hnp-2h">使用狄利克雷近似解决HNP-2H</h2><p>在使用狄利克雷近似解决HNP-2H之前，我们需要先了解何谓狄利克雷近似，其阐述如下</p><h3 id="狄利克雷近似dirichlets-approximation定理以及其推论">狄利克雷近似（Dirichlet's approximation）定理以及其推论</h3><p><strong>狄利克雷近似定理：</strong>设<span class="math inline">\(\alpha\in\mathbb{R}\)</span>以及<span class="math inline">\(0&lt;\varepsilon\le1\)</span>为两已知量，那么存在<span class="math inline">\(p,q\in\mathbb{Z}\)</span>使得<span class="math inline">\(1\le q\le\frac{1}{\varepsilon}\)</span>以及<span class="math inline">\(|\alpha-\frac{p}{q}|&lt;\frac{\varepsilon}{q}\)</span>成立。</p><p>通过这个定理，我们可以得到如下推论：</p><p>假定我们已知<span class="math inline">\(A,N\in\mathbb{Z}\)</span>与<span class="math inline">\(B\in\mathbb{R}\)</span>满足<span class="math inline">\(B\ge1\)</span>且<span class="math inline">\(N&gt;0\)</span>那么存在<span class="math inline">\(\lambda\in\mathbb{Z}\)</span>满足<span class="math inline">\(1\le\lambda\le B\)</span>且<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>.（<span class="math inline">\(|a|_N\)</span>表示<span class="math inline">\(min_{k\in\mathbb{Z}}|a-kN|\)</span>）</p><p>通过狄利克雷近似定理以及其推论，我们可以知道，在已知<span class="math inline">\(B\)</span>的情况下，我们可以通过连分数在多项式时间内通过<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>求解出<span class="math inline">\(\lambda\)</span></p><h3 id="借助狄利克雷近似解决hnp-2h">借助狄利克雷近似解决HNP-2H</h3><blockquote><p>本部分摘自论文第三部分的 Theorem 3 的证明</p></blockquote><p>令<span class="math inline">\(A_i=(\rho_{i,1})^{-1}\rho_{i,2}\mod{N}\)</span>，<span class="math inline">\(\gamma_i=k_{i,1}+A_ik_{i,2}\)</span>，<span class="math inline">\(\alpha_i&#39;=(\rho_{i,1})^{-1}\alpha_i\mod{N}\)</span>以及<span class="math inline">\(\beta_i&#39;=(\rho_{i,1})^{-1}\beta_i\mod{N}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），则同余式<span class="math inline">\(\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N}\)</span>可以转化为： <span class="math display">\[\alpha_i&#39;x+\gamma_i\equiv\beta&#39;_i\pmod{N}\]</span> 我们选定一个大于1的实数<span class="math inline">\(B\)</span>，由狄利克雷近似的推论，我们可以通过连分数找到一个非零整数<span class="math inline">\(\lambda_{i,B}\)</span>满足<span class="math inline">\(|\lambda_{i,B}A_i|&lt;\frac{N}{B}\)</span>，且有<span class="math inline">\(1\le\lambda_{i,B}\le B\)</span>（<span class="math inline">\(1\le i\le d\)</span>），使得下面的关系成立： <span class="math display">\[\begin{aligned}|\lambda_{i,B}\gamma_i|_N&amp;=|\lambda_{i,B}k_{i,1}+\lambda_{i,B}A_ik_{i,2}|_N\\&amp;\le|\lambda_{i,B}|_Nk_{i,1}+|\lambda_{i,B}A_i|_Nk_{i,2}\\&amp;&lt;B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\end{aligned}\]</span> 选择<span class="math inline">\(B_{min}=N^{\frac{1}{2}}2^{\frac{\mu_2-\mu_1}{2}}\)</span>可以最大限度地减少<span class="math inline">\(B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\)</span>的上界（此时<span class="math inline">\(B_{min}2^{\mu_1}+\frac{N}{B_{min}}2^{\mu_2}=N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\)</span>）.</p><p>在此之后，我们设<span class="math inline">\(k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{N}\)</span>，可以知道：<span class="math inline">\(k_i&#39;&lt;N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}\)</span>，那么通过下述步骤，我们就可以将HNP-2H转化为HNP，从而通过一般HNP的解决方法来解决HNP-2H了： <span class="math display">\[\begin{aligned}\alpha_i&#39;x+\gamma_i&amp;\equiv\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+\lambda_{i,B_{min}}\gamma_i&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+k_i&#39;&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\pmod{N}\\\alpha_i&#39;&#39;x+k_i&#39;&amp;\equiv\beta_i&#39;&#39;\pmod{N},\ (1\le i\le d)\end{aligned}\]</span></p><h2 id="例crypto-ctf-2024-honey">例：[Crypto CTF 2024] Honey</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_params</span>(<span class="params">nbit</span>):  </span><br><span class="line">    p, Q, R, S = getPrime(nbit), [], [], []  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(nbit &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       Q.append(getRandomRange(<span class="number">1</span>, p - <span class="number">1</span>))  </span><br><span class="line">       R.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">       S.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">return</span> p, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m, params</span>):  </span><br><span class="line">    p, Q, R, S = params  </span><br><span class="line">    <span class="keyword">assert</span> m &lt; p  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(p.bit_length() &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    C = []  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       r, s = [getRandomNBitInteger(d) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&#x27;01&#x27;</span>]  </span><br><span class="line">       c = Q[_] * m + r * R[_] + s * S[_]  </span><br><span class="line">       C.append(c % p)  </span><br><span class="line">    <span class="keyword">return</span> C  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">nbit = <span class="number">512</span>  </span><br><span class="line">params = gen_params(<span class="number">512</span>)  </span><br><span class="line">m = bytes_to_long(flag)  </span><br><span class="line">C = encrypt(m, params)  </span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;params_enc.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;p = <span class="subst">&#123;params[<span class="number">0</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;Q = <span class="subst">&#123;params[<span class="number">1</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;R = <span class="subst">&#123;params[<span class="number">2</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;S = <span class="subst">&#123;params[<span class="number">3</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;C = <span class="subst">&#123;C&#125;</span>&#x27;</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>整理可得方程组： <span class="math display">\[C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\]</span> 其中<span class="math inline">\(i=1,2,\cdots,d\)</span>，而<span class="math inline">\(C_i,Q_i,R_i,S_i\)</span>以及<span class="math inline">\(p\)</span>均已知，而且知道<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，要求<span class="math inline">\(m\)</span>，显然，这是HNP-2H，那么我们可以通过上面讲的方法来将其约化为HNP来求解，有<span class="math inline">\(A_i=R_i^{-1}S_i\mod{p}\)</span>，<span class="math inline">\(\gamma_{i}=r_i+A_is_i\)</span>，<span class="math inline">\(\alpha_i&#39;= R_i^{-1}Q_i\mod{p}\)</span>，<span class="math inline">\(\beta_i&#39;=R_i^{-1}C_i\mod{p}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），可以将方程<span class="math inline">\(C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\)</span>变为： <span class="math display">\[\alpha_i&#39;m+\gamma_i\equiv \beta_i&#39;\pmod{p}\]</span> 由于<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，那么我们可以取<span class="math inline">\(\mu_1=\mu_2=32\)</span>，那么我们取<span class="math inline">\(B_{min}=p^{\frac{1}{2}}2^{\frac{\mu_2-\mu_i}{2}}=p^{\frac{1}{2}}\)</span>，则可以利用连分数计算出满足条件的<span class="math inline">\(\lambda_{i,B_{min}}\)</span>，算法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在求出<span class="math inline">\(\lambda_{i,B_{min}}\)</span>之后，我们可以得到： <span class="math display">\[k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{p}=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{33}\rfloor\right)\mod{p}\]</span> 可以得到<span class="math inline">\(\{k_1,k_2,\cdots,k_d\}\)</span>的上界<span class="math inline">\(K=p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}=p^{\frac{1}{2}}2^{34}\)</span>.这样我们就可以将这个问题约化为一般的HNP进行求解，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Q = [...]</span><br><span class="line">R = [...]</span><br><span class="line">S = [...]</span><br><span class="line">C = [...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">len</span>(Q)</span><br><span class="line">A = []</span><br><span class="line">B = p.isqrt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    a = inverse(R[i], p) * S[i] % p</span><br><span class="line">    A.append(a)</span><br><span class="line"></span><br><span class="line">alpha = []</span><br><span class="line">beta = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    lambda_i = getLambda(A[i])</span><br><span class="line">    a = inverse(R[i], p) * Q[i] * lambda_i % p</span><br><span class="line">    b = (inverse(R[i], p) * C[i] * lambda_i + floor(B * <span class="number">2</span>^<span class="number">33</span>)) % p</span><br><span class="line">    alpha.append(a)</span><br><span class="line">    beta.append(b)</span><br><span class="line"></span><br><span class="line">K = p.isqrt() * <span class="number">2</span>^<span class="number">34</span></span><br><span class="line"></span><br><span class="line">L = matrix(QQ, d+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    L[i, i] = p</span><br><span class="line">    L[-<span class="number">2</span>, i] = alpha[i]</span><br><span class="line">    L[-<span class="number">1</span>, i] = beta[i]</span><br><span class="line"></span><br><span class="line">L[-<span class="number">2</span>, -<span class="number">2</span>] = K / p</span><br><span class="line">L[-<span class="number">1</span>, -<span class="number">1</span>] = K</span><br><span class="line"></span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line">v = res[<span class="number">1</span>]</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">abs</span>(v[-<span class="number">2</span>] * p / K))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行可得flag：<code>CCTF&#123;3X7eNdED_H!dD3n_nNm8eR_pR0Bl3m_iN_CCTF!!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>已知两质因数半数以上随机位的大整数分解</title>
      <link href="/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/"/>
      <url>/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在解决RSA问题的过程中，我们往往会需要对一个大整数<span class="math inline">\(n\)</span>进行质因数分解，在已知部分连续位的时候，我们经常会考虑使用Copper Smith方法来进行分解，但是若我们知道的是随机分散的位，Copper Smith方法将会失效，例如我们知道由两个质因数相乘得到的一个大整数<span class="math inline">\(n=pq\)</span>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span><br></pre></td></tr></table></figure><p>又已知<span class="math inline">\(p\)</span>的部分已知位（二进制表示，其中下划线为未知位，下同）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___</span><br></pre></td></tr></table></figure><p>与<span class="math inline">\(q\)</span>的部分已知位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___</span><br></pre></td></tr></table></figure><p>显然，我们不能使用Copper Smith方法进行分解。</p><p>为应对这种情况，大佬y011d4在Github上发布了一个项目：<a href="https://github.com/y011d4/factor-from-random-known-bits">y011d4/factor-from-random-known-bits</a>，我们可以使用这个项目对上述的情况进行分解。</p><p>下载方法（推荐Linux）：</p><ul><li><p>首先确保系统中有Rust环境（因为这个项目主要是由Rust语言编写的）</p></li><li>使用<code>git clone https://github.com/y011d4/factor-from-random-known-bits.git</code>从Github上将该项目拉下来</li><li><p><code>cd factor-from-random-known-bits</code>进入项目文件夹后依次运行<code>pip install -r requirements.txt</code>以及<code>python setup.py install</code></p></li></ul><p>在此之后就可以通过在Python中<code>import factor</code>后使用这个方法进行分解了。</p><blockquote><p>假若安装时报错，则有可能是系统中缺少 <code>m4</code> 这个宏处理器，可以通过<code>sudo apt-get install m4</code>来安装这个宏处理器.</p></blockquote><h2 id="适用条件">适用条件</h2><ul><li>已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位</li></ul><h2 id="使用方法">使用方法</h2><p>这个库有两种使用方法：<code>from_str</code>以及<code>from_vector</code></p><h3 id="from_str"><code>from_str</code></h3><p>以前面的数据为例，则可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = <span class="string">&quot;1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___&quot;</span></span><br><span class="line">q_known = <span class="string">&quot;110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___&quot;</span></span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">8996460061304658501483536370547552107653796408964122401908135206811298639114618429412462572834106148254319079697639081615546751035691609086377055207530819</span></span><br><span class="line">q = <span class="number">11577771027337574615881755252249566401199602697310825312674761422549781992489861876313558348484109945826438743090783573542794191930931862927421766237119653</span></span><br></pre></td></tr></table></figure><p>在这里，我们将未知的位置为下划线。</p><h3 id="from_vector"><code>from_vector</code></h3><p>以前面的数据为例，也可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">q_known = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到相同的结果。</p><p>在这种用法中，我们将未知的位设置为-1</p><blockquote><p>注意：虽然适用条件中说已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位就能使用，但是在某次测试中发现<span class="math inline">\(p\)</span>与<span class="math inline">\(q\)</span>均已知50.05%的位的时候其实是用不了的，这种时候就要通过爆破来知道尽可能多的位。</p></blockquote><h2 id="使用例bcactf-5.0-superstitious-2">使用例：[BCACTF 5.0 Superstitious 2]</h2><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myGetPrime</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = getRandomNBitInteger(<span class="number">1024</span>) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">1024</span>) - <span class="number">1</span>)//<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(x):</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">p = myGetPrime()</span><br><span class="line">q = myGetPrime()</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">m = bytes_to_long(message.read())</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;superstitious-2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>).write(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>\ne = <span class="subst">&#123;e&#125;</span>\nc = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以知道<code>((1 &lt;&lt; 1024) - 1)//3</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101</span><br></pre></td></tr></table></figure><p>所以我们可以知道<span class="math inline">\(p\)</span>以及<span class="math inline">\(q\)</span>约半数的位为0，以及最低位为1（因为<span class="math inline">\(p\)</span>,<span class="math inline">\(q\)</span>必为奇数），所以我们将除了最低位的所有1都替换为下划线后通过Cyberchef统计之后可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325392.png" alt="image-20241127232058419" /><figcaption>image-20241127232058419</figcaption></figure><p>有50.05%的位已知，显然可以利用本文说的方法来进行分解，但是实际操作发现只知道这么多位并不能直接分解<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>，所以我们需要对<span class="math inline">\(p\)</span>进行小范围爆破，所以我们可以通过如下脚本来进行求解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">550201148354755741271315125069984668413716061796183554308291706476140978529375848655819753667593579308959498512392008673328929157581219035186964125404507736120739215348759388064536447663960474781494820693212364523703341226714116205457869455356277737202439784607342540447463472816215050993875701429638490180199815506308698408730404219351173549572700738532419937183041379726568197333982735249868511771330859806268212026233242635600099895587053175025078998220267857284923478523586874031245098448804533507730432495577952519158565255345194711612376226297640371430160273971165373431548882970946865209008499974693758670929</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">12785320910832143088122342957660384847883123024416376075086619647021969680401296902000223390419402987207599720081750892719692986089224687862496368722454869160470101334513312534671470957897816352186267364039566768347665078311312979099890672319750445450996125821736515659224070277556345919426352317110605563901547710417861311613471239486750428623317970117574821881877688142593093266784366282508041153548993479036139219677970329934829870592931817113498603787339747542136956697591131562660228145606363369396262955676629503331736406313979079546532031753085902491581634604928829965989997727970438591537519511620204387132</span></span><br><span class="line"></span><br><span class="line">binlist = []</span><br><span class="line">s = <span class="string">&quot;_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_01&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    b = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    ns = <span class="built_in">list</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        ns[<span class="number">2</span>*i] = b[i]</span><br><span class="line">    binlist.append(<span class="string">&quot;&quot;</span>.join(ns))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pknown <span class="keyword">in</span> tqdm.tqdm(binlist):</span><br><span class="line">    ps = factor.from_str(n, pknown, s)</span><br><span class="line">    <span class="keyword">if</span> ps != <span class="literal">None</span>:</span><br><span class="line">        p, q = ps</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = inverse(e, phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在这里，我们通过爆破<span class="math inline">\(p\)</span>的高16位中的8个未知位将<span class="math inline">\(p\)</span>的已知位提升了8位，将补充的位全部置0再进行统计可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325083.png" alt="image-20241127232521024" /><figcaption>image-20241127232521024</figcaption></figure><p>这时候<span class="math inline">\(p\)</span>的已知部分变成了50.83%，应该可以进行有效分解了。运行脚本之后我们就可以得到flag：</p><blockquote><p>bcactf{l4zy_cHall3nG3_WRITinG_f8b335319e464}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>若尔当标准型与矩阵离散对数问题</title>
      <link href="/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><del>想写这篇好久了，一直没空，考完期末水一下</del></p><h2 id="第一部分：若尔当标准型概述"><a href="#第一部分：若尔当标准型概述" class="headerlink" title="第一部分：若尔当标准型概述"></a>第一部分：若尔当标准型概述</h2><blockquote><p>参考资料：《高等代数（第五版）》（北京大学数学系前代数小组 编）:P213-P219,P236-P239</p></blockquote><p><strong>定义：</strong>形为</p><script type="math/tex; mode=display">\pmb{J}(\lambda_0,k)=\left(\begin{matrix}\lambda_0&0&0&\cdots&0&0&0\\1&\lambda_0&0&\cdots&0&0&0\\0&1&\lambda_0&\cdots&0&0&0\\\vdots&\vdots&\vdots& &\vdots&\vdots&\vdots\\0&0&0&\cdots&1&\lambda_0&0\\0&0&0&\cdots&0&1&\lambda_0\end{matrix}\right)_{k×k}</script><p>的矩阵称为<strong>若尔当块</strong>，其中$\lambda_0$为复数.由若干个若尔当块组成的准对角矩阵</p><script type="math/tex; mode=display">\pmb{A}=\left(\begin{matrix}\pmb{J}(\lambda_1,k_1)&&&\\&\pmb{J}(\lambda_2,k_2)&&\\&&\ddots&&\\&&&\pmb{J}(\lambda_s,k_s)\end{matrix}\right)</script><p>称为<strong>若尔当形矩阵</strong>，其中$\lambda_1,\lambda_2,\cdots,\lambda_s$为复数，有一些可以相同.</p><p>例如矩阵</p><script type="math/tex; mode=display">\pmb{A}=\left(\begin{matrix}1&0&0\\1&1&0\\0&1&1\end{matrix}\right)=\pmb{J}(1,3)</script><p>为若尔当形矩阵（同时它也是一个若尔当块）.</p><p>下面给出的是跟若尔当形矩阵相关的一个重要结论，也是后面通过若尔当形矩阵解决矩阵离散对数问题的重要理论支撑.</p><p><strong>定理：</strong>每个$n$阶复矩阵$\pmb{A}$一定与一个若尔当形矩阵相似.这个若尔当形矩阵除去其中若尔当块的排列顺序外由$\pmb{A}$唯一确定，我们称该若尔当形矩阵为$\pmb{A}$的<strong>若尔当标准型</strong>.而若尔当标准型中主对角线上元素为$\pmb{A}$的所有特征值.</p><p>由上述定理我们可以知道：对于复矩阵$\pmb{A}$的若尔当标准型$\pmb{J}$，必存在一可逆矩阵$\pmb{P}$，使得$\pmb{J}=\pmb{P}^{-1}\pmb{A}\pmb{P}$.</p><p>实际上，对于上面的若尔当形矩阵：</p><script type="math/tex; mode=display">\pmb{A}=\left(\begin{matrix}\pmb{J}(\lambda_1,k_1)&&&\\&\pmb{J}(\lambda_2,k_2)&&\\&&\ddots&&\\&&&\pmb{J}(\lambda_s,k_s)\end{matrix}\right)</script><p>其转置$\pmb{A}^T$也可被称为若尔当形矩阵，例如对于矩阵</p><script type="math/tex; mode=display">\pmb{A}=\left(\begin{matrix}1&0&0\\1&1&0\\0&1&1\\\end{matrix}\right)</script><p>矩阵$\pmb{A}^T=\left(\begin{matrix}1&amp;1&amp;0\\0&amp;1&amp;1\\0&amp;0&amp;1\end{matrix}\right)$也是若尔当形矩阵.</p><p>下面介绍一种求矩阵的若尔当标准型的方法——通过矩阵的特征值求出其若尔当标准型：</p><p>第一步：对于一矩阵$\pmb{A}_{n×n}$，求出其特征值$\lambda_1,\lambda_2,\cdots,\lambda_s$；</p><p>第二步：求出每个特征值的几何重数（相等特征值只需求一次，表示该特征值对应的若尔当块的个数），其中对于特征值$\lambda_i$，几何重数为$n-r(\lambda_i\pmb{I}-\pmb{A})$</p><p>第三步：求每个特征值对应的若尔当块的最大阶数，即找到特征值$\lambda_i$对应的一个值$k_i$，使得$k_i$为满足$r[(\lambda_i\pmb{I}-\pmb{A})^{k_i}]=r[(\lambda_i\pmb{I}-\pmb{A})^{k_i+1}]$的最小正整数</p><p>举个例子，对矩阵$\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)$，求其对应的若尔当标准型：</p><p>第一步，求矩阵$\pmb{A}$对应的特征值，即解方程$det(\lambda \pmb{I}-A)=0$，解得唯一解$\lambda=3$；</p><p>第二步，对唯一特征值$\lambda=3$，有$3\pmb{I}-\pmb{A}=\left(\begin{matrix}-6&amp;0&amp;36\-6&amp;3&amp;27\\0&amp;-1&amp;3\end{matrix}\right)\sim\left(\begin{matrix}1&amp;0&amp;-6\\0&amp;1&amp;-3\\0&amp;0&amp;0\end{matrix}\right)$，所以其几何重数为$3-r(3\pmb{I}-\pmb{A})=1$，所以特征值$\lambda=3$对应的若尔当块的个数为$1$；</p><p>第三步：对$3\pmb{I}-\pmb{A}$有$r[(3\pmb{I}-\pmb{A})^1]=2,r[(3\pmb{I}-\pmb{A})^2]=1,r[(3\pmb{I}-\pmb{A})^3]=0,r[(3\pmb{I}-\pmb{A})^4]=0$，所以该特征值对应的若尔当块的最大阶数为$3$，所以$\lambda=3$对应的一个三阶的若尔当块$\pmb{J}(3,3)=\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)$或者$\pmb{J}(3,3)=\left(\begin{matrix}3&amp;0&amp;0\\1&amp;3&amp;0\\0&amp;1&amp;3\end{matrix}\right)$，所以矩阵$\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)$对应的若尔当标准型为$\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)$或者$\left(\begin{matrix}3&amp;0&amp;0\\1&amp;3&amp;0\\0&amp;1&amp;3\end{matrix}\right)$.</p><p>由于本文主要讨论的是通过若尔当标准型求解矩阵的离散对数问题，所以就不再深入介绍若尔当标准型了。</p><p>在这一部分的最后，我们介绍sage中求方阵的若尔当标准型的方法，这个在后面也会用到：</p><p>在sage中有函数<code>jordan_form()</code>，其作用是返回<code>self</code>的若尔当标准型，其函数原型为<code>jordan_form(subdivide=True,transformation=False)</code>，其接收三个参数，分别为一个方阵<code>self</code>，一个布尔型变量<code>subdivide</code>（默认为<code>True</code>），一个布尔型变量<code>transformation</code>（默认为<code>False</code>）。</p><p>若<code>subdivide=True</code>，则返回的矩阵中会根据若尔当块进行分块标出.</p><p>若<code>transformation=True</code>，则会返回一个矩阵组<code>(J,P)</code>，其中<code>J</code>为<code>self</code>的若尔当标准型，而<code>P</code>为使得$self=\pmb{P}\pmb{J}\pmb{P}^{-1}$成立的方阵；若<code>transformation=False</code>，则只会返回<code>self</code>的若尔当标准型<code>J</code>.</p><p>例：求矩阵$\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)$的若尔当标准型$\pmb{J}$并求矩阵$\pmb{P}$使得$\pmb{P}^{-1}\pmb{A}\pmb{P}=\pmb{J}$</p><p>sage代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sage: A = [[9,0,-36],[6,0,-27],[0,1,0]]</span><br><span class="line">sage: J,P = matrix(A).jordan_form(subdivide = False,transformation = True)</span><br><span class="line">sage: J</span><br><span class="line">[3 1 0]</span><br><span class="line">[0 3 1]</span><br><span class="line">[0 0 3]</span><br><span class="line">sage: P</span><br><span class="line">[36  6  1]</span><br><span class="line">[18  6  0]</span><br><span class="line">[ 6  0  0]</span><br><span class="line">sage: P^-1 * matrix(A) * P</span><br><span class="line">[3 1 0]</span><br><span class="line">[0 3 1]</span><br><span class="line">[0 0 3]</span><br></pre></td></tr></table></figure><p>可以得出矩阵$\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)$的若尔当标准型为$\pmb{J}=\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)$，且有矩阵$\pmb{P}=\left(\begin{matrix}36&amp;6&amp;1\\18&amp;6&amp;0\\6&amp;0&amp;0\end{matrix}\right)$使得$\pmb{P}^{-1}\pmb{A}\pmb{P}=\pmb{J}$.</p><h2 id="第二部分：利用若尔当标准型解决矩阵离散对数问题"><a href="#第二部分：利用若尔当标准型解决矩阵离散对数问题" class="headerlink" title="第二部分：利用若尔当标准型解决矩阵离散对数问题"></a>第二部分：利用若尔当标准型解决矩阵离散对数问题</h2><p>在解决矩阵离散对数问题之前，我们先要了解何谓矩阵离散对数：在有限域$GF(p)$（$p$为质数）中，已知$n$阶矩阵$\pmb{G}$和$\pmb{H}$，满足$\pmb{G}^x=\pmb{H}$，求其中$x$的问题即为矩阵的离散对数问题.</p><p>由上面的部分我们可以知道，对于矩阵$\pmb{G}$，存在一个可逆矩阵$\pmb{P}$使得$\pmb{G}=\pmb{P}\pmb{J}\pmb{P}^{-1}$，其中矩阵$\pmb{J}$为$\pmb{G}$对应的若尔当标准型，那么我们可以知道：</p><script type="math/tex; mode=display">\pmb{G}^x=(\pmb{P}\pmb{J}\pmb{P}^{-1})(\pmb{P}\pmb{J}\pmb{P}^{-1}\cdots\pmb{P}\pmb{J}\pmb{P}^{-1})=\pmb{P}\pmb{J}\pmb{P}^{-1}\pmb{P}\pmb{J}\pmb{P}^{-1}\cdots\pmb{P}\pmb{J}\pmb{P}^{-1}=\pmb{P}\pmb{J}^x\pmb{P}^{-1}</script><p>其中：</p><script type="math/tex; mode=display">\pmb{J}=\left(\begin{matrix}\pmb{J}_1&&&\\&\pmb{J}_2&&\\&&\ddots&\\&&&\pmb{J}_s\end{matrix}\right)</script><p>（$\pmb{J}_1,\pmb{J}_2,\cdots,\pmb{J}_s$均为若尔当块）</p><p>由于$\pmb{J}$为准对角矩阵，我们有：</p><script type="math/tex; mode=display">\pmb{J}^n=\left(\begin{matrix}\pmb{J}_1&&&\\&\pmb{J}_2&&\\&&\ddots&\\&&&\pmb{J}_s\end{matrix}\right)^n=\left(\begin{matrix}\pmb{J}_1^n&&&\\&\pmb{J}_2^n&&\\&&\ddots&\\&&&\pmb{J}_s^n\end{matrix}\right)</script><p>对于任意若尔当块</p><script type="math/tex; mode=display">\pmb{J}(\lambda,k)=\left(\begin{matrix}\lambda&1&0&\cdots&0&0&0\\0&\lambda&1&\cdots&0&0&0\\0&0&\lambda&\cdots&0&0&0\\\vdots&\vdots&\vdots& &\vdots&\vdots&\vdots\\0&0&0&\cdots&0&\lambda&1\\0&0&0&\cdots&0&0&\lambda\end{matrix}\right)_{k×k}</script><p>而若尔当块可以分为两部分：</p><script type="math/tex; mode=display">\pmb{J}(\lambda,k)=\pmb{\Lambda}+\pmb{E}=\left(\begin{matrix}\lambda&&&\\&\lambda&&\\&&\ddots&\\&&&\lambda\end{matrix}\right)+\left(\begin{matrix}0&1&0&\cdots&0&0\\0&0&1&\cdots&0&0\\0&0&0&\cdots&0&0\\\vdots&\vdots&\vdots&&\vdots&\vdots\\0&0&0&\cdots&0&1\\0&0&0&\cdots&0&0\end{matrix}\right)</script><p>所以</p><script type="math/tex; mode=display">\pmb{J}(\lambda,k)^n=(\pmb{\Lambda}+\pmb{E})^n=\sum_{m=0}^{n}\left(\begin{matrix}n\\m\end{matrix}\right)\pmb{\Lambda}^{n-m}\pmb{E}^m</script><p>而我们很容易可以知道：</p><script type="math/tex; mode=display">\pmb{E}=\left(\begin{matrix}0&1&0&\cdots&0&0\\0&0&1&\cdots&0&0\\0&0&0&\cdots&0&0\\\vdots&\vdots&\vdots&&\vdots&\vdots\\0&0&0&\cdots&0&1\\0&0&0&\cdots&0&0\end{matrix}\right),\pmb{E}^2=\left(\begin{matrix}0&0&1&\cdots&0&0\\0&0&0&\cdots&0&0\\0&0&0&\cdots&0&0\\\vdots&\vdots&\vdots&&\vdots&\vdots\\0&0&0&\cdots&0&0\\0&0&0&\cdots&0&0\end{matrix}\right),\cdots,\pmb{E}^{k-1}=\left(\begin{matrix}0&0&0&\cdots&0&1\\0&0&0&\cdots&0&0\\0&0&0&\cdots&0&0\\\vdots&\vdots&\vdots&&\vdots&\vdots\\0&0&0&\cdots&0&0\\0&0&0&\cdots&0&0\end{matrix}\right),\pmb{E}^k=\pmb{O}</script><p>所以$\pmb{J}(\lambda,k)^n=\left(\begin{matrix}n\\0\end{matrix}\right)\pmb{\Lambda}^n+\left(\begin{matrix}n\\1\end{matrix}\right)\pmb{\Lambda}^{n-1}\pmb{E}+\cdots+\left(\begin{matrix}n\\k-1\end{matrix}\right)\pmb{\Lambda}^{n-k+1}\pmb{E}^{k-1}$</p><p>可得：</p><script type="math/tex; mode=display">\pmb{J}(\lambda,k)^n=\left[\begin{matrix}\lambda^n&n\lambda^{n-1}&\frac{n(n-1)}{2}\lambda^{n-2}&\cdots&\left(\begin{matrix}n\\k-2\end{matrix}\right)\lambda^{n-k+2}&\left(\begin{matrix}n\\k-1\end{matrix}\right)\lambda^{n-k+1}\\0&\lambda^n&n\lambda^{n-1}&\cdots&\left(\begin{matrix}n\\k-3\end{matrix}\right)\lambda^{n-k+3}&\left(\begin{matrix}n\\k-2\end{matrix}\right)\lambda^{n-k+2}\\0&0&\lambda^{n}&\cdots&\left(\begin{matrix}n\\k-4\end{matrix}\right)\lambda^{n-k+4}&\left(\begin{matrix}n\\k-3\end{matrix}\right)\lambda^{n-k+3}\\\vdots&\vdots&\vdots&&\vdots&\vdots\\0&0&0&\cdots&\lambda^{n}&n\lambda^{n-1}\\0&0&0&\cdots&0&\lambda^{n}\end{matrix}\right]</script><p>对于一般的矩阵离散对数问题，即给出有限域$GF(p)$下两个矩阵$\pmb{G}$和$\pmb{H}$，求满足$\pmb{G}^x=\pmb{H}$的整数$x$，我们可以直接对比两个矩阵进行求解即可，大致步骤如下：</p><p>先求$\pmb{G}$的若尔当标准型$\pmb{J}$并求可逆矩阵$\pmb{P}$使得$\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}$，由于$\pmb{H}=\pmb{G}^x=(\pmb{P}\pmb{J}\pmb{P}^{-1})^x=\pmb{P}\pmb{J}^{x}\pmb{P}^{-1}$，所以有$\pmb{P}^{-1}\pmb{H}\pmb{P}=\pmb{J}^x$，取矩阵$\pmb{J}$其中一个阶数大于等于$2$的若尔当块$\pmb{J}(\lambda,k)$，在矩阵$\pmb{P}^{-1}\pmb{H}\pmb{P}$取该若尔当块对应区域中最后两行的最后一个元素，实际上就是$\pmb{J}(\lambda,k)^x$最后两行中的$\lambda^x$与$x\lambda^{x-1}$（由上面的矩阵可以得知），从而有：</p><script type="math/tex; mode=display">\frac{x\lambda^{x-1}}{\lambda^{x}}\equiv \frac{x}{\lambda}\equiv x\lambda^{-1}\pmod{p}</script><p>由于我们知道该若尔当块对应的特征值$\lambda$，所以我们就可以通过乘上一个$\lambda$求出我们需要的$x$.</p><p>举个例子，当$p=31$时，在$GF(p)$下有矩阵$\pmb{G}=\left(\begin{matrix}17&amp;0&amp;6\\0&amp;3&amp;0\\9&amp;0&amp;18\end{matrix}\right)$，且有$\pmb{H}=\pmb{G}^x=\left(\begin{matrix}25&amp;0&amp;3\\0&amp;28&amp;0\\20&amp;0&amp;10\end{matrix}\right)$，求$x$.</p><p>先求出$\pmb{G}$的若尔当标准型$\pmb{J}$及使得$\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}$成立的矩阵$\pmb{P}$如下（此处为了减少篇幅使用sage求两个矩阵）：</p><script type="math/tex; mode=display">\pmb{J}=\left(\begin{matrix}3&0&0\\0&2&1\\0&0&2\end{matrix}\right),\pmb{P}= \left(\begin{matrix}0&15&1\\1&0&0\\0&9&0\end{matrix}\right)</script><p>通过$\pmb{P}$求出$\pmb{J}^x=\pmb{P}^{-1}\pmb{H}\pmb{P}=\left(\begin{matrix}28&amp;0&amp;0\\0&amp;2&amp;16\\0&amp;0&amp;2\end{matrix}\right)$，由于$\pmb{J}$中有一个2阶的若尔当块$\left(\begin{matrix}2&amp;1\\0&amp;2\end{matrix}\right)$，其对应的$\pmb{G}$的特征值为$\lambda=2$，所以取$\pmb{J}^x$中对应的块$\left(\begin{matrix}2&amp;16\\0&amp;2\end{matrix}\right)$，有:</p><script type="math/tex; mode=display">8\equiv x\lambda^{-1}\pmod{p}</script><p>两边同乘一个$\lambda=2$可得$x\equiv16\pmod{31}$.</p><p>此类矩阵离散对数问题的求解代码模板如下（假设若尔当形矩阵$\pmb{J}$最右下角一个若尔当块阶数大于$2$）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = []</span><br><span class="line">H = []</span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">n = <span class="comment">#矩阵的阶数</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">M_H = matrix(GF(p),H)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">M_H_trans = P**-<span class="number">1</span> * M_H * P</span><br><span class="line"></span><br><span class="line">x = lambda0 * M_H_trans[n-<span class="number">2</span>][n-<span class="number">1</span>] * inverse(<span class="built_in">int</span>(M_H_trans[n-<span class="number">1</span>][n-<span class="number">1</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一种类型的矩阵离散对数问题，即为给出$GF(p)$下的矩阵$\pmb{G}$及一个初始向量$\pmb{v}$，且给出$\pmb{y}=\pmb{G}^x\pmb{v}$，求$x$.对于这种类型的矩阵离散对数的求解大致步骤如下：</p><p>设$\pmb{v}=\left(v_1,v_2,\cdots,v_n\right)^T,\pmb{y}=\left(y_1,y_2,\cdots,y_n\right)^T$，求出矩阵$\pmb{G}$的若尔当标准型$\pmb{J}$并求可逆矩阵$\pmb{P}$使得$\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}$.为方便解释，在这里我们假定$\pmb{G}$的若尔当标准型$\pmb{P}$的最右下角的若尔当块阶数大于等于$2$（实际上，一个矩阵的若尔当标准型可以通过若尔当块的顺序来变成该矩阵的另外一个若尔当标准型）.</p><p>所以有：</p><script type="math/tex; mode=display">\pmb{G}^x\pmb{v}=\pmb{P}\pmb{J}^x\pmb{P}^{-1}\pmb{v}=\pmb{y}</script><p>设$\pmb{t}=\pmb{P}^{-1}\pmb{v}，\pmb{z}=\pmb{P}^{-1}\pmb{y}$，就可以得到：$\pmb{P}\pmb{J}^x\pmb{t}=\pmb{P}\pmb{z}$，而由于矩阵$\pmb{P}$可逆，则有$\pmb{J}^x\pmb{t}=\pmb{z}$.</p><p>由于我们已知$\pmb{v}$及$\pmb{y}$，所以我们可以通过$\pmb{P}$求出$\pmb{t}$及$\pmb{z}$，在这里我们设$\pmb{t}=\left(t_1,t_2,\cdots,t_n\right)^T,\pmb{z}=\left(z_1,z_2,\cdots,z_n\right)^T$，由于上面我们假设了$\pmb{J}$最右下角的若尔当块的阶数大于等于$2$，在这里我们假设它对应的特征值为$\lambda$，就可以得出若尔当标准型$\pmb{J}$最后两行对应的线性关系为：</p><script type="math/tex; mode=display">\begin{cases}\lambda^{x}t_{n-1}&+&x\lambda^{x-1}t_n&\equiv&z_{n-1}&\pmod{p}\\&&\lambda^xt_n&\equiv&z_n&\pmod{p}\end{cases}</script><p>我们可以知道$\lambda^{x}\equiv\frac{z_n}{t_n}\pmod{p}$，代入第一行的式子可以得到：</p><script type="math/tex; mode=display">\frac{z_nt_{n-1}}{t_n}+\frac{xz_n}{\lambda}\equiv z_{n-1}\pmod{p}</script><p>整理可得：</p><script type="math/tex; mode=display">x\equiv\frac{\lambda(z_{n-1}t_n-z_nt_{n-1})}{t_nz_n}\pmod{p}</script><p>这样我们就可以求出我们要求的$x$了.</p><p>例如，当$p=31$时，在$GF(p)$下有矩阵$\pmb{G}=\left(\begin{matrix}17&amp;0&amp;6\\0&amp;3&amp;0\\9&amp;0&amp;18\end{matrix}\right)$，且有$\pmb{v}=(1,2,3)^T$，有$\pmb{G}^x\pmb{v}=\pmb{y}=(13,30,25)^T$，求$x$.</p><p>这个矩阵$\pmb{G}$的若尔当标准型$\pmb{J}$和对应的矩阵$\pmb{P}$在上面已经求出，所以这里我们直接搬下来用：</p><script type="math/tex; mode=display">\pmb{J}=\left(\begin{matrix}3&0&0\\0&2&1\\0&0&2\end{matrix}\right),\pmb{P}= \left(\begin{matrix}0&15&1\\1&0&0\\0&9&0\end{matrix}\right)</script><p>所以有$\pmb{t}=\pmb{P}^{-1}\pmb{v}=(2,21,27)^T，\pmb{z}=\pmb{P}^{-1}\pmb{y}=(30,20,23)^T$，而矩阵$\pmb{J}$的最右下角的若尔当块对应的特征值$\lambda=2$，所以有：</p><script type="math/tex; mode=display">x\equiv\frac{\lambda(z_{2}t_3-z_3t_{2})}{t_3z_3}\equiv\frac{2\cdot(20\cdot27-23\cdot21)}{27\cdot23}\equiv21\pmod{31}</script><p>所以可以得出要求的$x = 21$.</p><p>此类矩阵离散对数问题的求解代码模板如下（假设若尔当形矩阵$\pmb{J}$最右下角一个若尔当块阶数大于$2$）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = []</span><br><span class="line">V = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line">p = <span class="number">31</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">v = matrix(GF(p),V)</span><br><span class="line">y = matrix(GF(p),Y)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line">t = P**-<span class="number">1</span> * v</span><br><span class="line">z = P**-<span class="number">1</span> * y</span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x = lambda0 * (t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">2</span>][<span class="number">0</span>] - t[n-<span class="number">2</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]) * inverse(<span class="built_in">int</span>(t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>还有一种特殊情况就是$\pmb{G}^x=\pmb{H}$中$\pmb{G}$的若尔当标准型为对角矩阵.这种情况实际上只需要求出$\pmb{G}$的标准型$\pmb{J}$与其对应的$\pmb{P}$之后，通过$\pmb{P}^{-1}\pmb{H}\pmb{P}$求出$\pmb{J}^x$，再通过求解整数的离散对数问题的方法求解就行（实际上应该只有这一种方法）.</p><p>下面通过一道题展示一下矩阵离散对数在密码学上的应用：</p><h3 id="XYCTF2024-fakeRSA"><a href="#XYCTF2024-fakeRSA" class="headerlink" title="[XYCTF2024]fakeRSA"></a>[XYCTF2024]fakeRSA</h3><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;XYCTF&#123;******&#125;&#x27;</span></span><br><span class="line">n = ZZ(bytes_to_long(flag))</span><br><span class="line">p = getPrime(<span class="built_in">int</span>(<span class="number">320</span>))</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line">G = Zmod(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">X, Y, Z</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">part</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> vector([<span class="number">9</span> * a - <span class="number">36</span> * c, <span class="number">6</span> * a - <span class="number">27</span> * c, b])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parts</span>(<span class="params">n</span>):</span><br><span class="line">        Gx.&lt;a, b, c&gt; = G[]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> vector([a, b, c])</span><br><span class="line">        mid = parts(n // <span class="number">2</span>)</span><br><span class="line">        result = mid(*mid)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> part(*result)</span><br><span class="line">    <span class="keyword">return</span> parts(n)(X, Y, Z)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(function(<span class="number">69</span>, <span class="number">48</span>, <span class="number">52</span>))</span><br><span class="line"><span class="comment">#输出数据略</span></span><br></pre></td></tr></table></figure><p>由代码可以看出function的作用是在$GF(p)$中对向量$(X,Y,Z)^T$进行$n$次变换$(X’,Y’,Z’)^T=(9X-36Z,6X-27Z,Y)^T$后得到输出的向量，写出变换的矩阵形式如下：</p><script type="math/tex; mode=display">\left(\begin{matrix}9&0&-36\\6&0&-27\\0&1&0\end{matrix}\right)\left(\begin{matrix}X\\Y\\Z\end{matrix}\right)=\left(\begin{matrix}X'\\Y'\\Z'\end{matrix}\right)</script><p>设原向量为$(x_1,x_2,x_3)^T$，最终向量为$(y_1,y_2,y_3)^T$，则有：</p><script type="math/tex; mode=display">\left(\begin{matrix}9&0&-36\\6&0&-27\\0&1&0\end{matrix}\right)^n\left(\begin{matrix}x_1\\x_2\\x_3\end{matrix}\right)=\left(\begin{matrix}y_1\\y_2\\y_3\end{matrix}\right)</script><p>通过上面介绍的方法求解即可得出$n$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = [[<span class="number">9</span>,<span class="number">0</span>,-<span class="number">36</span>],[<span class="number">6</span>,<span class="number">0</span>,-<span class="number">27</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">V = [[<span class="number">69</span>],[<span class="number">48</span>],[<span class="number">52</span>]]</span><br><span class="line">Y = ...<span class="comment">#题目中输出的向量</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">1849790472911267366045392456893126092698743308291512220657006129900961168811898822553602045875909</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">v = matrix(GF(p),V)</span><br><span class="line">y = matrix(GF(p),Y)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line">t = P**-<span class="number">1</span> * v</span><br><span class="line">z = P**-<span class="number">1</span> * y</span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x = lambda0 * (t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">2</span>][<span class="number">0</span>] - t[n-<span class="number">2</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]) * inverse(<span class="built_in">int</span>(t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(x)))</span><br></pre></td></tr></table></figure><p>运行可得结果：<code>XYCTF&#123;y0u_finally_f0und_t3h_s3cr3ts!!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 高等代数笔记 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XYCTF2024-疯狂大杂烩！九转功成复现WP</title>
      <link href="/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/"/>
      <url>/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你能突破九大关卡修成神仙吗？</p><p>hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！</p><p>hint2：flag格式：XYCTF{md5(flag)}</p><p>hint3：第三层非夏多，看看交点</p><p>hint4：第六层键盘画图，狼蛛键盘最新版你值得拥有！</p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>由提示猜测压缩包密码XYCTF20240401</p><h1 id="炼气"><a href="#炼气" class="headerlink" title="炼气"></a>炼气</h1><p>第一层是天书加密，用随波逐流就可以解出压缩包密码。</p><p>第二层是一张图片，修改高就可以看到flag的第一部分：</p><blockquote><p>XYCTF{T3e_c0mb1nation_</p></blockquote><h1 id="筑基"><a href="#筑基" class="headerlink" title="筑基"></a>筑基</h1><p>第一层是<strong>BubbleBabble</strong>编码，<a href="http://www.hiencode.com/bubble.html">在线解码</a>就能解出压缩包密码。</p><p>第二层是一张图片，010看不出什么东西，用StegSolve通过LSB可以找到一串Base64编码，解码可得flag第二部分：</p><blockquote><p>0f_crypt0_and_</p></blockquote><h1 id="结丹（全复现）"><a href="#结丹（全复现）" class="headerlink" title="结丹（全复现）"></a>结丹（全复现）</h1><p>给出一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281730505.jpg" alt="hint3"></p><p>hint说看交点，可能跟Begin CTF 2023的下一站上岸差不多，四个交点为”-”，三个交点为空格，一个交点为”.”，可以转化为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- .... . ..--.- - .... .. .-. -..</span><br></pre></td></tr></table></figure><p>摩斯密码解码就可以得到压缩包的密码</p><p>打开压缩包发现还有一层压缩包和一个txt，文本文件里面没有有用信息，但是压缩包带密码，用010打开看看，看到末尾有一段附加信息：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828487.png" alt="image-20240428173027310"></p><p>分析特征，显然是Base64，解码之后可以得到压缩包密码，解压发现里面有一个文本文件，由特征可知是Base32，解码就可以得到flag的第三部分。</p><blockquote><p>misc_1s_re6lly_fun!!</p></blockquote><h1 id="元婴"><a href="#元婴" class="headerlink" title="元婴"></a>元婴</h1><p>hint4.txt打开一看发现是base64，解密一看salted，用这个网站解密：<a href="https://www.sojson.com/encrypt_triple_des.html">在线Triple DES加密 | Triple DES解密- 在线工具 (sojson.com)</a>（一个个试出来的），密码是2024.</p><p>拿密码打开压缩包，有个hint.txt和一个db文件，hint内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wqk：1m813onn17o040358p772q37rm137qpnqppqpn38nr704m56n2m9q22po7r05r77</span><br></pre></td></tr></table></figure><p>进行一个凯撒解密就可以得到一个key，</p><p>下面是在52上面找到的一个解密微信聊天数据库的脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> hashlib, hmac, ctypes</span><br><span class="line"></span><br><span class="line">SQLITE_FILE_HEADER = <span class="built_in">bytes</span>(<span class="string">&quot;SQLite format 3&quot;</span>,encoding=<span class="string">&#x27;ASCII&#x27;</span>) + <span class="built_in">bytes</span>(<span class="number">1</span>)<span class="comment">#文件头</span></span><br><span class="line">IV_SIZE = <span class="number">16</span></span><br><span class="line">HMAC_SHA1_SIZE = <span class="number">20</span></span><br><span class="line">KEY_SIZE = <span class="number">32</span></span><br><span class="line">DEFAULT_PAGESIZE = <span class="number">4096</span> <span class="comment">#4048数据 + 16IV + 20 HMAC + 12</span></span><br><span class="line">DEFAULT_ITER = <span class="number">64000</span></span><br><span class="line"><span class="comment">#yourkey</span></span><br><span class="line">password = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;...&quot;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="comment">#这里填入上面求出的key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\MSG0.db&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#这里填入MSG0.db的文件路径</span></span><br><span class="line">    blist = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(blist))</span><br><span class="line"></span><br><span class="line">salt = blist[:<span class="number">16</span>]<span class="comment">#微信将文件头换成了盐</span></span><br><span class="line">key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, password, salt, DEFAULT_ITER, KEY_SIZE)<span class="comment">#获得Key</span></span><br><span class="line"></span><br><span class="line">first = blist[<span class="number">16</span>:DEFAULT_PAGESIZE]<span class="comment">#丢掉salt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import struct</span></span><br><span class="line">mac_salt = <span class="built_in">bytes</span>([x^<span class="number">0x3a</span> <span class="keyword">for</span> x <span class="keyword">in</span> salt])</span><br><span class="line">mac_key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, key, mac_salt, <span class="number">2</span>, KEY_SIZE)</span><br><span class="line"></span><br><span class="line">hash_mac = hmac.new(mac_key ,digestmod = <span class="string">&#x27;sha1&#x27;</span>)<span class="comment">#用第一页的Hash测试一下</span></span><br><span class="line">hash_mac.update(first[:-<span class="number">32</span>])</span><br><span class="line">hash_mac.update(<span class="built_in">bytes</span>(ctypes.c_int(<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># hash_mac.update(struct.pack(&#x27;=I&#x27;,1))</span></span><br><span class="line"><span class="keyword">if</span> (hash_mac.digest() == first[-<span class="number">32</span>:-<span class="number">12</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Correct Password&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Wrong Password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">blist = [blist[i:i+DEFAULT_PAGESIZE] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_PAGESIZE,<span class="built_in">len</span>(blist),DEFAULT_PAGESIZE)]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\ChatMsg.db&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#解密后的路径</span></span><br><span class="line">    f.write(SQLITE_FILE_HEADER)<span class="comment">#写入文件头</span></span><br><span class="line">    t = AES.new(key ,AES.MODE_CBC ,first[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">    f.write(t.decrypt(first[:-<span class="number">48</span>]))</span><br><span class="line">    f.write(first[-<span class="number">48</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blist:</span><br><span class="line">            t = AES.new(key ,AES.MODE_CBC ,i[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">            f.write(t.decrypt(i[:-<span class="number">48</span>]))</span><br><span class="line">            f.write(i[-<span class="number">48</span>:])</span><br></pre></td></tr></table></figure><p>用打开数据库的软件打开解密之后的数据库（我用的Dbeaver），在MSG表里面就可以看到flag的第四部分：</p><blockquote><p>L1u_and_K1cky_Mu</p></blockquote><h1 id="化神（第二部分复现）："><a href="#化神（第二部分复现）：" class="headerlink" title="化神（第二部分复现）："></a>化神（第二部分复现）：</h1><p>hint5给出了一串字符和md5后的结果，进行爆破，爆破出压缩包密码，解压<code>第五层.zip</code> 看到flag.txt里面没有有用的东西.</p><p>serpent.txt文件里有东西，考虑serpent加密，用这个网站<a href="http://serpent.online-domain-tools.com/">Serpent Encryption – Easily encrypt or decrypt strings or files (online-domain-tools.com)</a></p><p>通过文件输入，从头到尾没有密钥，猜测密钥是前面爆破得到的key，解密之后下载下来塞进Cyberchef可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828521.png" alt="image-20240428172659005"></p><p>导出为txt并转换编码为UTF-8后可以得到：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726731.png" alt="image-20240428172642676"></p><p>字数比可以看到的多很多，考虑零宽字符隐写：</p><p>将文本转化为unicode编码后：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726082.png" alt="image-20240428172606982"></p><p>筛选发现，里面包含零宽unicode字符\u200A,\u200B,\u200C,\u202C,\uFEFF</p><p>用<a href="https://www.mzy0.com/ctftools/zerowidth1/">Unicode Steganography with Zero-Width Characters (mzy0.com)</a>解码即可得出flag的第五部分：</p><blockquote><p>_3re_so_sm4rt!</p></blockquote><h1 id="炼虚（第二部分复现）："><a href="#炼虚（第二部分复现）：" class="headerlink" title="炼虚（第二部分复现）："></a>炼虚（第二部分复现）：</h1><p>第一层是键盘画图，是一个句子，不确定的字母可以掩码爆破。</p><p>用上面得到的密码打开压缩包，可以看到一个压缩包，一个word文档，一个Excel文档，一个PPT，一个文本文件还有一张图片。除了图片之外，都没有看到有什么有用的，直接用steghide提取一下，发现要密码，发现上面几个文件名称都是数字，倒着来输一遍（98641）就是密码（纯猜谜），提取出来就可以得到flag的第六部分：</p><blockquote><p>In_just_a_few_m1nutes_</p></blockquote><h1 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h1><p>第一层UTF-7加维吉尼亚，密钥是字母表。</p><p>解开压缩包可以看到一个图片：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281724825.png" alt="flag"></p><p>就一个八进制，按颜色填数字就行，八进制转换之后就可以得到flag的第七部分：</p><blockquote><p>they_were_thr0ugh!</p></blockquote><h1 id="大乘"><a href="#大乘" class="headerlink" title="大乘"></a>大乘</h1><p>这一层的第一部分是一个RSA，显然是p^q泄露，加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line">flag=<span class="string">b&quot;password&#123;xxxxx&#125;&quot;</span></span><br><span class="line">p,q= getPrime(<span class="number">1024</span>),getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p^q=&quot;</span>,p^q)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n= 22424440693845876425615937206198156323192795003070970628372481545586519202571910046980039629473774728476050491743579624370862986329470409383215065075468386728605063051384392059021805296376762048386684738577913496611584935475550170449080780985441748228151762285167935803792462411864086270975057853459586240221348062704390114311522517740143545536818552136953678289681001385078524272694492488102171313792451138757064749512439313085491407348218882642272660890999334401392575446781843989380319126813905093532399127420355004498205266928383926087604741654126388033455359539622294050073378816939934733818043482668348065680837</span></span><br><span class="line"><span class="string">c= 1400352566791488780854702404852039753325619504473339742914805493533574607301173055448281490457563376553281260278100479121782031070315232001332230779334468566201536035181472803067591454149095220119515161298278124497692743905005479573688449824603383089039072209462765482969641079166139699160100136497464058040846052349544891194379290091798130028083276644655547583102199460785652743545251337786190066747533476942276409135056971294148569617631848420232571946187374514662386697268226357583074917784091311138900598559834589862248068547368710833454912188762107418000225680256109921244000920682515199518256094121217521229357</span></span><br><span class="line"><span class="string">p^q= 14488395911544314494659792279988617621083872597458677678553917360723653686158125387612368501147137292689124338045780574752580504090309537035378931155582239359121394194060934595413606438219407712650089234943575201545638736710994468670843068909623985863559465903999731253771522724352015712347585155359405585892</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)<span class="comment">#随便设置，但是不能不设置，增大递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_high_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp0 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq0 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tp1 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq1 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp0 * tq0 &gt; n <span class="keyword">or</span> tp1 * tq1 &lt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp0)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[lp] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_low_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp = <span class="built_in">int</span>(p, <span class="number">2</span>) <span class="keyword">if</span> p <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    tq = <span class="built_in">int</span>(q, <span class="number">2</span>) <span class="keyword">if</span> q <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp * tq % <span class="number">2</span>**lp != n % <span class="number">2</span>**lp:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[-lp-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line">mask = (<span class="number">1</span>&lt;&lt;<span class="number">1024</span>)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">leak_bits = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">leak = ...</span><br><span class="line">xor = <span class="built_in">bin</span>(leak)[<span class="number">2</span>:].zfill(<span class="number">1024</span>)</span><br><span class="line">pq = []</span><br><span class="line">pq_low_xor()</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pq:</span><br><span class="line">    <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">        q = n // p</span><br><span class="line">        phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">        d = inverse(<span class="number">65537</span>,phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>得到密码解开压缩包，可以见到一个txt，打开看到一堆no和yes，将no替换为0，yes替换为1，通过下述脚本转换为图片：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">    pic = Image.new(<span class="string">&quot;L&quot;</span>,(<span class="number">548</span>,<span class="number">72</span>))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">72</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">548</span>):</span><br><span class="line">            <span class="keyword">if</span> s[h * <span class="number">548</span> + w] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">255</span>)</span><br><span class="line">    pic.save(<span class="string">&quot;out.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828921.png" alt="out"></p><p>是须弥沙漠文，对字母表换就行，下附字母表</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281829364.png" alt="fcd8e8310bde689198d4be3e6b749f15_9129134670435119053"></p><p>换完就可以得到flag的第八部分：</p><blockquote><p>sm3rty0ucando</p></blockquote><h1 id="渡劫（第二部分复现）"><a href="#渡劫（第二部分复现）" class="headerlink" title="渡劫（第二部分复现）"></a>渡劫（第二部分复现）</h1><p>这一层的第一部分是一个RSA，很简单，加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    a, b = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">8</span>), randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">    <span class="built_in">list</span>.append(a * p + b * q)</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&quot;xxxxx&quot;</span></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(password), e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;c = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">list</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#n = 107803636687595025440095910573280948384697923215825513033516157995095253288310988256293799364485832711216571624134612864784507225218094554935994320702026646158448403364145094359869184307003058983513345331145072159626461394056174457238947423145341933245269070758238088257304595154590196901297344034819899810707</span></span><br><span class="line"><span class="comment">#c = 46049806990305232971805282370284531486321903483742293808967054648259532257631501152897799977808185874856877556594402112019213760718833619399554484154753952558768344177069029855164888168964855258336393700323750075374097545884636097653040887100646089615759824303775925046536172147174890161732423364823557122495</span></span><br><span class="line"><span class="comment">#list = [618066045261118017236724048165995810304806699407382457834629201971935031874166645665428046346008581253113148818423751222038794950891638828062215121477677796219952174556774639587782398862778383552199558783726207179240239699423569318, 837886528803727830369459274997823880355524566513794765789322773791217165398250857696201246137309238047085760918029291423500746473773732826702098327609006678602561582473375349618889789179195207461163372699768855398243724052333950197]</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line"><span class="built_in">list</span> = [..., ...]</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">for</span> a2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=<span class="number">1</span> <span class="keyword">and</span> gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=n):</span><br><span class="line">            <span class="built_in">print</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n))<span class="comment">#这里求出来是q</span></span><br><span class="line"><span class="comment">#--------part2--------</span></span><br><span class="line">q = ...</span><br><span class="line">p = n // q</span><br><span class="line"><span class="keyword">assert</span> p*q == n</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>解开压缩包就是一个带图片的压缩包和一个txt，txt内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">压缩包里的图片真的有东西吗？不如看向外面</span><br></pre></td></tr></table></figure><p>图片里面确实没有东西，由压缩包名字“我们的小秘密嘿嘿”猜测是oursecret隐写，猜测密码是上面解出来的，尝试发现是正确的，就可以得到flag的第九部分：</p><blockquote><p>_nine_turns?}</p></blockquote><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>组合之后：</p><blockquote><p>XYCTF{T3e_c0mb1nation_0f_crypt0_and_misc_1s_re6lly_fun!!L1u_and_K1cky_Mu_3re_so_sm4rt!In_just_a_few_m1nutes_they_were_thr0ugh!Sm3rt_y0u_can_do_nine_turns?}</p></blockquote><p>注意，第八段开头大写，然后要按词加下划线得到flag之后要整体用md5加密之后再包上XYCTF{}才是flag。</p>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicoCTF2024 Crypto部分WP</title>
      <link href="/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/"/>
      <url>/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/</url>
      
        <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.</p><h2 id="interencdec"><a href="#interencdec" class="headerlink" title="interencdec"></a>interencdec</h2><p>签到题</p><p>密文如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YidkM0JxZGtwQlRYdHFhR3g2YUhsZmF6TnFlVGwzWVROclgyZzBOMm8yYXpZNWZRPT0nCg==</span><br></pre></td></tr></table></figure><p>显然是Base64编码，解码得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;d3BqdkpBTXtqaGx6aHlfazNqeTl3YTNrX2g0N2o2azY5fQ==&#x27;</span><br></pre></td></tr></table></figure><p>去除<strong>b’’</strong>之后进行Base64解码结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wpjvJAM&#123;jhlzhy_k3jy9wa3k_h47j6k69&#125;</span><br></pre></td></tr></table></figure><p>进行一次偏移量为7的凯撒解密可以得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;caesar_d3cr9pt3d_a47c6d69&#125;</span><br></pre></td></tr></table></figure><h2 id="Custom-encryption"><a href="#Custom-encryption" class="headerlink" title="Custom encryption"></a>Custom encryption</h2><p>题目给出加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">g, x, p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(g, x) % p<span class="comment">#实际上就是pow(g,x,p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    cipher = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> plaintext:</span><br><span class="line">        cipher.append(((<span class="built_in">ord</span>(char) * key*<span class="number">311</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">p</span>):</span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, p + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p % i == <span class="number">0</span>:</span><br><span class="line">            v = v + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_xor_encrypt</span>(<span class="params">plaintext, text_key</span>):</span><br><span class="line">    cipher_text = <span class="string">&quot;&quot;</span></span><br><span class="line">    key_length = <span class="built_in">len</span>(text_key)</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(plaintext[::-<span class="number">1</span>]):<span class="comment">#将字符串反转后异或加密</span></span><br><span class="line">        key_char = text_key[i % key_length]</span><br><span class="line">        encrypted_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="built_in">ord</span>(key_char))</span><br><span class="line">        cipher_text += encrypted_char</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">plain_text, text_key</span>):</span><br><span class="line">    p = <span class="number">97</span></span><br><span class="line">    g = <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_prime(p) <span class="keyword">and</span> <span class="keyword">not</span> is_prime(g):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enter prime numbers&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a = randint(p-<span class="number">10</span>, p)</span><br><span class="line">    b = randint(g-<span class="number">10</span>, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line">    u = generator(g, a, p)</span><br><span class="line">    v = generator(g, b, p)</span><br><span class="line">    key = generator(v, a, p)</span><br><span class="line">    b_key = generator(u, b, p)</span><br><span class="line">    shared_key = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> key == b_key:</span><br><span class="line">        shared_key = key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)</span><br><span class="line">    cipher = encrypt(semi_cipher, shared_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;cipher is: <span class="subst">&#123;cipher&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    test(message, <span class="string">&quot;trudeau&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目给出的另一个附件如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 89</span><br><span class="line">b = 27</span><br><span class="line">cipher is: [33588, 276168, 261240, 302292, 343344, 328416, 242580, 85836, 82104, 156744, 0, 309756, 78372, 18660, 253776, 0, 82104, 320952, 3732, 231384, 89568, 100764, 22392, 22392, 63444, 22392, 97032, 190332, 119424, 182868, 97032, 26124, 44784, 63444]</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析代码可以知道有一个<code>share_key</code>，把它求出来（很简单，不知道他为什么要把<code>pow(a,b,p)</code>包装成一个新的函数）然后通过<code>cipher</code>里面每一个元素除以<code>share_key</code>和311得到一个串，跟<code>text_key</code>进行一个异或（<code>dynamic_xor_encrypt</code>）再对得到的<code>plaintext</code>进行反转。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>先求<code>share_key</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br></pre></td></tr></table></figure><p>求出<code>share_key</code>之后就可以将<code>cipher</code>除以<code>share_key</code>和311得到一个串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = [x//shared_key//<span class="number">311</span> <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br></pre></td></tr></table></figure><p>将<code>temp</code>与<code>text_key</code>进行一个异或，其中<code>text_key=&quot;trudeau&quot;</code>得到一字符串后反转就可以得到flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>总体代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">97</span></span><br><span class="line">g = <span class="number">31</span></span><br><span class="line">a = <span class="number">89</span></span><br><span class="line">b = <span class="number">27</span></span><br><span class="line">cipher = [<span class="number">33588</span>, <span class="number">276168</span>, <span class="number">261240</span>, <span class="number">302292</span>, <span class="number">343344</span>, <span class="number">328416</span>, <span class="number">242580</span>, <span class="number">85836</span>, <span class="number">82104</span>, <span class="number">156744</span>, <span class="number">0</span>, <span class="number">309756</span>, <span class="number">78372</span>, <span class="number">18660</span>, <span class="number">253776</span>, <span class="number">0</span>, <span class="number">82104</span>, <span class="number">320952</span>, <span class="number">3732</span>, <span class="number">231384</span>, <span class="number">89568</span>, <span class="number">100764</span>, <span class="number">22392</span>, <span class="number">22392</span>, <span class="number">63444</span>, <span class="number">22392</span>, <span class="number">97032</span>, <span class="number">190332</span>, <span class="number">119424</span>, <span class="number">182868</span>, <span class="number">97032</span>, <span class="number">26124</span>, <span class="number">44784</span>, <span class="number">63444</span>]</span><br><span class="line"></span><br><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br><span class="line"></span><br><span class="line">temp = [<span class="built_in">chr</span>(x//shared_key//<span class="number">311</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;custom_d2cr0pt6d_dc499538&#125;</span><br></pre></td></tr></table></figure><h2 id="C3"><a href="#C3" class="headerlink" title="C3"></a>C3</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">  chars += line</span><br><span class="line"></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">  cur = lookup1.index(char)</span><br><span class="line">  out += lookup2[(cur - prev) % <span class="number">40</span>]</span><br><span class="line">  prev = cur</span><br><span class="line"></span><br><span class="line">sys.stdout.write(out)</span><br></pre></td></tr></table></figure><p>题目给出的另外一个附件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl</span><br></pre></td></tr></table></figure><p>可以知道附件是<code>chars</code>加密得到的，分析代码后写出解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br></pre></td></tr></table></figure><p>运行代码可得：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#asciiorder</span></span><br><span class="line"><span class="comment">#fortychars</span></span><br><span class="line"><span class="comment">#selfinput</span></span><br><span class="line"><span class="comment">#pythontwo</span></span><br><span class="line"></span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">    chars += line</span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span> chars[i] <span class="comment">#prints</span></span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>会发现解出来是一串缺少参数<code>chars</code>内容的代码，猜测这里的<code>chars</code>就是上面求解出来的<code>chars</code>，拼接上一条代码再进行修改后得到如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span>(chars[i],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行得到的字符串包裹上<code>picoCTF&#123;&#125;</code>即可得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;adlibs&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa-oracle"><a href="#rsa-oracle" class="headerlink" title="rsa_oracle"></a>rsa_oracle</h2><p>这道题考点较多，但是算是模板题，所以难度不算高.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先题目给了个预言机（Oracle），通过交互我们可以发现可以通过这个Oracle对一些东西进行加密或者解密，而文件中给出了一个password.enc文件，从题目描述中的“<strong>After some intensive reconassainance they found out that the bank has an oracle that was used to encrypt the password</strong>”可以知道password.enc里面的数据是通过Oracle中内置的RSA的参数进行加密的，但是我们并不能将password.enc的数据直接丢进Oracle里面得到password，故我们考虑使用选择密文攻击得到password。得到password之后，我们通过<strong>hint2：OpenSSL can be used to decrypt the message. e.g <code>openssl enc -aes-256-cbc -d ...</code></strong> （或者通过message.enc里面的格式）可以知道需要通过OpenSSL解密message.enc得到flag，而密码就是password.enc解密得到的。</p><h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><h4 id="第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数"><a href="#第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数" class="headerlink" title="第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数"></a>第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数</h4><p>由RSA的原理，我们可以得到以下式子：</p><script type="math/tex; mode=display">2^e\equiv c_2\pmod{n}\\4^e\equiv c_4\pmod{n}\\8^e\equiv c_8\pmod{n}</script><p>可得：</p><script type="math/tex; mode=display">c_2^2\equiv c_4\pmod{n}\\c_2^3\equiv c_8\pmod{n}</script><p>即：</p><script type="math/tex; mode=display">c_2^2-c_4=k_1n\\c_2^3-c_8=k_2n</script><p>在一般情况下，有$(c_2^2-c_4,c_2^3-c_8)=n$</p><p>自此，我们得到了$n$，现在要得到$e$，猜测$e$小于$100000$，使用上面求出的$c_2$（或者$c_4,c_8$）进行爆破，就得到了$e$。</p><p>该步代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;地址&quot;</span>,端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(2,e,n)</span></span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">2</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c2 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(4,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">4</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c4 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(8,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">8</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c8 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line">n = gmpy2.gcd(c2**<span class="number">2</span>-c4,c2**<span class="number">3</span>-c8)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">2</span>,e,n)==c2:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h4 id="第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）"><a href="#第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）" class="headerlink" title="第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）"></a>第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）</h4><p>由于不能直接解密password（后面将里面的数记为$c$），而从一般通过Oracle选择密文攻击的题目，我们可以知道他应该也不能解密$c+kn,k\in Z$，我们考虑通过解密$c*s^e\ mod\ n$来得到我们需要的东西。</p><p>解密之后可以得到$s$倍的$m$（这里$m$就是解密后的<code>password</code>），乘上$inv(s,n)$再模$n$（这里$inv(a,b)$表示$a$模$b$的乘法逆元）就可以还原出<code>password</code>了（需要<code>long_to_bytes</code>）</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(<span class="built_in">str</span>(c*<span class="built_in">pow</span>(<span class="number">2</span>,e,n)%n).encode())</span><br></pre></td></tr></table></figure><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>通过OpenSSL对message.enc通过<code>aes_256_cbc</code>算法进行解密，命令大致如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl enc <span class="literal">-aes-256-cbc</span> <span class="literal">-d</span> <span class="operator">-in</span> (这里是message.enc的路径) <span class="literal">-out</span> flag.txt <span class="literal">-k</span> (这里是password)</span><br></pre></td></tr></table></figure><p>就可以得到flag了.</p><h2 id="flag-printer"><a href="#flag-printer" class="headerlink" title="flag_printer"></a>flag_printer</h2><p>算法优化题，卡了好久，感觉这题不应该出现在Cryptography里面.</p><p>题目给出了一个30.8MB的文本文件，里面有1769611组数，还给出了一个python源码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> galois</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">MOD = <span class="number">7514777789</span></span><br><span class="line"></span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;encoded.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read().strip().split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    x, y = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    points.append((<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)))</span><br><span class="line"></span><br><span class="line">GF = galois.GF(MOD)</span><br><span class="line"></span><br><span class="line">matrix = []</span><br><span class="line">solution = []</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    x, y = point</span><br><span class="line">    solution.append(GF(y % MOD))</span><br><span class="line"></span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        row.append(GF(x**i%MOD))</span><br><span class="line"></span><br><span class="line">    matrix.append(GF(row))</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.bmp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="built_in">bytearray</span>(np.linalg.solve(GF(matrix), GF(solution)).tolist()[:-<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由代码可以知道我们需要求解如下方程：</p><script type="math/tex; mode=display">\left[\begin{matrix}x_0^0&x_0^1&x_0^2&\cdots&x_0^{n-1}\\x_1^0&x_1^1&x_1^2&\cdots&x_1^{n-1}\\x_2^0&x_2^1&x_2^2&\cdots&x_2^{n-1}\\\vdots&\vdots&\vdots&\ddots&\vdots\\x_{n-1}^0&x_{n-1}^1&x_{n-1}^2&\cdots&x_{n-1}^{n-1}\\\end{matrix}\right]\left[\begin{matrix}\alpha_0\\\alpha_1\\\alpha_2\\\vdots\\\alpha_{n-1}\end{matrix}\right]=\left[\begin{matrix}y_0\\y_1\\y_2\\\vdots\\y_{n-1}\end{matrix}\right]</script><p>可以看到，左式的$n\times n$矩阵是一个范德蒙德矩阵，所以优先考虑范德蒙德方程组求解，找到<strong>Björck-Pereyra算法</strong>，后面发现在Python中需要分配11.4TB的内存，并不能解决问题。</p><p>再观察矩阵可以发现对于任意$x_i(i=0,1,2,\cdots,n-1)$，有：$\alpha_0x_i^0+\alpha_1x_i^1+\alpha_2x_i^2+\cdots+\alpha_{n-1}x_i^{n-1}=y_i$</p><p>可以知道，这显然可以利用拉格朗日插值法，得到的函数应为：$f(x)=\alpha_0x^0+\alpha_1x^1+\alpha_2x^2+\cdots+\alpha_{n-1}x^{n-1}$</p><p>但是一般的拉格朗日插值法时间复杂度太高，不能达到我想要的效果（实际上如果是硬跑的话还是可以跑出flag的），故考虑FFT（快速傅里叶变换），但是可惜的是我对算法的学习不深，并不知道怎么写FFT.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量空间（Vector Space）学习笔记</title>
      <link href="/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>由于近期高等代数课程正在讲向量空间，所以想着结合一下高中对于向量空间的学习整理一下一些知识点和笔记。</p><p><strong>参考书籍：《高等代数（第五版）》（北京大学数学系前代数小组 编，高等教育出版社）（以下简称北大版），《高等代数（第五版）》（张禾瑞、郝鈵新 编，高等教育出版社）（以下简称北师大版）</strong></p><h2 id="向量空间的定义"><a href="#向量空间的定义" class="headerlink" title="向量空间的定义"></a>向量空间的定义</h2><p>设$V$是一个非空集合，$F$为一个数域.在集合$V$的元素之间定义一代数运算，称为<strong>加法</strong>，即给出一个法则，对于$V$中任意两个元素$\pmb{\alpha}$与$\pmb{\beta}$，在$V$中都有唯一的一个元素$\pmb{\gamma}$，称为$\pmb{\alpha}$与$\pmb{\beta}$的和，记为$\pmb{\gamma}=\pmb{\alpha}+\pmb{\beta}$，在数域$F$与集合$V$的元素之间还定义了一种运算，称为数量乘法，即对于数域$F$中任一数$k$与$V$中任意元素$\pmb{\alpha}$，在$V$中都有唯一的一个元素$\pmb{\delta}$与它们对应，称为$k$与$\pmb{\alpha}$的<strong>数量乘积</strong>（简称<strong>数乘</strong>），记为$\pmb{\delta}=k\pmb{\alpha}$.若加法与数乘满足下述规则，那么$V$称为数域$P$上的<strong>向量空间</strong>（或称<strong>线性空间</strong>）（向量空间或集合$V$中的元素用小写黑体希腊字母表示，数域中元素用小写拉丁字母表示）：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \pmb{\alpha}+\pmb{\beta}=\pmb{\beta}+\pmb{\alpha};\\&(2)\ (\pmb{\alpha}+\pmb{\beta})+\pmb{\gamma}=\pmb{\alpha}+(\pmb{\beta}+\pmb{\gamma});\\&(3)\ 在V中有一元素\pmb{0}，对于V中任一元素\pmb{\alpha} 都有\ \pmb{0}+\pmb{\alpha}=\pmb{\alpha}\\&(具有该性质的元素\pmb{0}称为V的零元素);\\&(4)\ 对于V中每一元素\pmb{\alpha} ,都有V中的元素\pmb{\beta},使得\ \pmb{\alpha}+\pmb{\beta}=0\\&(\pmb{\beta} 称为\pmb{\alpha} 的负元素);\\&(5)1\pmb{\alpha} = \pmb{\alpha};\\&(6)k(l\pmb{\alpha})=(kl)\pmb{\alpha}\ (k,l\in F,下同);\\&(7)(k+l)\pmb{\alpha} = k\pmb{\alpha}+l\pmb{\alpha};\\&(8)k(\pmb{\alpha}+\pmb{\beta})=k\pmb{\alpha}+k\pmb{\beta}.\end{flalign}</script><h2 id="向量空间的一些简单的性质"><a href="#向量空间的一些简单的性质" class="headerlink" title="向量空间的一些简单的性质"></a>向量空间的一些简单的性质</h2><p>1.零元素是唯一的.</p><p>2.负元素是唯一的.</p><p>3.$0\pmb{\alpha}=\pmb{0},k\pmb{0}=\pmb{0},(-1)\pmb{\alpha}=-\pmb{\alpha}$</p><p>4.若$k\pmb{\alpha}=\pmb{0}$，则有$k=0$或$\pmb{\alpha}=\pmb{0}$</p><h2 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h2><p><strong>子空间的定义：</strong>令$W$是数域$F$上向量空间$V$的一个非空子集.若$W$对于$V$的加法以及标量与向量的乘法来说是封闭的，那么就称$W$是$V$的一个<strong>子空间</strong>.</p><p><strong>定理1：</strong>数域$F$上向量空间$V$的一个非空子集$W$是$V$的一个子空间，当且仅当对于任意$a,b\in F,\pmb{\alpha}$及任意$\pmb{\beta}\in W$，都有$a\pmb{\alpha}+b\pmb{\beta}\in W$</p><h2 id="子空间的和与直和"><a href="#子空间的和与直和" class="headerlink" title="子空间的和与直和"></a>子空间的和与直和</h2><p><strong>子空间和的定义：</strong>设$W_1,W_2$为向量空间$V$的两个子空间.那么$W_1,W_2$的<strong>和</strong>是指由所有能表示为$\pmb{\alpha_1}+\pmb{\alpha_2}$，而$\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2$的向量组成的子集合，记作$V_1+V_2$.</p><p>在子空间的和中，有一种特殊的情形，被称为<strong>直和(direct sum)</strong>，定义如下：</p><p><strong>直和的定义：</strong>设设$W_1,W_2$为向量空间$V$的两个子空间，若和$W_1+W_2$中每个向量$\pmb{\alpha}$的分解式$\pmb{\alpha}=\pmb{\alpha_1}+\pmb{\alpha_2}\ (\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2)$是唯一的，则称这个和为<strong>直和</strong>，记为$V_1\oplus V_2$.</p><p><strong>余子空间的定义：</strong>设$W$为向量空间$V$的一个子空间，若对于$V$的一个子空间$W’$，满足$W\oplus W’=V$，则称$W’$是$W$的一个<strong>余子空间</strong>.</p><p>由定义我们可以知道：</p><p>（1）和$V_1+V_2$是直和的充分必要条件为等式$\pmb{\alpha_1}+\pmb{\alpha_2}=\pmb{0}$(其中$\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2)$只有在$\pmb{\alpha_1},\pmb{\alpha_2}$全为零向量时才成立；</p><p>（2）和$V_1+V_2$是直和的充分必要条件为$V_1\cap V_2=\{\pmb{0}\}$；</p><h2 id="向量的线性相关性、向量组的等价及向量组的极大线性无关组"><a href="#向量的线性相关性、向量组的等价及向量组的极大线性无关组" class="headerlink" title="向量的线性相关性、向量组的等价及向量组的极大线性无关组"></a>向量的线性相关性、向量组的等价及向量组的极大线性无关组</h2><p> <strong>线性组合的定义：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$是向量空间$V$的$r$个向量，$a_1,a_2,\cdots,a_r$是数域$F$中任意$r$个数.我们将和$\pmb{\alpha}=a_1\pmb{\alpha_1}+a_2\pmb{\alpha_2}+\cdots+a_r\pmb{\alpha_r}$称为向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$的一个<strong>线性组合</strong>，而称向量$\pmb{\alpha}$被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$<strong>线性表示</strong>.</p><p><strong>线性相关的定义：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$是向量空间$V$的$r$个向量，若存在$F$中不全为零的数$a_1,a_2,\cdots,a_r$，使得：$a_1\pmb{\alpha_1}+a_2\pmb{\alpha_2}+\cdots+a_r\pmb{\alpha_r}=\pmb{0}$，则称$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性相关.</p><p>若向量组不线性相关，则称它们<strong>线性无关</strong>.</p><p><strong>向量组等价的定义：</strong>设$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$和$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$是向量空间$V$的两个向量组. 若每一$\pmb{\alpha_i}$都可以由$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}$线性表示，而每一$\pmb{\beta_j}$也可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示，那么就说这两个向量组<strong>等价</strong>.</p><p><strong>极大线性无关组的定义：</strong>对于向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$的一个部分向量组$\{\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}\}$，若$\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}$线性无关且对于每一$\pmb{\alpha_j}\ (j=1\cdots,n)$都可以由$\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}$线性表示，则称部分向量组$\{\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}\}$为$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$的一个<strong>极大线性无关部分组</strong>（简称<strong>极大线性无关组</strong>）.</p><p>实际上，在解析几何中，我们已经接触过线性相关与线性无关的概念，在高等代数中，将“向量”这一概念泛化之后，我们可以知道：在向量空间$F\left[x\right]$（数域$F$中一元多项式环）中，对于任意非负整数$n$，有$1,x,x^2,\cdots,x^n$线性无关.</p><p>下面是几个有用的定理：</p><p><strong>定理2：</strong>若向量$\pmb{\gamma}$可以由$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_r}$线性表示，而每一$\pmb{\beta_i}$又可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示，那么$\pmb{\gamma}$可以被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示.</p><p><strong>定理3：</strong>若向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$线性无关，而向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta}\}$线性相关，则$\pmb{\beta}$可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示.</p><p><strong>定理4：</strong>向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}(r\ge2)$线性相关，当且仅当其中某一个向量是其余向量的线性组合.</p><p><strong>定理5（替换定理）：</strong>设向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$线性无关，并且每一$\pmb{\alpha_i}$都可以由向量组$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$线性表示.那么$r\le s$，且必要时可以对$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$中向量重新编号，使得用$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$替换$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_r}$后，所得的向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_{r+1}},\pmb{\beta_{r+2}},\cdots,\pmb{\beta_s}\}$与$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$等价.</p><p><strong>替换定理推论1：</strong>两个等价的线性无关的向量组含有相同个数的向量.</p><p><strong>替换定理推论2：</strong>等价的向量组的极大无关组含有相同个数的向量，特别的，一个向量组的任意两个极大无关组含有相同个数的向量.</p><p>下面是一个求$F^n$中列向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$的一个极大线性无关组的方法：</p><p>（1）首先将列向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$拼接为一个矩阵$\pmb{A}=\left(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\right)$，</p><p>（2）将其化为行最简形式，并得出矩阵$\pmb{A}$的秩$r(\pmb{A})$，</p><p>（3）从中挑选非零数最少的$r(\pmb{A})$个列向量（一般只有一个元素是$1$而其余是$0$），这些变换后的列向量对应的原向量组成的向量组即为向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$的一个极大线性无关组.</p><p>举个例子：</p><p>已知向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\}$，其中$\pmb{\alpha_1}=(1,1,2,3)^T,\pmb{\alpha_2}=(-1,-1,1,1)^T,\pmb{\alpha_3}=(1,3,3,5)^T,\pmb{\alpha_4}=(4,-2,5,6)^T, \pmb{\alpha_5}=(-3,-1,-5,-7)$，求这个向量组的一个极大线性无关组.</p><script type="math/tex; mode=display">\begin{flalign}解:&将这5个向量拼接为一个矩阵如下:\\&\left(\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\right)=\left(\begin{matrix}1&-1&1&4&-3\\1&-1&3&-2&-1\\2&1&3&5&-5\\3&1&5&6&-7\end{matrix}\right)→\left(\begin{matrix}1&0&0&7&-4\\0&1&0&0&0\\0&0&1&-3&1\\0&0&0&0&0\end{matrix}\right)\\&取第1，2，3列向量对应的原向量即\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3}，可得到向量组\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\}的一个极大线性无关组为\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3}\}.\end{flalign}</script><h2 id="基和维数"><a href="#基和维数" class="headerlink" title="基和维数"></a>基和维数</h2><p><strong>生成元和生成子空间的定义：</strong>设$V$为数域$F$上一个向量空间，$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\in V$，由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$的一切线性组合所成的集合显然是$V$的一个子空间，称这个子空间为<strong>由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$所生成的子空间</strong>，并用符号$\mathscr{L}(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n})$表示.向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$叫做这个子空间的一组<strong>生成元</strong>.</p><p><strong>基的定义：</strong>设$V$是数域$F$上一个向量空间.对于$V$中一向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$，若$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$线性无关且$V$中的每一向量都可以被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$线性表示，则称向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$为$V$的一个<strong>基</strong>.</p><p>根据定义，我们很容易可以知道向量空间$V$的一个基就是$V$的一组线性无关的生成元.</p><p>而对数域$F^n$中的$n$个向量：$\pmb{\varepsilon_i}=(0,\cdots,0,1,0,\cdots,0)$，这里$\pmb{\varepsilon_i}$除第$i$为$1$外，其余位置元素均为零，显然向量组$\{\pmb{\varepsilon_1},\pmb{\varepsilon_2},\cdots,\pmb{\varepsilon_n}\}$是$F^n$的一个基，这个基称为$F^n$的<strong>标准基</strong>（或称<strong>标准正交基</strong>）.</p><p><strong>维的定义：</strong>一个向量空间$V$的基所含向量个数称为$V$的<strong>维数</strong>，记作$\dim V$，特别的，我们定义<strong>零空间</strong>的维数为$0$.</p><p>几个常见向量空间的维数：</p><p>（1）$F^n$的维数为$n$；</p><p>（2）$F$上一切$m×n$的矩阵所成的向量空间的维数为$mn$；</p><p>（3）$F[x]$是无限维的.</p><p>下面是关于基和维数的几个定理：</p><p><strong>定理6：</strong>设$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$是向量空间$V$的一个基.那么$V$中的每一个向量可以<strong>唯一</strong>地被表成基向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$的线性组合.</p><p><strong>定理7：</strong>$n$维向量空间中任意多于$n$个向量一定线性相关.</p><p><strong>定理8：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\in V$为$n$维向量空间$V$中一组线性无关向量.那么总可以添加$n-r$个向量$\pmb{\alpha_{r+1}},\cdots,\pmb{\alpha_n}$使得$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\alpha_{r+1}},\cdots,\pmb{\alpha_n}\}$作成$V$的一组基.特别的，$n$维向量空间中任意$n$个线性无关的向量都可以取作基.</p><p><strong>定理9（维数定理）：</strong>设$W_1$和$W_2$都是数域$F$上向量空间$V$的有限维子空间.那么$W_1+W_2$也是有限维的，且</p><script type="math/tex; mode=display">\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)</script><p>对于向量空间$V_1,V_2$，$V_1+V_2$的基即为$V_1,V_2$的生成元构成的向量组的一个极大线性无关组.</p><p>在对$n$维列向量组成的向量空间$W_1,W_2$使用维数定理时，我们常常需要求$W_1+W_2$与$W_1\cap W_2$，下面是求它们的方法：</p><p>设$W_1=\mathscr{L}(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}),W_2=\mathscr{L}(\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})$</p><p>（1）将$W_1,W_2$的生成元拼接为矩阵</p><script type="math/tex; mode=display">\pmb{A}=(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})</script><p>（2）求出向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$的一个极大线性无关组，设为$\{\pmb{\gamma_1},\pmb{\gamma_2},\cdots,\pmb{\gamma_t}\}$，则$W_1+W_2=\mathscr{L}(\pmb{\gamma_1},\pmb{\gamma_2},\cdots,\pmb{\gamma_t})$，且$\dim (W_1+W_2)=t$</p><p>（3）求出矩阵$(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})$所表示的齐次线性方程组的<strong>基础解系</strong>$\{\pmb{\delta_1},\pmb{\delta_2},\cdots,\pmb{\delta_u}\}$，那么我们可以得到$W_1\cap W_2=\mathscr{L}(\pmb{\delta_1},\pmb{\delta_2},\cdots,\pmb{\delta_u})$，且有$\dim (W_1\cap W_2)=u$.</p><p>（基础解系相关定义将会在后面给出）</p><p>显然有$t=r(\pmb{A}),\dim W_1=r,\dim W_1=s$，而由基础解系的概念，显然有$u=(r+s)-t$，所以可以得到$\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高等代数笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连分数（Continued Fractions）笔记</title>
      <link href="/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）</em></p></blockquote><h2 id="连分数的定义"><a href="#连分数的定义" class="headerlink" title="连分数的定义"></a>连分数的定义</h2><p>形如：</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+\frac{1}{\begin{matrix}a_3+\\&&\ddots\\&&&&+\frac{1}{a_n}\end{matrix}}}\tag{1}</script><p>的分数被称作连分数。</p><p>在平常的使用中，为了节省篇幅，我们一般使用以下符号来表示上述连分数：</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+}\frac{1}{a_3+}\frac{1}{a_4+}\cdots\frac{1}{a_n}或[a_1,a_2,\cdots ,a_n]</script><p>其中第二种表示方式最常用。</p><h2 id="有关连分数的一些定理-amp-定义"><a href="#有关连分数的一些定理-amp-定义" class="headerlink" title="有关连分数的一些定理&amp;定义"></a>有关连分数的一些定理&amp;定义</h2><h3 id="定义1（连分数的渐进分数）："><a href="#定义1（连分数的渐进分数）：" class="headerlink" title="定义1（连分数的渐进分数）："></a>定义1（连分数的渐进分数）：</h3><p>$[a_1,a_2,\cdots ,a_k]=\frac{p_k}{q_k}\ (1\le k\le n)$叫做连分数$(1)$的第$k$个<strong>渐进分数</strong></p><h3 id="定义2（简单连分数）："><a href="#定义2（简单连分数）：" class="headerlink" title="定义2（简单连分数）："></a>定义2（简单连分数）：</h3><p>若$a_1$是整数，$a_2,a_3,\cdots,a_k,\cdots$是正整数，则连分数</p><script type="math/tex; mode=display">[a_1,a_2,\cdots,a_k,\cdots]</script><p>称为<strong>简单连分数</strong>，若$a$的个数有限，则称为<strong>有限简单连分数</strong>，若$a$的个数无限，则称为<strong>无限简单连分数</strong>.</p><p>对于无限连分数，若当$k→∞$时$[a_1,a_2,\cdots,a_n,\cdots]$的渐进分数$\frac{p_k}{q_k}$存在极限，则称这个极限为<strong>连分数$[a_1,a_2,\cdots,a_n,\cdots]$的值.</strong></p><h3 id="定义3（循环连分数）："><a href="#定义3（循环连分数）：" class="headerlink" title="定义3（循环连分数）："></a>定义3（循环连分数）：</h3><p>对于一个无限连分数$[a_1,a_2,\cdots,a_n,\cdots]$，如果能找到两个整数$s\ge0,t&gt;0$使得</p><script type="math/tex; mode=display">a_{s+i}=a_{s+kt+i},\ \ \ i=1,2,\cdots,t;\ \ \ \ k=0,1,2,\cdots</script><p>这个无限简单连分数就叫<strong>循环连分数</strong>，并简单地把它记作</p><script type="math/tex; mode=display">[a_1,a_2, \cdots ,a_s,a_{s+1},\cdots ,a_{s+t}]</script><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a>定理1：</h3><p>若连分数$[a_1,a_2,\cdots ,a_n]$的渐进分数是$\frac{p_1}{q_1},\frac{p_2}{q_2},\cdots ,\frac{p_n}{q_n}$，则在这些渐进分数之间，下列关系成立：</p><script type="math/tex; mode=display">\begin{matrix}p_1=a_1,p_2=a_2a_1+1&p_k=a_kp_{k-1}+p_{k-2},\\ q_1=1,q_2=a_2\ \ \ \ \ \ \ \ \ \ \ \ \ &q_k=a_kq_{k-1}+q_{k-2},\end{matrix}\cdots,\ \ \ 3\le k\le n</script><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a>定理2：</h3><p>若连分数$[a_1,a_2,\cdots ,a_n]$的$n$个渐进连分数是$\frac{p_k}{q_k},k=1,2,\cdots,n$，则下列两关系成立：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \ p_kq_{k-1}-p_{k-1}q_k=(-1)^k,\ \ \ \ \ \ \ \ \ \ k\ge 2\\ &(2)\ \ p_kq_{k-2}-p_{k-2}q_k=(-1)^{k-1}a_k,\ \ k\ge3\end{flalign}</script><h3 id="定理3："><a href="#定理3：" class="headerlink" title="定理3："></a>定理3：</h3><p>设$[a_1,a_2,\cdots,a_n,\cdots]$是简单连分数，$\frac{p_k}{q_k}(k=1,2,\cdots)$是它的渐进分数，则：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \ 当k\ge 3时，q_k\ge q_{k-1}+1，因而对任何k来说,q_k\ge k-1\\ &(2)\ \ \frac{p_{2(k-1)}}{q_{2(k-1)}}>\frac{p_{2k}}{q_{2k}},\frac{p_{2k-1}}{q_{2k-1}}>\frac{p_{2k-3}}{q_{2k-3}},\frac{p_{2k}}{q_{2k}}>\frac{p_{2k-1}}{q_{2k-1}}\\ &(3)\frac{p_k}{q_k}(k=1,2,\cdots)都是既约分数\end{flalign}</script><h3 id="定理4："><a href="#定理4：" class="headerlink" title="定理4："></a>定理4：</h3><p>每一简单连分数表示一个实数.</p><h3 id="定理5："><a href="#定理5：" class="headerlink" title="定理5："></a>定理5：</h3><p>任一实无理数可以表成无限简单连分数.</p><h4 id="定理5的推论："><a href="#定理5的推论：" class="headerlink" title="定理5的推论："></a>定理5的推论：</h4><p>对于实无理数$\alpha$，有</p><script type="math/tex; mode=display">\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta_k}{q_kq_{k+1}}或\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta'_k}{q_k^2},其中0<\delta_k<1,0<\delta'_k<1</script><h3 id="定理6："><a href="#定理6：" class="headerlink" title="定理6："></a>定理6：</h3><p>每一实无理数只有一种唯一的方法表成无限简单连分数.</p><h3 id="定理7："><a href="#定理7：" class="headerlink" title="定理7："></a>定理7：</h3><script type="math/tex; mode=display">\begin{flalign}&(1)若\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[b_1,b_2,\cdots,b_n],且a_n>1,b_m>1，则m=n,a_i=b_i\ \ (i=1,2,\cdots,n)\\ &(2)任一有理数\frac{a}{b}有且仅有两种方法表成简单连分数，即\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[a_1,a_2,\cdots,a_n-1,1]\end{flalign}</script><h3 id="定理8："><a href="#定理8：" class="headerlink" title="定理8："></a>定理8：</h3><p>若$\alpha$是任一实数，$\frac{p_k}{q_k}$是$\alpha$的第$k$个渐进分数，则在分母小于等于$q_k$的一切有理数中，$\frac{p_k}{q_k}$是$\alpha$最好的有理近似值，即若$0&lt;q\le q_k$，则</p><script type="math/tex; mode=display">|{\alpha-\frac{p_k}{q_k}}|\le|{\alpha-\frac{p}{q}}|</script><h3 id="定理9："><a href="#定理9：" class="headerlink" title="定理9："></a>定理9：</h3><p>每一循环连分数一定是某一整系数二次不可约方程的实根.</p><h3 id="定理10："><a href="#定理10：" class="headerlink" title="定理10："></a>定理10：</h3><p>若$f(x)=ax^2+bx+c$是一个整系数二次不可约多项式，$\alpha$是$f(x)=0$的一个实根，则表示$\alpha$的简单连分数是一循环连分数.</p><h3 id="定理11（Legendre定理）："><a href="#定理11（Legendre定理）：" class="headerlink" title="定理11（Legendre定理）："></a>定理11（Legendre定理）：</h3><p>对于有理数$\alpha$，若整数$c,d$满足</p><script type="math/tex; mode=display">|{\alpha-\frac{c}{d}}|<\frac{1}{2d^2}</script><p>那么$\frac{c}{d}$就是$\alpha$的一个有理近似.</p><h2 id="连分数的应用实例"><a href="#连分数的应用实例" class="headerlink" title="连分数的应用实例"></a>连分数的应用实例</h2><h3 id="佩尔方程-Pell-equation"><a href="#佩尔方程-Pell-equation" class="headerlink" title="佩尔方程(Pell equation)"></a>佩尔方程(Pell equation)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>形如$x^2-dy^2=1$的不定方程被称为<strong>佩尔方程</strong></p><p>现求佩尔方程有正整数解的条件：</p><p>在实数域对方程$x^2-dy^2=1$进行分解有$(x+\sqrt{d}y)(x-\sqrt{d}y)=1$</p><p>(1)当$d$为完全平方数</p><p>则有$x+\sqrt{d}y,x-\sqrt{d}y$均为整数，那么若$(x+\sqrt{d}y)(x-\sqrt{d}y)=1$，则必有$x+\sqrt{d}y=x-\sqrt{d}y=1$</p><p>而满足这种情况的非负整数对$(x,y)=(1,0)$所以方程$x^2-dy^2=1$并不存在正整数解.</p><p>(2)当$d$为非完全平方数</p><h3 id="定理12："><a href="#定理12：" class="headerlink" title="定理12："></a>定理12：</h3><p>对任何正整数$n$，都存在两个整数$P_n,Q_n$，使得</p><script type="math/tex; mode=display">\alpha_n=\frac{\sqrt{d}+P_n}{Q_n},且P_n^2\equiv d\ (mod\ Q_n)</script><p>成立.</p><h3 id="定理13："><a href="#定理13：" class="headerlink" title="定理13："></a>定理13：</h3><p>若$d$是一个非平方的正整数，$Q_n$为<strong>定理12</strong>中所定义，则二次不定方程$x^2-dy^2=(-1)^nQ_n$有正整数解$x,y$且$(x,y)=1$.</p><h3 id="定理14："><a href="#定理14：" class="headerlink" title="定理14："></a>定理14：</h3><p>若有$\sqrt{d}=[a_1,a_2, \cdots ,a_s,a_{s+1}, \cdots ,a_{s+t}],n&gt;s$而$Q_n$为<strong>定理12</strong>所定义，则方程$x^2-dy^2=(-1)^nQ_n$有无穷多个正整数解 $|{p_{m+lt}}|,q_n+lt,2\ |\ l,l\ge0$ .（其中 $\frac {p_{m+lt}}{q_{m+lt}}$ 为 $\sqrt {d}$ 的第 $m+lt$ 个渐进分数）.</p><p>由<strong>定理14</strong>可知存在一正整数$Q$（取$Q=(-1)^nQ_n,n&gt;s$）使得不定方程$x^2-dy^2=Q$有无穷多组正整数解，则在这些解中必存在两组不同的正整数$x_1y_1;x_2y_2$使得</p><script type="math/tex; mode=display">x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)</script><p>成立.由于$x^2_1-dy^2_1=x^2_2-dy^2_2=Q$，故有</p><script type="math/tex; mode=display">Q^2=(x_1^2-dy_1^2)(x_2^2-dy_2^2)=(x_1x_2-dy_1y_2)^2-d(x_1y_2-x_2y_1)^2</script><p>由$x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)$可得：</p><script type="math/tex; mode=display">x_1x_2-dy_1y_2\equiv x_1^2-dy_1^2\equiv 0\ (mod\ |{Q}|),\\ x_1y_2-x_2y_1\equiv x_1y_1-x_1y_1\equiv 0\ (mod\ |{Q}|)</script><p>故若令$|{\frac{x_1x_2-dy_1y_2}{Q}}|=x,|{\frac{x_1y_2-x_2y_1}{Q}}|=y$，可知$x,y$均为非负整数且为方程$x^2-dy^2=1$的一解.</p><p>显然有$x\neq0$，否则有$-dy^{2}=1$，与$d&gt;0$矛盾；且有$y\neq0$否则有$x_1y_2-x_2y_1=0$，由引理2知$(x_1,y_1)=(x_2,y_2)=1$，所以有$x_1\ |\ x_2,x_2\ |\ x_1$，由于$x_1,x_2$均为正整数，所以有$x_1=x_2,y_1=y_2$，与$x_1,y_1;x_2;y_n$不同的定义相悖.故可知$x,y$为方程$x^2-dy^2=1$的一组正整数解.</p><p>综上所述，当$d$为完全平方数时，不定方程$x^2-dy^2=1$有正整数解.</p><h4 id="现在求不定方程-x-2-dy-2-1-的正整数解："><a href="#现在求不定方程-x-2-dy-2-1-的正整数解：" class="headerlink" title="现在求不定方程$x^2-dy^2=1$的正整数解："></a>现在求不定方程$x^2-dy^2=1$的正整数解：</h4><h3 id="定理15："><a href="#定理15：" class="headerlink" title="定理15："></a>定理15：</h3><p>若$x_0,y_0$是方程$x^2-dy^2=1$的一组正整数解，且$x_0+\sqrt{d}y_0$是形如$x+\sqrt{d}y$（$x,y$是方程$x^2-dy^2=1$的正整数解）的最小数，则方程$x^2-dy^2=1$的一切正整数解$x,y$可以由</p><script type="math/tex; mode=display">x\pm\sqrt{d}y=\big(x_0+\sqrt{d}y_0\big)^n,n=1,2,\cdots</script><p>确定.</p><p>有了<strong>定理15</strong>，我们可以通过一个佩尔方程的最小正整数解求出这个佩尔方程的所有解.现在我们的目标就成为找到如何求佩尔方程的最小正整数解.</p><p> 实际上，对于不为完全平方数的$\sqrt{d}=[a_1,a_2,\cdots,a_n,\cdots]$我们总能找到$a_{n+1}$满足$a_i=2a_1(i=2,3,\cdots,n)$，则$\frac{x}{y}=[a_1,a_2,\cdots,a_{n}]$可能为$d$定义的佩尔方程的一组解.</p><p>求佩尔方程最小整数解的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line">d = ...</span><br><span class="line">cf = continued_fraction(sqrt(d))</span><br><span class="line">a0 = cf[<span class="number">0</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> cf[i] == <span class="number">2</span>*a0:</span><br><span class="line">        c = cf.convergent(i-<span class="number">1</span>)</span><br><span class="line">        x, y = c.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> - d*y**<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>((x,y))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这里扩展地提一下广义佩尔方程：</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>形如$x^2-dy^2=c$的方程称为广义佩尔方程.</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>通过连分数求出广义佩尔方程的最小正整数解$(x_0,y_0)$后，可以知道$(x_0r+Dy_0s,x_0s+y_0r)$也是该方程的整数解（其中$r,s$为方程$r^2-ds^2=1$的整数解）</p><h4 id="求解代码"><a href="#求解代码" class="headerlink" title="求解代码"></a>求解代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell_roots</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    intervals = <span class="number">2</span>**<span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_a_root</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span></span>):</span><br><span class="line">        cf = continued_fraction(sqrt(D))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            c = cf.convergent(i - <span class="number">1</span>)</span><br><span class="line">            x, y = c.as_integer_ratio()</span><br><span class="line">            <span class="keyword">if</span> x**<span class="number">2</span> - D * y**<span class="number">2</span> == C:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            x2 = C + D * y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x2 &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x = isqrt(x2)</span><br><span class="line">            <span class="keyword">if</span> x ** <span class="number">2</span> == x2:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    r, s = get_a_root(D, <span class="number">1</span>)</span><br><span class="line">    x, y = get_a_root(D, C)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x, y</span><br><span class="line">        x, y = x * r + D * y * s, r * y + s * x</span><br><span class="line">D = ...</span><br><span class="line">C = ...</span><br><span class="line">x, y = <span class="built_in">next</span>(pell_roots(D, C))</span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span> - D * y**<span class="number">2</span> == C)</span><br><span class="line"><span class="built_in">print</span>((x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RSA的维纳攻击"><a href="#RSA的维纳攻击" class="headerlink" title="RSA的维纳攻击"></a>RSA的维纳攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>考虑一般的RSA，$c\equiv m^e\ (mod\ n),n=pq$，$p,q$均为质数，在这里$e$非常大，这也是适用维纳攻击的RSA的明显特征，有$\varphi(n)=(p-1)(q-1)$，则有</p><script type="math/tex; mode=display">\varphi(n)=(p-1)(q-1)=pq-p-q+1=N-p-\frac{n}{p}+1</script><p>故有$p^2+p\big[\varphi(n)-n-1\big]+n=0$</p><p>故若我们已知$n$和$\varphi(n)$，我们就可以对$n$进行分解.</p><p>又由于在RSA中，有$ed\equiv1\ (mod\ \varphi(n))$，所以存在整数$k$使得$ed=k\varphi(n)+1$</p><p>即有</p><script type="math/tex; mode=display">|{\frac{e}{\varphi(n)}-\frac{k}{d}}|=\frac{1}{d\varphi(n)}</script><p>由<strong>定理11（Legendre定理）</strong>可知：$\frac{k}{d}$是$\frac{e}{\varphi(n)}$的一个有理近似，故我们可以通过$\frac{e}{\varphi(n)}$的有理近似获得$\frac{k}{d}$，当$n=pq$且$q&lt;p&lt;2q$时，若满足$d&lt;\frac{1}{3}n^\frac{1}{4}$，则$\frac{k}{d}$为$\frac{e}{n}$的一个有理近似.</p><h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4><p>(1)估测是否满足$d&lt;\frac{1}{3}n^\frac{1}{4}$</p><p>(2)求$\frac{e}{n}$的连分数展开</p><p>(3)迭代连分数$\frac{k_i}{d_i}$：先使用$k_i,d_i$求出$\varphi_i(n)$，再通过$\varphi_i(n)$计算出$n$，验证$\varphi_i(n)$是否正确</p><h4 id="解密脚本："><a href="#解密脚本：" class="headerlink" title="解密脚本："></a>解密脚本：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">n, e</span>):</span><br><span class="line">    cf = continued_fraction(e / n)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pkd <span class="keyword">in</span> convers:</span><br><span class="line">        pk, pd = pkd.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> pk == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * pd - <span class="number">1</span>) % pk != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pphi = (e * pd - <span class="number">1</span>) // pk</span><br><span class="line">        p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">        roots = solve(p ** <span class="number">2</span> + (pphi - n - <span class="number">1</span>) * p + n, p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">            pp, pq = roots</span><br><span class="line">            <span class="keyword">if</span> pp * pq == n:</span><br><span class="line">                <span class="keyword">return</span> pp, pq, pd</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">n = ...</span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line">p, q, d = wienerAttack(n, e)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG笔记</title>
      <link href="/2023/12/17/LCG%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/17/LCG%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义：</p><script type="math/tex; mode=display">X_{n+1}\equiv aX_n+b\ (mod\ p)</script><p>在CTF中，一般有以下题型：</p><h2 id="一-求逆"><a href="#一-求逆" class="headerlink" title="一.求逆"></a>一.求逆</h2><p>所谓求逆，其实即为已知a,b,p,c后求解方程：</p><script type="math/tex; mode=display">c\equiv(ax+b)\ (mod\ p)</script><p>由数论知识我们很容易可以知道：</p><script type="math/tex; mode=display">x\equiv(c-b)a^{-1}\ (mod\ p)</script><p>对于这类题目，我们只需利用以上公式即可快速解出。</p><h2 id="二-求参数a-b后求逆"><a href="#二-求参数a-b后求逆" class="headerlink" title="二.求参数a,b后求逆"></a>二.求参数a,b后求逆</h2><p>这类题型一般都会给出一列连续经过几次线性同余的数据后得出的数据和p，我们需要通过这些有限的数据来求解原来的数据，在此之前我们需要先求解a和b，大致过程如下：</p><p>假设已知<script type="math/tex">x_{n},x_{n+1},x_{n+2}</script>，我们有：</p><script type="math/tex; mode=display">x_{n+1}\equiv ax_n+b\ (mod\ p)\\ x_{n+2}\equiv ax_{n+1}+b\ (mod\ p)</script><p>所以我们有：</p><script type="math/tex; mode=display">x_{n+2}-x_{n+1}\equiv a(x_{n+1}-x_n)\ (mod\ p)</script><p>所以：</p><script type="math/tex; mode=display">a\equiv (x_{n+2}-x_{n+1})(x_{n+1}-x_n)^{-1}\ (mod\ p)(假定(x_{n+1}-x_n)与p互质)</script><p>那么我们有：</p><script type="math/tex; mode=display">b\equiv x_{n+1}-ax_n\ (mod\ p)</script><p>这样我们就可以得到a,b，再通过求逆得出原来的数据即可。</p><h3 id="例：-Newstar-CTF2023-Week3-babyrandom"><a href="#例：-Newstar-CTF2023-Week3-babyrandom" class="headerlink" title="例：[Newstar  CTF2023]Week3    babyrandom"></a>例：[Newstar  CTF2023]Week3    babyrandom</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line"></span><br><span class="line">a = randrange(<span class="number">2</span>, p)</span><br><span class="line">b = randrange(<span class="number">2</span>, p)</span><br><span class="line">x = bytes_to_long(flag)</span><br><span class="line">menu = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Random as a Service with LCG backend</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter your option</span></span><br><span class="line"><span class="string">1. Reset</span></span><br><span class="line"><span class="string">2. Get</span></span><br><span class="line"><span class="string">3. Exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetRandom</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    nx = (a*x + b) % p</span><br><span class="line">    <span class="built_in">print</span>(nx)</span><br><span class="line">    x = nx</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(menu)</span><br><span class="line">    opt = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opt = <span class="built_in">int</span>(opt)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="number">1</span>:</span><br><span class="line">            x = bytes_to_long(flag)</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">2</span>:</span><br><span class="line">            GetRandom()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;invalid option&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oh no, something wrong!&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这道题提供了靶机，可以通过靶机得出三个连续加密后数据，解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = []</span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line">io = pwn.remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25624</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    data = io.recvline()</span><br><span class="line">    io.recv()</span><br><span class="line">    x.append(<span class="built_in">int</span>(data))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">x = (x[<span class="number">0</span>]-b)*gmpy2.invert(a,p)%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><blockquote><p>flag{lcg_1s_n0t_s3cur3#fb528ba5}</p></blockquote><h2 id="三-求参数a-b-p后求逆"><a href="#三-求参数a-b-p后求逆" class="headerlink" title="三.求参数a,b,p后求逆"></a>三.求参数a,b,p后求逆</h2><p>与上一种形式相似，但是多了个p要求，我们假设一个数列：</p><script type="math/tex; mode=display">\{x_0,x_1,x_2,\cdots,x_{n-1},x_{n},\cdots\}</script><p>其满足：</p><script type="math/tex; mode=display">x_{n+1}\equiv ax_n+b\ (mod\ p)</script><p>假设有一个数列 <script type="math/tex">\{t_n\}</script> 有：</p><script type="math/tex; mode=display">t_n\equiv x_{n+1}-x_n\equiv a(x_n-x_{n-1})\equiv at_{n-1}\ (mod\ p)</script><p>所以：</p><script type="math/tex; mode=display">t_{n+1}t_{n-1}\equiv a^{2}t_{n-1}^2\equiv t_n^2\ (mod\ p)</script><p>也就是说：</p><script type="math/tex; mode=display">t_{n+1}t_{n-1}-t_n^{2}=kp\ (k\in Z)</script><p>同理，有：</p><script type="math/tex; mode=display">t_{n+2}t_{n}-t_{n+1}^{2}=k'p\ (k'\in Z)</script><p>所以：</p><script type="math/tex; mode=display">p=gcd(t_{n+2}t_{n}-t_{n+1}^{2},t_{n+1}t_{n-1}-t_n^{2})</script><p>求出p后我们就可以由上种类型继续求解。</p><p>但是要注意，上面求出的p不一定就是实际要求的p，所以需要综合多组数据求解。</p><h3 id="例：-PCTF2023-cgl"><a href="#例：-PCTF2023-cgl" class="headerlink" title="例：[PCTF2023]cgl"></a>例：[PCTF2023]cgl</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag,hint,key_number</span><br><span class="line"></span><br><span class="line">hint=bytes_to_long(hint)</span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">256</span>)</span><br><span class="line">b = getPrime(<span class="number">256</span>)</span><br><span class="line">n = getPrime(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">state = hint</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    state = (state * a + b) % n</span><br><span class="line">    result.append(state)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc=<span class="built_in">list</span>(base64.b64encode(flag))</span><br><span class="line">seed(key_number)</span><br><span class="line">shuffle(enc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(enc))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[64808739969023370119048821688797617211776674130654821075486774236651303382814, </span></span><br><span class="line"><span class="string">79259085906502785899793009961165414442137337544515472474317826031734962148580, </span></span><br><span class="line"><span class="string">47572752582229256276978761367590954300620113464013293239765792280017260371290, </span></span><br><span class="line"><span class="string">38491979589561565391093783861378040494484383004914878495301417593240442882761, </span></span><br><span class="line"><span class="string">58955289126482266943455593731576872529828229203595014577711629479455475819111]</span></span><br><span class="line"><span class="string">b&#x27;QkiTMMx3St9IYTLMN2DmR0t53zd1MhmJT1hZ2YiwMZETVhwhOGYVZYcD&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题很明显要通过上述方法来求解hint，在这里我们只求解hint，求解代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = [<span class="number">64808739969023370119048821688797617211776674130654821075486774236651303382814</span>, </span><br><span class="line"><span class="number">79259085906502785899793009961165414442137337544515472474317826031734962148580</span>, </span><br><span class="line"><span class="number">47572752582229256276978761367590954300620113464013293239765792280017260371290</span>, </span><br><span class="line"><span class="number">38491979589561565391093783861378040494484383004914878495301417593240442882761</span>, </span><br><span class="line"><span class="number">58955289126482266943455593731576872529828229203595014577711629479455475819111</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.append(x[i+<span class="number">1</span>]-x[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    p = gmpy2.gcd(t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>],t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i])</span><br><span class="line">    a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">    b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">    x = (x[<span class="number">0</span>] - b) * gmpy2.invert(a, p) % p</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可以得出hint：</p><blockquote><p>key_number=randrange(999999)</p></blockquote><p>要注意的是：在这种情况下，<script type="math/tex">\{x_n\}</script>的元素数量应该至少要有5个才能求解出p。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anshel–Anshel–Goldfeld 密钥交换体系(Anshel–Anshel–Goldfeld key exchange)</title>
      <link href="/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/"/>
      <url>/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/</url>
      
        <content type="html"><![CDATA[<h3 id="原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）"><a href="#原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）" class="headerlink" title="原理（代数密钥建立协议，The algebraic key establishment protocol）"></a>原理（代数密钥建立协议，The algebraic key establishment protocol）</h3><p>​    We now present an algebraic key establishment protocol which, in its most general form consists of a five–tuple </p><script type="math/tex; mode=display">(U, V,\beta,\gamma_1, \gamma_2)</script><p>where $U$ and $V$ are feasibly computable monoids, and</p><script type="math/tex; mode=display">\beta:U× U\rightarrow V,\ \ \ \gamma_i:U× V\rightarrow V\ \ (i=1,2)</script><p>are feasibly computable functions satisfying the following properties.</p><p>​    (i) For all elements $x, y_1, y_2 \in U$ ,</p><script type="math/tex; mode=display">\beta(x,y_1\cdot y_2)=\beta(x,y_1)\cdot \beta(x,y_2)</script><p>​    (ii) For all elements $x, y \in U$ ,</p><script type="math/tex; mode=display">\gamma_1(x,\beta(y,x))=\gamma_2(x,\beta(x,y))</script><p>​    (iii) Suppose $y_1, y_2, \cdots ,y_k \in U$ and $\beta(x, y_1), \beta(x, y_2), \cdots ,\beta(x, y_k)$ are publicly known for some secret element $x \in U$. Then, in general, it is infeasible to determine the secret element $x$ .</p><p>​    The users $A$ and $B$ are publicly assigned submonoids, $S_A, T_B \subseteq U$, respectively. Suppose that $S_A$ is generated by the elements</p><script type="math/tex; mode=display">\{s_1,\cdots ,s_m\}</script><p>and $S_B$ is generated by $\{t_1,\cdots,t_n\}$.The protocol begins with user A choosing a secret element a in $S_A$ and transmitting the elements</p><script type="math/tex; mode=display">\beta(a,t_i)\ \ \ \ \ \ i=1,\cdots,n.</script><p>Likewise, user $B$ chooses a secret element $b$ in $T$, transmits</p><script type="math/tex; mode=display">\beta(b,s_i)\ \ \ \ \ \ i=1,\cdots,m.</script><p>It follows from property (iii) that even though the transmission is over a public channel, the secret elements $a$ and $b$ are secure. Property (i) above insures that user $A$ can compute the element</p><script type="math/tex; mode=display">\beta(b,a),</script><p>and</p><script type="math/tex; mode=display">\gamma_1(a,\beta(b,a)).</script><p>Likewise user $B$ can compute $\beta(a, b)$ and $\gamma_2(b, \beta(a, b))$. Recalling property (ii) above we see that</p><script type="math/tex; mode=display">\kappa=\gamma_1(a,\beta(b,a))=\gamma_2(b,\beta(a,b))</script><p>can serve as an established key.</p><h3 id="具体例子（群论协议，A-group-theoretic-protocol）"><a href="#具体例子（群论协议，A-group-theoretic-protocol）" class="headerlink" title="具体例子（群论协议，A group theoretic protocol）"></a>具体例子（群论协议，A group theoretic protocol）</h3><p>In this illustration the monoid $U = V$ is a group, denoted $G$, and the users $A$ and $B$ are publicly assigned subgroups</p><script type="math/tex; mode=display">S_A=\langle s_1,s_2,\cdots ,s_m\rangle,\ \ \ \ S_B=\langle t_1,t_2,\cdots ,t_n\rangle.</script><p>Here the function $\beta:G× G\rightarrow G$ is chosen to be conjugation,</p><script type="math/tex; mode=display">\gamma_1(u,v)=u^{-1}v,\ \ \ \ \ \ \gamma_2(u,v)=v^{-1}u.</script><p>Users A and B choose secret elements $a \in S_A$ and $b \in S_B$ respectively, and user $A$ begins the protocol by computing, rewriting, and transmitting the collection of elements</p><script type="math/tex; mode=display">a^{-1}t_1a,a^{-1}t_2a,\cdots ,a^{-1}t_na.</script><p>Similarly, user $B$ computes, rewrites, and transmits</p><script type="math/tex; mode=display">b^{-1}s_1b,b^{-1}s_2b,\cdots,b^{-1}s_mb.</script><p>An adversary observing these transmissions is unable to determine $a$ or $b$ unless $(s)$ he can solve a set of simultaneous conjugacy equations over the base group. </p><p>​    Multiplying two elements in the group can be accomplished by simply concatenating the two expressions representing the elements. The process of rewriting, while not unique, must be chosen so that no adversary can determine the conjugating element from viewing the publicly transmitted conjugates.</p><p>​    Recalling that the conjugate of the product of two elements is the product of the conjugates of those elements (i.e., property (i) of $\beta$), users $A$ and $B$ are now in a position to compute, respectively, the elements</p><script type="math/tex; mode=display">\beta(b,a)=b^{-1}ab,\ \ \ \ \ \ \ \ \beta(a,b)=a^{-1}ba.</script><p>In order to attain a common key, user $A$ computes</p><script type="math/tex; mode=display">\kappa=\gamma_1(a,\beta(b,a))=a^{-1}b^{-1}ab=[a,b],</script><p>and user $B$ computes</p><script type="math/tex; mode=display">\kappa=\gamma_2(a,\beta(b,a))=[a,b].</script><p>（上文摘自<em>Mathematical Research Letters 6, 287–291 (1999),AN ALGEBRAIC METHOD FOR PUBLIC-KEY CRYPTOGRAPHY</em>,Iris Anshel, Michael Anshel, and Dorian Goldfeld著）</p><h4 id="应用例"><a href="#应用例" class="headerlink" title="应用例"></a>应用例</h4><h5 id="UTCTF2020-Cube-Crypto"><a href="#UTCTF2020-Cube-Crypto" class="headerlink" title="[UTCTF2020]Cube Crypto"></a>[UTCTF2020]Cube Crypto</h5><p>Mr. Anshel and Mr. Goldfeld were trying to exchange some asymmetric keys to get a shared key. They aren’t very good at math, so they decided to use a Rubik’s Cube instead to do the crypto. I don’t think it’s very secure though, I think you might be able to guess some of their keys :hmm:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mr. A public key: [B&#x27; U&#x27;, F B F, R&#x27; D, B D&#x27;]</span><br><span class="line">Mr. G public key: [R D L&#x27;, D U&#x27; B, U F&#x27;, L&#x27; F]</span><br><span class="line"></span><br><span class="line">Mr. A sends: [B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;, B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;]</span><br><span class="line">Mr. G sends: [U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;]</span><br></pre></td></tr></table></figure><p><strong>NOTE: The flag is the shared key that they generate, so it is NOT in <code>utflag&#123;&#125;</code> format</strong></p><p>显然的，这道题需要应用Anshel–Anshel–Goldfeld 密钥交换体系，在这里，密钥是由魔方转动记号呈现的，而我们知道，魔方的转动操作群是非阿贝尔群，在这里，我们可以从Mr.A和Mr.G提供的公钥中提取出：</p><script type="math/tex; mode=display">S_A=\langle s_1,s_2,s_3,s_4\rangle\ \ \ \ \ \ \ S_G=\langle t_1,t_2,t_3,t_4\rangle</script><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1=B&#x27; U&#x27;</span><br><span class="line">s_2=F B F</span><br><span class="line">s_3=R&#x27; D</span><br><span class="line">s_4=B D&#x27;</span><br><span class="line">t_1=R D L&#x27;</span><br><span class="line">t_2=D U&#x27; B</span><br><span class="line">t_3=U F&#x27;</span><br><span class="line">t_4=L&#x27; F</span><br></pre></td></tr></table></figure><p>又设在交换后得出的密文的集合分别为：</p><script type="math/tex; mode=display">C_G=\langle s_1',s_2',s_3',s_4'\rangle\ \ \ \ \ \ \ C_A=\langle t_1',t_2',t_3',t_4'\rangle</script><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1&#x27;=U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_2&#x27;=U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_3&#x27;=U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_4&#x27;=U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">t_1&#x27;=B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_2&#x27;=B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;</span><br><span class="line">t_3&#x27;=B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_4&#x27;=B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;</span><br></pre></td></tr></table></figure><p>我们假设共享密钥为$a^{-1}g^{-1}ag$，所以我们有：</p><script type="math/tex; mode=display">a^{-1}t_ia=t_i'\ \ \ \ \ g^{-1}s_ig=s_i'\ \ \ \ \ (i=1,2,3,4)</script><p>通过观察我们很容易可以得到：</p><script type="math/tex; mode=display">a=D' R D B'\\g=L D' R' F U'</script><p>所以我们可以得出共享密钥：</p><script type="math/tex; mode=display">a^{-1}g^{-1}ag=B D' R' DU F' R D L'D' R D B'L D' R' F U'</script><p>这样我们就得到了flag：</p><blockquote><p>utflag{B D’ R’ D U F’ R D L’ D’ R D B’ L D’ R’ F U’}</p></blockquote><p>至此，对于Anshel–Anshel–Goldfeld 密钥交换体系的介绍就到此结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triode的RSA学习笔记（1）</title>
      <link href="/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在进行RSA解密之前，我们先要理解RSA的加密原理：</p><p>已知明文$a$，公钥对$(n,e)$，加密过程如下:</p><script type="math/tex; mode=display">b\equiv a^e\ (mod\ n)</script><p>若要对已知的密文进行解密，我们就需要得到私钥(Private Key)：</p><p>设对于上述加密过程所得出的私钥为$d$，则：</p><script type="math/tex; mode=display">a\equiv b^d\ (mod\ n)</script><p>很明显：</p><script type="math/tex; mode=display">b^{ed}\equiv a^e\equiv b\ (mod\ n)</script><p>所以：</p><script type="math/tex; mode=display">b^{ed-1}\equiv 1\ (mod\ n)</script><p>一般情况下，$gcd(n,b)=1$，故先对这种情况进行考虑</p><p>由欧拉定理：我们知道</p><script type="math/tex; mode=display">b^{\varphi(n)}\equiv 1\ (mod\ n)</script><p>很显然：</p><script type="math/tex; mode=display">ed-1=k\varphi(n)</script><p>可以看出：</p><script type="math/tex; mode=display">ed\equiv1\ (mod\ \varphi(n))</script><p>所以：</p><script type="math/tex; mode=display">d=inv(e,\varphi(n))\ (inv(e,\varphi(n))为e模\varphi(n)的乘法逆元)</script><hr><h3 id="已知n-e-c在一般情况下（n可通过软件进行质因数分解）的解密"><a href="#已知n-e-c在一般情况下（n可通过软件进行质因数分解）的解密" class="headerlink" title="已知n,e,c在一般情况下（n可通过软件进行质因数分解）的解密"></a>已知n,e,c在一般情况下（n可通过软件进行质因数分解）的解密</h3><p>此时，我们有：</p><script type="math/tex; mode=display">n=p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}(p_1,p_2,p_3,\cdots ,p_k为k个不同质数)</script><p>此时，由欧拉函数的性质，我们有：</p><p>$\varphi(n)=\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}=n)$</p><p>由欧拉函数的计算公式我们可以知道：</p><script type="math/tex; mode=display">\varphi(p^k)=p^k\prod_{i=1}^{k}\bigg(1-\frac{1}{p^i}\bigg)</script><p>所以对于$n$，有：</p><script type="math/tex; mode=display">\varphi(n)=\prod_{i=1}^{k}p_i^{\alpha_i}\prod_{j = 1}^{\alpha_i}\bigg(1-\frac{1}{p_i^j}\bigg)</script><p>特别的，对于质数$p$，有：</p><script type="math/tex; mode=display">\varphi(p)=p\bigg(1-\frac{1}{p}\bigg)=p-1</script><p>若$n$为$k$个不相同质数相乘，即：</p><script type="math/tex; mode=display">n=p_1p_2p_3\cdots p_k</script><p>有：</p><script type="math/tex; mode=display">\varphi(n)=(p_1-1)(p_2-1)(p_3-1)\cdots(p_k-1)</script><p>在一般情况下$n$只有两个质因数$p$和$q$，例如下题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long,long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd,invert</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">p=<span class="number">274327862430236019688316864082249987313</span></span><br><span class="line">q=<span class="number">206961224895267889099693426679050192439</span></span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"><span class="comment"># c = 54831930044859946955044417597501651143196043923856762253170140444376354297816</span></span><br></pre></td></tr></table></figure><p>这题直接给出了$p$和$q$，故我们只需要写出如下代码即可解决：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = <span class="number">274327862430236019688316864082249987313</span></span><br><span class="line">q = <span class="number">206961224895267889099693426679050192439</span></span><br><span class="line">c = <span class="number">54831930044859946955044417597501651143196043923856762253170140444376354297816</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)<span class="comment">#求e模phi的乘法逆元</span></span><br><span class="line">m = gmpy2.powmod(c,d,n)<span class="comment">#等价于c^d mod n</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行即可得出flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;how_excellent_you_are!&#125;</span><br></pre></td></tr></table></figure><p>这就是最基本的RSA类型了。</p><h3 id="在已知e以及e组-n-c-的广播攻击"><a href="#在已知e以及e组-n-c-的广播攻击" class="headerlink" title="在已知e以及e组(n,c)的广播攻击"></a>在已知e以及e组(n,c)的广播攻击</h3><p>此类型攻击属于CRT（Chinese remainder theorem，中国剩余定理，又称孙子定理）类型。</p><p>原理不赘述，实质上即为已知$e$组$(n,c)$时利用CRT在不对任何一个$n$进行分解的情况下求解明文</p><p>在这里，我们设明文为$m$，有：</p><script type="math/tex; mode=display">\begin{cases}m^e\equiv c_1\ (mod\ n_1)\\m^e\equiv c_1\ (mod\ n_1)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\m^e\equiv c_e\ (mod\ n_e)\end{cases}\\\ \ \ (其中(n_1,c_1),(n_2,c_2),\cdots,(n_e,c_e)为e组不同的n与c)</script><p>再通过CRT求解出$m^e$后对其开$e$次方根即可得到明文$m$</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><h6 id="鹤城杯-2021-Crazy-Rsa-Tech"><a href="#鹤城杯-2021-Crazy-Rsa-Tech" class="headerlink" title="[鹤城杯 2021]Crazy_Rsa_Tech"></a>[鹤城杯 2021]Crazy_Rsa_Tech</h6><p>题目代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">FLAG = bytes_to_long(pad(<span class="string">b&quot;flag&#123;??????&#125;&quot;</span>,<span class="number">64</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_key</span>():</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">    n = p*q</span><br><span class="line">    e = <span class="number">9</span></span><br><span class="line">    <span class="keyword">while</span>(GCD((p-<span class="number">1</span>)*(q-<span class="number">1</span>),e)!=<span class="number">1</span>):</span><br><span class="line">        p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">        n = p*q</span><br><span class="line">    d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> n,e,d</span><br><span class="line"></span><br><span class="line">n_list=<span class="built_in">list</span>()</span><br><span class="line">c_list=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    N,e,d=init_key()</span><br><span class="line">    n_list.append(N)</span><br><span class="line">    c=<span class="built_in">pow</span>(FLAG,e,N)</span><br><span class="line">    c_list.append(<span class="built_in">pow</span>(FLAG,e,N))</span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">pow</span>(c,d,N)==FLAG)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n_list:&quot;</span>,n_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c_list:&quot;</span>,c_list)</span><br><span class="line"><span class="comment">#n_list= [71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799, 92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949, 100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919, 59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847, 66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147, 120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377, 72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281, 69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951, 76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581]</span></span><br><span class="line"><span class="comment">#c_list=[62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585, 46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900, 85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198, 14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656, 1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839, 2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981, 16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376, 31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996, 25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里很容易可以知道$e=9$（显而易见，$n$和$c$也有九组），所以很显然，这题要用到$e=9$的广播攻击</p><p>将上面给出的n_list和c_list用sagemath利用CRT求解得出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m9=<span class="number">3678337284039442047026947312380394506988284605153398380909870598085147736828709178219597429308046538374273111663234962853201175297522552444068549756304348183089003998584929250444862897734669616839072634559776823068102560978738392642133409979083241310818961120830565330801827594023873873703163937572703881578432281109467318674533265052430906776650900523035132668203491899352234368836316318216812572637893433384928785981896373747430646617935503364537613820302679656375356094380483213814869276308187497478084540603362678580814022322799191778371368875742773945120383365613028633102737056410926701477700008313642639347163933146129361496566648131161287075292980980083166106192999528561889437021539352391671756010617540361596164032486633114877739259434431765044242037641759566659268290619705700083536966807192023377334915872207418596226819579720241509860110741821630775501873143209229299530346706612248414951753383716954165108266753409813119293227854442685830689203424064786691447734948037502729127922328149002842971722645909768174575776908113523451541199095073733017029558396658874593357205426105429760517295964966905772455366037986657671195106462661190327510507460112791663031458690187525393979689469548319821181450874331998372947479866557921497942728807505035932385939931524294822439633516457845581452433022749099648076725811489217888688273759202726271093237450290814247396662589614216704</span><span class="comment">#m9为m的9次方</span></span><br></pre></td></tr></table></figure><p>再对$m9$开9次方根可得：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=<span class="number">5364346700993245916083351542951836466599376039702798829478182513243184146028312538778801523615449405915572188751896617305936540801999004614344621214275094</span></span><br></pre></td></tr></table></figure><p>再通过Crypto库中long_to_bytes函数可得：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;H0w_Fun_13_HAstads_broadca5t_AtTack!&#125;</span><br></pre></td></tr></table></figure><h3 id="gcd类型"><a href="#gcd类型" class="headerlink" title="gcd类型"></a>gcd类型</h3><p>这种类型主要考察数学推导的能力，直接上例题。</p><h4 id="GKCTF-2021-RRRRsa-1（部分）"><a href="#GKCTF-2021-RRRRsa-1（部分）" class="headerlink" title="[GKCTF 2021]RRRRsa 1（部分）"></a>[GKCTF 2021]RRRRsa 1（部分）</h4><p>题目代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pbits = <span class="number">512</span></span><br><span class="line">p, q = getPrime(pbits), getPrime(pbits)</span><br><span class="line">n = p * q</span><br><span class="line">hint1 = <span class="built_in">pow</span>(<span class="number">2020</span> * p + q, <span class="number">202020</span>, n)</span><br><span class="line">hint2 = <span class="built_in">pow</span>(<span class="number">2121</span> * p + <span class="number">212121</span>, q, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint1 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint2 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n =</span></span><br><span class="line"><span class="string">72480597722768310802103225074022304502987810353239303491995392556828592827312126864102279719480413772239054950810362120660174703790228376146053986053171930937388580526219104498648291397309599209554202670080978901954049943834889894306222459711036629282482760872552358198065124168348275611897584923869319730917</span></span><br><span class="line"><span class="string">hint1 =</span></span><br><span class="line"><span class="string">70685159982753618117937078087626553902610663214529331305611406765104333038200912863267956767277081926123480288270862897047313253820275507292683667878994502600957911694615683337770022569861106230373836250952155917286151237134316356851059293688768775787985566372022900108303136666429150678266857778726967849907</span></span><br><span class="line"><span class="string">hint2 =</span></span><br><span class="line"><span class="string">59397395285145715354919882069200896861665631746130494855994590508589325004636436593048816842106180115714527211321251497281171549276111388361451000025849056493942252398618018816656979043710894623882099581494083699322411790446784391932055982624616996747139852037848608960801937270797966812928286289985647495610</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以知道：</p><script type="math/tex; mode=display">hint1\equiv (2020p+q)^{202020}\ (mod\ n)\\hint2\equiv (2121p+212121)^{q}\ (mod\ n)</script><p>我们要从上面两个方程中求解$p$和$q$，下面进行数学推导：</p><p>首先观察hint1，由二项式定理有：</p><script type="math/tex; mode=display">(2020p+q)^{202020}=(2020p)^{202020}+(2020p)^{202019}q+\cdots+2020pq^{202019}+q^{202020}</script><p>显然的，右式除$(2020p)^{202020}$与$q^{202020}$两项外均能被$n$整除</p><p>所以有：</p><script type="math/tex; mode=display">hint1\equiv (2020p)^{202020}+q^{202020}\ (mod\ n)</script><p>进一步的，有：</p><script type="math/tex; mode=display">hint1\equiv(2020p)^{202020}\ (mod\ q)</script><p>现在看到hint2，有：</p><script type="math/tex; mode=display">hint2\equiv (2121p+212121)^q\ (mod\ q)</script><p>由费马小定理，可以得到：</p><script type="math/tex; mode=display">hint2\equiv 2121p+212121\ (mod\ q)</script><p>所以：</p><script type="math/tex; mode=display">(hint2-212121)^{202020}(2020)^{202020}\equiv (2020\cdot2021p)^{202020}\ (mod\ q)</script><p>对于hint1：</p><script type="math/tex; mode=display">hint1(2121)^{202020}\equiv (2020\cdot2021p)^{202020}\ (mod\ q)</script><p>故：</p><script type="math/tex; mode=display">hint1(2121)^{202020}-(hint2-212121)^{202020}(2020)^{202020}\equiv 0\ (mod\ q)</script><p>所以有：</p><script type="math/tex; mode=display">kq=hint1(2121)^{202020}-(hint2-212121)^{202020}(2020)^{202020}</script><p>由于$n=pq$</p><p>所以$gcd(kq,n)=$</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n = <span class="number">72480597722768310802103225074022304502987810353239303491995392556828592827312126864102279719480413772239054950810362120660174703790228376146053986053171930937388580526219104498648291397309599209554202670080978901954049943834889894306222459711036629282482760872552358198065124168348275611897584923869319730917</span></span><br><span class="line">hint1 = <span class="number">70685159982753618117937078087626553902610663214529331305611406765104333038200912863267956767277081926123480288270862897047313253820275507292683667878994502600957911694615683337770022569861106230373836250952155917286151237134316356851059293688768775787985566372022900108303136666429150678266857778726967849907</span></span><br><span class="line">hint2 = <span class="number">59397395285145715354919882069200896861665631746130494855994590508589325004636436593048816842106180115714527211321251497281171549276111388361451000025849056493942252398618018816656979043710894623882099581494083699322411790446784391932055982624616996747139852037848608960801937270797966812928286289985647495610</span></span><br><span class="line">kq = gmpy2.powmod(<span class="number">2121</span>,<span class="number">202020</span>,n)*hint1-gmpy2.powmod((hint2-<span class="number">212121</span>)*<span class="number">2020</span>,<span class="number">202020</span>,n)</span><br><span class="line">q = gmpy2.gcd(kq,n)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure><p>这样就得出了$q$，由此我们就可以顺带求出$p$了。</p><p>（还有道题是Geek Challenge 2023的Poly_RSA，但是在写笔记的时候比赛还没结束，就不放出来了，后面写wp的时候再讲推导过程）</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深大Aurora第一批入队赛WP</title>
      <link href="/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/"/>
      <url>/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/</url>
      
        <content type="html"><![CDATA[<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><hr><h2 id="简单丢番图方程（解题成本最高的一道）"><a href="#简单丢番图方程（解题成本最高的一道）" class="headerlink" title="简单丢番图方程（解题成本最高的一道）"></a>简单丢番图方程（解题成本最高的一道）</h2><p>（其实就是一道二元二次不定方程问题）</p><p>这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决.</p><p>刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;None&#125;</span><br></pre></td></tr></table></figure><p>我以为这是对的，交上去发现是错的</p><p>后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤大致如下：</p><h3 id="打开虚拟机（这是要讲的吗）"><a href="#打开虚拟机（这是要讲的吗）" class="headerlink" title="打开虚拟机（这是要讲的吗）"></a>打开虚拟机<del>（这是要讲的吗）</del></h3><h3 id="在虚拟机中打开靶机"><a href="#在虚拟机中打开靶机" class="headerlink" title="在虚拟机中打开靶机"></a>在虚拟机中打开靶机</h3><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938767.png" alt="picture1"></p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>在这里我们可以看到一个比较大的数和一条很像勾股定理的方程，所以我们可以断定这题要用到勾股定理，而我们知道的勾股数就那么几对，所以我们可以通过质因数分解找出我们熟悉的勾股数，现在我们打开factordb，将这个已知的数进行质因数分解，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938627.png" alt="picture2"></p><p>啊？怎么是个质数？运气太差了吧QwQ（我发誓不是节目效果）</p><p>遇到这种情况，我们直接重开一把（这个数是随机生成的）</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938955.png" alt="picture3"></p><p>这回就出来了</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938258.png" alt="picture4"></p><p>不幸的是，对于这个数的较小质因数4289，我们好像很难找出一组适合的勾股数（不一定是不存在，就是难找）</p><p>那么再重开一把：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111924525.png" alt="picture5"></p><p>很好，这次质因数分解后得到了我们想要的小质数</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111924541.png" alt="picture6"></p><p>而我们知道</p><script type="math/tex; mode=display">(5,12,13)</script><p>是一组常见的勾股数，所以我们丢进计算器中可以算出：</p><script type="math/tex; mode=display">x=304168011786560/5*12=730003228287744</script><script type="math/tex; mode=display">y=304168011786560/5*13=790836830645056</script><p>这个时候我们把结果提交到靶机就可以得到我们想要的flag啦！</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938758.png" alt="final"></p><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;ebd8bc51-2d57-406e-bcab-f601cfcb6924&#125;</span><br></pre></td></tr></table></figure><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>这道题我觉得要改进的话应该数字搞大一点，锻炼Python编程能力</p><hr><h2 id="baby-RSA"><a href="#baby-RSA" class="headerlink" title="baby_RSA"></a>baby_RSA</h2><p>这题还是比较简单的，只涉及到大数分解问题</p><p>先贴一下加密的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;**************************&#125;&#x27;</span></span><br><span class="line">secret = bytes_to_long(flag)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    p = getPrime(<span class="number">64</span>)</span><br><span class="line">    n *= p</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = &#x27;</span>, n)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(secret, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = &#x27;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = &#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n =  2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c =  1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在《初等数论（第四版）》（闵嗣鹤，严士健编）对于RSA公钥体系的描述中（应该很多讲密码的书都是这样）</p><script type="math/tex; mode=display">n=pq(p,q是两个大质数)</script><p>但是将上面的n丢进factordb（谢谢学姐提供的数据）之后，它出现了16个不同的质因数（其实从代码中也可以看出）！那要怎么办呢？</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938273.png" alt="picture1"></p><p>实际上，在RSA公钥体系中，将密码转化为明码需要求解下列同余方程</p><script type="math/tex; mode=display">b^d\equiv a^{ed}\equiv a^{1+k\varphi(n)}(modn)(e为密钥，n为解钥，b为密码，a为明码)</script><p>而对于欧拉函数，有如下定理：</p><script type="math/tex; mode=display">\varphi(n)=\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}=n)</script><p>而对于质数p，其欧拉函数值为：</p><script type="math/tex; mode=display">\varphi(p)=p-1</script><p>所以对于对于题中解钥n，有：</p><script type="math/tex; mode=display">\varphi(n)=(p_1-1)(p_2-1)(p_3-1)\cdots(p_{16}-1)(p_1,p_2,p_3,\cdots,p_{16}为n的16个不同的质因数</script><p>所以我们可以写出获得flag的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p1=<span class="number">11032741923171941087</span></span><br><span class="line">p2=<span class="number">11545653624202476473</span></span><br><span class="line">p3=<span class="number">11636293469353905931</span></span><br><span class="line">p4=<span class="number">11791412171539768003</span></span><br><span class="line">p5=<span class="number">12072682976194265431</span></span><br><span class="line">p6=<span class="number">12286985218370609161</span></span><br><span class="line">p7=<span class="number">13979567880622268887</span></span><br><span class="line">p8=<span class="number">14381447749489789777</span></span><br><span class="line">p9=<span class="number">14487171289353351409</span></span><br><span class="line">p10=<span class="number">14573688259437788669</span></span><br><span class="line">p11=<span class="number">15652738194884126429</span></span><br><span class="line">p12=<span class="number">16034270403328241087</span></span><br><span class="line">p13=<span class="number">16631285257180468447</span></span><br><span class="line">p14=<span class="number">17327252249988599903</span></span><br><span class="line">p15=<span class="number">17905457523849945107</span></span><br><span class="line">p16=<span class="number">18027152598391207147</span></span><br><span class="line">n=<span class="number">2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line">phi=(p1-<span class="number">1</span>)*(p2-<span class="number">1</span>)*(p3-<span class="number">1</span>)*(p4-<span class="number">1</span>)*(p5-<span class="number">1</span>)*(p6-<span class="number">1</span>)*(p7-<span class="number">1</span>)*(p8-<span class="number">1</span>)*(p9-<span class="number">1</span>)*(p10-<span class="number">1</span>)*(p11-<span class="number">1</span>)*(p12-<span class="number">1</span>)*(p13-<span class="number">1</span>)*(p14-<span class="number">1</span>)*(p15-<span class="number">1</span>)*(p16-<span class="number">1</span>)<span class="comment">#很蠢的方法，一个一个填</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行程序，我们就可以得到flag啦！</p><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;RS4_1s_r3a1y_fun_4nd_ea5y!&#125;</span><br></pre></td></tr></table></figure><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>善用百度，Python真好用，还有，数论真好玩。</p><hr><h2 id="你爱深大吗"><a href="#你爱深大吗" class="headerlink" title="你爱深大吗"></a>你爱深大吗</h2><p>（最抽象的一道）</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938612.png" alt="picture1"></p><h3 id="解题过程及思路"><a href="#解题过程及思路" class="headerlink" title="解题过程及思路"></a>解题过程及思路</h3><p>这本质上是一道阅读题</p><p>刚开始，我看到下面的藏宝图这么抽象，我就知道：这题必有Base100！</p><p>后来再看一眼上面的小作文，我在里面找到了偏移值为6的凯撒密码，18层栅栏密码和一个密钥为”iloveszu”的维吉尼亚密码</p><p>故我试着解密</p><p>解密过程：Base100-&gt;偏移值为6的凯撒密码-&gt;18层的栅栏密码-&gt;密钥为”iloveszu”的维吉尼亚密码</p><p>解密出来长这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;JTpnwk$VLB%p:?CR&amp;QIH:]An&gt;Zz;#CAg&lt;f37;$IZXvZ2INm;MS\0@Cg`c@It4892#G?&lt;mftRsQ,t;&gt;Fsxd&lt;2o_&#x27;:f@TSj&gt;!&#x27;BM+%`5&gt;$&quot;.qrET&lt;K9vaE?@W`&quot;1;89%@JbhgeACT9$;3KE\&lt;O9n(;aNA!@5tl1;WiC@5=BJX:];z-&gt;5/(V;7&lt;Gk_V%.!&lt;i:#?=tJOu*g/@s97T(E=n&#x27;%GJMF):M8</span><br></pre></td></tr></table></figure><p>这一看就不是flag</p><p>后来（一天后）经过指点及思考我发现了“冲破了基地的重重阻碍”中的“重重”二字，所以就尝试一下多重Base解码吧</p><p>经过尝试，对“Base”步骤解码过程如下：</p><p>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32</p><h5 id="解码结果："><a href="#解码结果：" class="headerlink" title="解码结果："></a>解码结果：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bky__cuuiwlz_zpwo&#123;taIkppbxywe__w&#125;st_hupzodnzht__t_ymhcicpfm</span><br></pre></td></tr></table></figure><p>解码出来发现出现了花括号和下划线，证明步骤应该是对了。</p><p>继续解密</p><p>根据上面的步骤，我们继续这条从偏移值为6的凯撒密码到18层的栅栏密码再到密钥为”iloveszu”的维吉尼亚密码的解密过程</p><p>解密出来如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N_r_uHfa_&#125;_kdt_hioaerz&#123;wkc_rxbitfvoeowgpfyddmvpol__qil_kbra</span><br></pre></td></tr></table></figure><p>完全不对，连格式（Aurora{___}）都不对，而上面的加密方式中而可以改变符号位置的只有栅栏密码，而我在搜索引擎里面发现了一种不同的栅栏密码——W型。</p><p>在尝试之后，我发现再次经过上述解码方式后得出了如下字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nhihpr&#123;Dpk_bacj_eaik_wvs_mdfti_fa_j_knuomyddm_bu_movvgjjjh&#125;</span><br></pre></td></tr></table></figure><p>格式总算是正确了，但是为什么连关键的Aurora都没有出现呢？</p><p>我发现可能是凯撒密码的问题</p><p>后来我尝试偏移值为666的凯撒密码（实际上偏移值是16）</p><p>然后再进行上述步骤得到了如下字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dxyxfh&#123;Tfa_rqsz_uqya_mli_ctvjy_vq_z_adkecottc_rk_cellwzzzx&#125;</span><br></pre></td></tr></table></figure><p>发现还是不对</p><p>退回维吉尼亚密码前一步，我发现在解维吉尼亚密码之前的密文是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Limsjz&#123;Szi_cend_mpsi_xzd_gludg_ge_u_evjykzhog_jj_wmwzrdryr&#125;</span><br></pre></td></tr></table></figure><p>第一个是L，对照维吉尼亚密码表，我们可以发现，如果要从A得到L（因为我们猜测明文的第一个字母为A），那么密钥应为L</p><p>也就是说，维吉尼亚密码的密钥开头应该为L而不是I</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111928296.png" alt="密码表"></p><p>再次解密，得到如下字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;You_have_seen_the_magic_of_a_thousands_of_encodings&#125;</span><br></pre></td></tr></table></figure><p>这个就是flag了。</p><p>所以这道题的步骤为：</p><h3 id="Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-偏移值为666（即16）的凯撒密码-gt-18层的W型栅栏密码-gt-密钥为”loveszu”的维吉尼亚密码"><a href="#Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-偏移值为666（即16）的凯撒密码-gt-18层的W型栅栏密码-gt-密钥为”loveszu”的维吉尼亚密码" class="headerlink" title="Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码"></a>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码</h3><hr><h2 id="AAAEEESSS"><a href="#AAAEEESSS" class="headerlink" title="AAAEEESSS"></a>AAAEEESSS</h2><p>先读代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag   </span><br><span class="line"><span class="comment">#flag从一个神秘的地方获得</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;welcometoAurora!&#x27;</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv=key)</span><br><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enc_flag = &quot;</span>, aes.encrypt(pad(flag, <span class="built_in">len</span>(key))).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">enc_flag =  de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们会发现这是CBC模式的AES加密，flag可能是下面的16进制字串解密而来的，通过搜索，我们发现有一个工具可以解密AES：</p><p><a href="https://www.mklab.cn/utils/aes">AES在线加密解密工具 - MKLab在线工具</a></p><p>而阅读上面的代码，我们可以知道偏移向量和密钥均为<u>welcometoAurora!</u>将这两个东西放进去对应的地方，解码发现他出现了如下乱码:</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111928937.png" alt="解密1"></p><p>是否是我的方法出了问题呢？</p><p>继续读代码，我们可以看到一个刚才被忽略的东西：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br></pre></td></tr></table></figure><p>这串代码我们可以猜测是在Could u slove this challenge?加密后16进制字串后面拼接一条什么东西（AES加密的填充机制和密码长度规律）。</p><p>所以我们可以试着先将Could u slove this challenge?进行AES加密，得到如下密文串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546</span><br></pre></td></tr></table></figure><p>在后面拼接代码中enc_flag部分如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span><br></pre></td></tr></table></figure><p>再放入密码输入框中解密可得：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could u solve this challenge?Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure><p>这样就得到了flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="qsdz的密码学衔接课（赛后复现）"><a href="#qsdz的密码学衔接课（赛后复现）" class="headerlink" title="qsdz的密码学衔接课（赛后复现）"></a>qsdz的密码学衔接课（赛后复现）</h2><p>这题由三小题组成，分别是：求解同余方程，求解同余方程组，求解离散对数问题。</p><p>而这三个问题，我们都要利用到一个重要工具：sagemath</p><p>下面我们分别求解三个问题：</p><h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">x: <span class="built_in">int</span>, order: <span class="built_in">int</span></span>):</span><br><span class="line">    p = getPrime(x.bit_length() * order)</span><br><span class="line">    A = [getPrime(x.bit_length()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(order)]</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(order):</span><br><span class="line">        y = (y + A[i] * x ** i) % p</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 1&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;p = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;A = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">==========Challenge 1==========</span></span><br><span class="line"><span class="string">p = 140540932516518794145151934666843219294863335242957071370416678765850106203805810862867703792863302163318519910426474343219910841109958974959958710112904675289540046802486139135135963299678067328274525866708889478446402107588914151782335913</span></span><br><span class="line"><span class="string">A = [586077106161933115521158870621277482378849813647,</span></span><br><span class="line"><span class="string">594177621805167358745968527276343722485294425499, </span></span><br><span class="line"><span class="string">438154568295734958683230212377930413557186542591,</span></span><br><span class="line"><span class="string">613916554223827544243334495150247792479839893207,</span></span><br><span class="line"><span class="string">696514075788803577127407605798057483933441939039]</span></span><br><span class="line"><span class="string">y = 13584348643332560556129513295162939264971165296317907991475444036286814596235852842416707036226141464730561542976865467336771619592932663214739700885173786520323855676418761763774305698027356758972580332479097742926600081856865297421280491</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出，这里的同余方程为：</p><script type="math/tex; mode=display">A_0+A_1x+A_2x^2+A_3x^3+A_4x^4\equiv y(mod\ p)</script><p>所以我们在sagemath中对该方程做出如下定义：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R.&lt;x&gt;=Zmod(p)[]</span><br><span class="line">f=A[<span class="number">0</span>]+A[<span class="number">1</span>]*x+A[<span class="number">2</span>]*x^<span class="number">2</span>+A[<span class="number">3</span>]*x^<span class="number">3</span>+A[<span class="number">4</span>]*x^<span class="number">4</span>-y</span><br></pre></td></tr></table></figure><p>再通过下面一段代码进行求解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.roots()</span><br></pre></td></tr></table></figure><p>可以得出下面两个解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x_1=98641516410644248590730760547711915061873706589456407188998882763190683930094458978790759787796637145415287953931944776332655673057814076619504993207500838191433321143407475719143239135946766090781645970151825507798503659865125167544876679</span><br><span class="line">x_2=373703556015754746532223260569877349038577184359</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至于是哪个解，我们到后面再讨论。</p><h3 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">x: <span class="built_in">int</span>, number: <span class="built_in">int</span></span>):</span><br><span class="line">    ps = [getPrime(x.bit_length() // (number - <span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line">    ys = [x % p <span class="keyword">for</span> p <span class="keyword">in</span> ps]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 2&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ps = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ys = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ps = [288186237701, 283710289297, 488405307827, 284002449103, 433963503397]</span></span><br><span class="line"><span class="string">ys = [229627846199, 206465857548, 461943583630, 18924375666, 173733924485]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>我们很容易可以写出上述代码的等价方程组：</p><script type="math/tex; mode=display">\begin{cases}        x\equiv229627846199(mod\ 288186237701)\\        x\equiv206465857548(mod\ 283710289297)\\        x\equiv461943583630(mod\ 488405307827)\\        x\equiv18924375666(mod\ 284002449103)\\        x\equiv173733924485(mod\ 433963503397)\end{cases}</script><p>求解这种传统不定方程组需要利用一个定理——孙子定理（中国剩余定理/CRT），在sagemath中输入下列指令：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crt(ys,ps)</span><br></pre></td></tr></table></figure><p>可以得到下列解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">653438615351908597859575533851627354929851494003</span><br></pre></td></tr></table></figure><p>设上面的数字为y，则上述方程组等价于：</p><script type="math/tex; mode=display">x\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)</script><p>我们可以验证：</p><script type="math/tex; mode=display">gcd(y,ps_0ps_1ps_2ps_3ps_4)=1</script><p>根据同余方程的性质，我们可以知道还有其他的解：</p><script type="math/tex; mode=display">y+k\cdot ps_0ps_1ps_2ps_3ps_4\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)</script><p>先假定需要的解就是上面的y。</p><h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><p><del>又是同余方程</del></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">x: <span class="built_in">int</span></span>):</span><br><span class="line">    base = getPrime(x.bit_length())</span><br><span class="line">    exp = getRandomInteger(<span class="number">40</span>)</span><br><span class="line">    module = getPrime(x.bit_length())</span><br><span class="line">    y = <span class="built_in">pow</span>(base, exp, module)</span><br><span class="line">    cipher = exp * x % module</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 3&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;base = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;module = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;cipher = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">base = 410736349593916097049313683889292166618005625707</span></span><br><span class="line"><span class="string">module = 644953605408967844199642272144415528955561551061</span></span><br><span class="line"><span class="string">y = 242650313731015062596916881403616976177380555988</span></span><br><span class="line"><span class="string">cipher = 398635925008029999138603615357303867027885126384</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>求解上述离散对数，其实就是求解下列同余方程：</p><script type="math/tex; mode=display">base^{exp}\equiv y(mod\ module)</script><p>而上述方程中，又有：</p><script type="math/tex; mode=display">exp\cdot x\equiv cipher(mod\ module)</script><p>现在我们要求解未知数x，所以我们需要先求出exp</p><p>在sagemath中使用以下指令：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exp = discrete_log_lambda(mod(y, module), mod(base, module), bounds=(<span class="number">2</span>**<span class="number">39</span>, <span class="number">2</span>**<span class="number">40</span>))</span><br></pre></td></tr></table></figure><p>可得</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exp=<span class="number">940420210186</span></span><br></pre></td></tr></table></figure><p>再通过下面的指令求出x：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cipher * inverse_mod(exp, module) % module</span><br></pre></td></tr></table></figure><p>可得解为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">545012220020390134376571283157248116812656615805</span><br></pre></td></tr></table></figure><h3 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h3><p>阅读题中代码的最上面部分：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">b&#x27;Aurora&#123;qsdzyyds&#125;&#x27;</span></span><br><span class="line">part_number = <span class="built_in">len</span>(flag) // <span class="number">3</span></span><br><span class="line">flag_part1 = bytes_to_long(flag[:part_number])</span><br><span class="line">flag_part2 = bytes_to_long(flag[part_number:<span class="number">2</span>*part_number])</span><br><span class="line">flag_part3 = bytes_to_long(flag[<span class="number">2</span>*part_number:])</span><br></pre></td></tr></table></figure><p>我们可以知道，flag的三部分应该长度一致，所以对于同余方程与同余方程组部分的解应该与离散对数相同，所以有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag1=<span class="number">373703556015754746532223260569877349038577184359</span></span><br><span class="line">flag2=<span class="number">653438615351908597859575533851627354929851494003</span></span><br><span class="line">flag3=<span class="number">545012220020390134376571283157248116812656615805</span></span><br></pre></td></tr></table></figure><p>我们可以通过下面的代码求出flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(long_to_bytes(flag1))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag2))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag3))</span><br></pre></td></tr></table></figure><p>可以得出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;Aurora&#123;Sagem4th&amp;c0ng&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ru3nce_and_e9uations&#x27;</span></span><br><span class="line"><span class="string">b&#x27;_w1th_di5crete_lOg!&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;Sagem4th&amp;c0ngru3nce_and_e9uations_w1th_di5crete_lOg!&#125;</span><br></pre></td></tr></table></figure><p>至此，衔接题就解决了。</p><hr><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><hr><h2 id="Basic-nc"><a href="#Basic-nc" class="headerlink" title="[Basic]nc"></a>[Basic]nc</h2><p>直接打开靶机</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938881.png" alt="picture1"></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111931005.png" alt="picture2"></p><p>看到有个flag，输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat flag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938471.png" alt="picture3"></p><p>flag就出来了。</p><h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;ce8bf21a-3c2e-49f3-b27b-86440b8e8dd9&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Advanced-寰宇蝗灾"><a href="#Advanced-寰宇蝗灾" class="headerlink" title="[Advanced]寰宇蝗灾"></a>[Advanced]寰宇蝗灾</h2><p><del>（我就想玩个游戏，为什么会拿到这题的一血）</del></p><p>直接打开靶机！</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938268.png" alt="picture1"></p><p>直接攻击</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938360.png" alt="picture2"></p><p>玩着玩着虫子的数量出现了负数，这个时候我们就可以知道，这题利用的是数据溢出的漏洞，那我们逮着这个漏洞打就行了，多打几遍就会出现下面的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938852.png" alt="picture3"></p><p>还真是溢出<del>（至于怎么溢出的我也不清楚）</del></p><p>现在flag就出来了。</p><h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;8fae9274-d452-4f64-966e-024584b8a8d1&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><hr><h2 id="Basic-消失的原神"><a href="#Basic-消失的原神" class="headerlink" title="[Basic]消失的原神"></a>[Basic]消失的原神</h2><p><del>（我刚开始真的以为下载个原神就可以拿到flag）</del></p><p>首先将消失的原神.exe文件拖到ida64中</p><p>按下Shift+F12进入string页面</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111932558.png" alt="picture1"></p><p>上面就是我们要的flag了</p><h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;D0_u_P1a_G3nsh1n_iMpact&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Basic-148464"><a href="#Basic-148464" class="headerlink" title="[Basic]148464"></a>[Basic]148464</h2><p>先拖进ida64，直接飞去main按F5进行一个编译</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938413.png" alt="picture1"></p><p>观察下列代码我们可以看到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&quot;</span>) )</span><br></pre></td></tr></table></figure><p>发现flag在一系列未知的操作后变成了字符串”zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”。</p><p>现在我们要找到flag怎么变才能变成上述字符串。</p><p>我们阅读如下代码，可知flag是一个长度为24的字符串</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%24s&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>再次阅读代码，我们发现s被丢进下面的函数里面进行过操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v5 - <span class="number">2</span> &gt; dword_4124 )</span><br><span class="line"> &#123;</span><br><span class="line">    sub_12F0((<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">1</span>], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">2</span>]);</span><br><span class="line">    dword_4124 += <span class="number">3</span>;</span><br><span class="line">    dword_4128 += <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>双击进入函数sub_12F0，我们看到这个函数进行的是如下操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_12F0</span><span class="params">(<span class="type">char</span> a1, <span class="type">char</span> a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  </span><br><span class="line">  s1[dword_4128] = aAbcdefghijklmn[a1 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">1</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">16</span> * a1) | (<span class="type">unsigned</span> __int8)(a2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">2</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">4</span> * a2) | (<span class="type">unsigned</span> __int8)(a3 &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  result = dword_4128 + <span class="number">3</span>;</span><br><span class="line">  s1[result] = aAbcdefghijklmn[a3 &amp; <span class="number">0x3F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以知道，其实这就是Base64的加密，但是当我将“zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”丢进Base64之后会见到一坨不明所以的无意义字符串，所以要思考是不是遗漏了什么。</p><p>再次阅读代码，可以发现在加密前有一个不明函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sub_1234();</span><br></pre></td></tr></table></figure><p>点进去我们可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1234</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[j], &amp;aAbcdefghijklmn[j + <span class="number">26</span>]);</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[k + <span class="number">52</span>], &amp;aAbcdefghijklmn[k + <span class="number">58</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，参与加密操作的字符串aAbcdefghijklmn是被修改过的！！</p><p>里面还有一个修改的函数为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">sub_1169</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+1Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v3 = *a1;</span><br><span class="line">  *a1 = *a2;</span><br><span class="line">  result = a2;</span><br><span class="line">  *a2 = v3;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个sub_1169函数的作用是交换a1和a2。</p><p>而直接查看内存，我们可以看到字符串aAbcdefghijklmn的值如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br></pre></td></tr></table></figure><p>我们重写上面的C语言修改字符串代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">65</span>] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[j];</span><br><span class="line">            a[j] = a[j + <span class="number">26</span>];</span><br><span class="line">            a[j + <span class="number">26</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[k + <span class="number">52</span>];</span><br><span class="line">            a[k + <span class="number">52</span>] = a[k + <span class="number">58</span>];</span><br><span class="line">            a[k + <span class="number">58</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到aAbcdefghijklmn的新值为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&quot;</span></span><br></pre></td></tr></table></figure><p>我们上搜索引擎找到Base64解码算法（Python比较方便，所以用了Python）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">STANDARD_ALPHABET = <span class="string">b&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#标准加密表</span></span><br><span class="line">CUSTOM_ALPHABET = <span class="string">b&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&#x27;</span><span class="comment">#修改后的加密表</span></span><br><span class="line">ENCODE_TRANS = <span class="built_in">bytes</span>.maketrans(STANDARD_ALPHABET, CUSTOM_ALPHABET)</span><br><span class="line">DECODE_TRANS = <span class="built_in">bytes</span>.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="built_in">input</span>).translate(ENCODE_TRANS)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(<span class="built_in">input</span>.translate(DECODE_TRANS))</span><br><span class="line"></span><br><span class="line">a=<span class="string">b&#x27;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&#x27;</span><span class="comment">#密文</span></span><br><span class="line">destr = decode(a)</span><br><span class="line"><span class="built_in">print</span>(destr.decode())</span><br></pre></td></tr></table></figure><p>运行可得flag如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;tH1s_iS_3z_base_64&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Advanced-爱门"><a href="#Advanced-爱门" class="headerlink" title="[Advanced]爱门"></a>[Advanced]爱门</h2><p><del>（爱门✝）</del></p><p>先将它放进ida64反编译，进入main点击F5进行编译。</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938312.png" alt="main"></p><p>我们可以看到，获取flag的前置步骤是解出byte_4060，点进sub_134A函数，我们可以见到byte_4060被一定的规矩转换成了byte_40A0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sub_134A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = byte_4060[i];</span><br><span class="line">    byte_40A0[i] = v0 + aTheresa[i % <span class="built_in">strlen</span>(aTheresa)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而参与了转换的函数为aTheresa<del>（一只德莉莎？）</del>，双击这个字符数组我们可以看到aTheresa的值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aTheresa        db <span class="string">&#x27;Theresa&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>转换为C++我们可以知道：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string aTheresa=<span class="string">&quot;Theresa&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们只知道这样一个类似维吉尼亚密码的密钥没有任何实质性作用，我们需要找出被加密后的字符串。点进main中的sub_1281函数，可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1281</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = byte_4020[i];</span><br><span class="line">    <span class="keyword">if</span> ( byte_40A0[i] != (_BYTE)result )</span><br><span class="line">      dword_403C = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以见到，这边要得到byte_40A0，则需要先知道byte_4020是如何定义的，点开byte_4020我们可以看到它所在的那行是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">byte_4020       db <span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span></span><br></pre></td></tr></table></figure><p>它只有七个数据，但是byte_40A0需要26个数据，怎么办呢？</p><p>结合指针知识，数组的数据是存储在连续的地址里面的，如果一个指针指向一个数组，当指针指向的数组下标超过了数组范围时，它就会指向数组最后一个元素所在地址后面紧接着的地址，所以我们放大视野，就可以看到下面的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938044.png" alt="data (2)"></p><p>刚刚好有26个数据，且跟其他的数据的地址没有冲突，所以用C++写下列代码进行解密的尝试：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;</span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a1[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，我们可以得出下面一个看似合理的“flag”：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;Elysia_is_dead????&#125;</span><br></pre></td></tr></table></figure><p><del>爱莉希雅死了？？？？</del></p><p>提交发现是错的，肯定是我们忽略了什么。</p><p>我们唯一没看过的就是左边的函数列了</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938479.png" alt="function_list"></p><p>这里有很多不知道是什么的函数，我们一个一个看，可以发现函数sub_12CE里面有修改上面的数组中数据的代码（变量命名对应）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sub_12CE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(byte_4060, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">  result = <span class="built_in">memset</span>(byte_40A0, <span class="number">0</span>, <span class="keyword">sizeof</span>(byte_40A0));</span><br><span class="line">  byte_4030 = <span class="number">-45</span>;</span><br><span class="line">  byte_4031 = <span class="number">-103</span>;</span><br><span class="line">  byte_4032 = <span class="number">-39</span>;</span><br><span class="line">  byte_4033 = <span class="number">-46</span>;</span><br><span class="line">  byte_4034 = <span class="number">-59</span>;</span><br><span class="line">  byte_4035 = <span class="number">-71</span>;</span><br><span class="line">  byte_4036 = <span class="number">-55</span>;</span><br><span class="line">  byte_4037 = <span class="number">-55</span>;</span><br><span class="line">  byte_4038 = <span class="number">-109</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用此处代码对上述解密代码进行修改：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a2[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后又给出了一个看似合理的“flag”：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;Elysia_isn&#x27;t_dead!&#125;</span><br></pre></td></tr></table></figure><p><del>爱莉希雅没有死！</del></p><p>提交发现，他还是错的。似乎我们还是有所遗漏。</p><p>继续把我们的目光放到函数列上，我们会发现，在main函数后，还有一个名为sub_144F的函数，它跟sub_12CE发挥的效果是相似的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_144F</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  byte_4027 = <span class="number">-121</span>;</span><br><span class="line">  byte_402B = <span class="number">-106</span>;</span><br><span class="line">  byte_402E += <span class="number">10</span>;</span><br><span class="line">  byte_402F -= <span class="number">31</span>;</span><br><span class="line">  byte_4030 = <span class="number">-106</span>;</span><br><span class="line">  byte_4031 = <span class="number">-34</span>;</span><br><span class="line">  byte_4032 -= <span class="number">8</span>;</span><br><span class="line">  byte_4034 -= <span class="number">3</span>;</span><br><span class="line">  byte_4035 = <span class="number">-64</span>;</span><br><span class="line">  byte_4036 = <span class="number">-47</span>;</span><br><span class="line">  byte_4037 = <span class="number">-69</span>;</span><br><span class="line">  byte_4038 = <span class="number">-41</span>;</span><br><span class="line">  dword_403C = <span class="number">1</span>;</span><br><span class="line">  sub_1281();</span><br><span class="line">  <span class="keyword">if</span> ( dword_403C == <span class="number">1</span> )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Nice, job! U find it!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;What wrong with U? U didn&#x27;t find it! where is it?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且我们可以发现它还判断了变量dword_403C的大小，通过前面的阅读，我们可以发现，dword_403C只有在输入的字符串是正确的flag的时候才是1，参考上面的代码对解密代码进行修改如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//一次修改后</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">-121</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">-106</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">199</span>, <span class="number">188</span>, <span class="number">-106</span>, <span class="number">-34</span>, <span class="number">-47</span>, <span class="number">-46</span>, <span class="number">-62</span>, <span class="number">-64</span>, <span class="number">-47</span>, <span class="number">-69</span>, <span class="number">-41</span>, <span class="number">226</span>&#125;;<span class="comment">//二次修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a3[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，我们可以得到如下flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aurora&#123;3lys1a_sT1ll_aliVe&#125;</span><br></pre></td></tr></table></figure><p><del>爱莉希雅还活着</del></p><p>提交发现这个是真正的flag，至此，我们就解决了这道题。</p><hr><h2 id="Block-Chain"><a href="#Block-Chain" class="headerlink" title="Block Chain"></a>Block Chain</h2><hr><h2 id="easy-契约"><a href="#easy-契约" class="headerlink" title="[easy]契约"></a>[easy]契约</h2><p>这题利用的是合约创建字节码泄露。</p><p><del>需要挂梯子</del></p><p>进入网站：<a href="https://sepolia.etherscan.io/">TESTNET Sepolia (ETH) Blockchain Explorer (etherscan.io)</a></p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938033.png" alt="Exploer"></p><p>在搜索框中输入题中给出合约并搜索：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938458.png" alt="heyue"></p><p>点进合约对应的交易之后找到“Input data”一栏，在“View input as”处选择“UTF-8”就可以看到这样一坨：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111935175.png" alt="flag"></p><p>里面蕴含了我们要的flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;W3lc0me_2_Blockch4in!!!&#125;</span><br></pre></td></tr></table></figure><p>注意：在提交的时候，flag的最后可能有一个不可见字符，需要删掉。</p>]]></content>
      
      
      <categories>
          
          <category> 信安WP </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
