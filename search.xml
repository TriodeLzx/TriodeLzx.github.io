<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XYCTF 2025 部分题目Write Up</title>
      <link href="/2025/04/10/XYCTF-2025-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWrite-Up/"/>
      <url>/2025/04/10/XYCTF-2025-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWrite-Up/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年明明说以后都不打这比赛的，今年还是来打了_(:3 」∠ )_</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="Division"><a href="#Division" class="headerlink" title="Division"></a>Division</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----Welcome to my division calc----&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">menu:  </span></span><br><span class="line"><span class="string">      [1]  Division calc      </span></span><br><span class="line"><span class="string">      [2]  Get flag</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    choose = <span class="built_in">input</span>(<span class="string">&#x27;: &gt;&gt;&gt; &#x27;</span>)  </span><br><span class="line">    <span class="keyword">if</span> choose == <span class="string">&#x27;1&#x27;</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            denominator = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;input the denominator: &gt;&gt;&gt; &#x27;</span>))  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;INPUT NUMBERS&#x27;</span>)  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        nominator = random.getrandbits(<span class="number">32</span>)  </span><br><span class="line">        <span class="keyword">if</span> denominator == <span class="string">&#x27;0&#x27;</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NO YOU DONT&#x27;</span>)  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nominator&#125;</span>//<span class="subst">&#123;denominator&#125;</span> = <span class="subst">&#123;nominator//denominator&#125;</span>&#x27;</span>)  </span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;2&#x27;</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            ans = <span class="built_in">input</span>(<span class="string">&#x27;input the answer: &gt;&gt;&gt; &#x27;</span>)  </span><br><span class="line">            rand1 = random.getrandbits(<span class="number">11000</span>)  </span><br><span class="line">            rand2 = random.getrandbits(<span class="number">10000</span>)  </span><br><span class="line">            correct_ans = rand1 // rand2  </span><br><span class="line">            <span class="keyword">if</span> correct_ans == <span class="built_in">int</span>(ans):  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WOW&#x27;</span>)  </span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&#x27;Here is your flag: <span class="subst">&#123;f.read()&#125;</span>&#x27;</span>)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;NOPE, the correct answer is <span class="subst">&#123;correct_ans&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;INPUT NUMBERS&#x27;</span>)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Invalid choice&#x27;</span>)</span><br></pre></td></tr></table></figure><p>MT19937随机数状态预测，分母全部输出1就可以直接得到生成的随机数，获取624个状态再预测就可以了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange  </span><br><span class="line">  </span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>, port)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_state</span>():  </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input the denominator: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;= &#x27;</span>)  </span><br><span class="line">    st = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(st)  </span><br><span class="line">  </span><br><span class="line">rc = RandCrack()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> trange(<span class="number">624</span>):  </span><br><span class="line">    state = get_state()  </span><br><span class="line">    rc.submit(state)  </span><br><span class="line">  </span><br><span class="line">rand1 = rc.predict_getrandbits(<span class="number">11000</span>)  </span><br><span class="line">rand2 = rc.predict_getrandbits(<span class="number">10000</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;input the answer: &gt;&gt;&gt; &#x27;</span>, <span class="built_in">str</span>(rand1 // rand2).encode())  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="Complex-signin"><a href="#Complex-signin" class="headerlink" title="Complex_signin"></a>Complex_signin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20  </span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, re, im</span>):  </span><br><span class="line">        self.re = re  </span><br><span class="line">        self.im = im  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, c</span>):  </span><br><span class="line">        re_ = self.re * c.re - self.im * c.im  </span><br><span class="line">        im_ = self.re * c.im + self.im * c.re  </span><br><span class="line">        <span class="keyword">return</span> Complex(re_, im_)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, c</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.re == c.re <span class="keyword">and</span> self.im == c.im  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rshift__</span>(<span class="params">self, m</span>):  </span><br><span class="line">        <span class="keyword">return</span> Complex(self.re &gt;&gt; m, self.im &gt;&gt; m)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lshift__</span>(<span class="params">self, m</span>):  </span><br><span class="line">        <span class="keyword">return</span> Complex(self.re &lt;&lt; m, self.im &lt;&lt; m)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">if</span> self.im == <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(self.re)  </span><br><span class="line">        <span class="keyword">elif</span> self.re == <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(self.im) == <span class="number">1</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> <span class="keyword">if</span> self.im &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>&#125;</span>i&quot;</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.im&#125;</span>i&quot;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.re&#125;</span> <span class="subst">&#123;<span class="string">&#x27;+&#x27;</span> <span class="keyword">if</span> self.im &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;-&#x27;</span>&#125;</span> <span class="subst">&#123;<span class="built_in">abs</span>(self.im)&#125;</span>i&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tolist</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> [self.re, self.im]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">complex_pow</span>(<span class="params">c, exp, n</span>):  </span><br><span class="line">    result = Complex(<span class="number">1</span>, <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> exp &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">if</span> exp &amp; <span class="number">1</span>:  </span><br><span class="line">            result = result * c  </span><br><span class="line">            result.re = result.re % n  </span><br><span class="line">            result.im = result.im % n  </span><br><span class="line">        c = c * c  </span><br><span class="line">        c.re = c.re % n  </span><br><span class="line">        c.im = c.im % n  </span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line">bits = <span class="number">128</span>  </span><br><span class="line">p = getPrime(<span class="number">1024</span>)  </span><br><span class="line">q = getPrime(<span class="number">1024</span>)  </span><br><span class="line">n = p * q  </span><br><span class="line">m = Complex(getRandomRange(<span class="number">1</span>, n), getRandomRange(<span class="number">1</span>, n))  </span><br><span class="line">e = <span class="number">3</span>  </span><br><span class="line">c = complex_pow(m, e, n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;mh = <span class="subst">&#123;(m &gt;&gt; bits &lt;&lt; bits).tolist()&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;C = <span class="subst">&#123;c.tolist()&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;enc = <span class="subst">&#123;ChaCha20.new(key=hashlib.sha256(<span class="built_in">str</span>(m.re + m.im).encode()).digest(), nonce=<span class="string">b&#x27;Pr3d1ctmyxjj&#x27;</span>).encrypt(flag)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">n = ...  </span></span><br><span class="line"><span class="string">mh = [..., ...]  </span></span><br><span class="line"><span class="string">C = [..., ...]  </span></span><br><span class="line"><span class="string">enc = ... </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>复数RSA，而且泄露了明文高位，对于明文$m$，可知：</p><script type="math/tex; mode=display">C=m^3=[Re(m)+i\cdot Im(m)]^3=[Re(m)^3 - 3Re(m)Im(m)^2] + i[3Re(m)^2Im(m) - Im(m)^3]</script><p>在这里已知$Re(m)$以及$Im(m)$的高1920位，所以我们可以通过二元coppersmith来还原低位，在这里仅使用密文的实部，可以构造得到多项式：</p><script type="math/tex; mode=display">f=(mh_0+x)^3-3(mh_0+x)(mh_1+y)^2-Re(C)</script><p>上式中$mh_0,mh_1$对应题目给出数据中的<code>mh[0],mh[1]</code>，通过下述代码就可以得到flag了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line">    B, monomials = G.coefficients_monomials()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">mh = [..., ...]</span><br><span class="line">C = [..., ...]</span><br><span class="line">enc = ...</span><br><span class="line">bits = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">R.&lt;x, y&gt; = Zmod(n)[]</span><br><span class="line"></span><br><span class="line">re_m = mh[<span class="number">0</span>] + x</span><br><span class="line">im_m = mh[<span class="number">1</span>] + y</span><br><span class="line"></span><br><span class="line">f = re_m^<span class="number">3</span> - <span class="number">3</span>*re_m*im_m^<span class="number">2</span> - C[<span class="number">0</span>]</span><br><span class="line">a, b = small_roots(f, bounds=(<span class="number">2</span>^bits, <span class="number">2</span>^bits), m=<span class="number">1</span>, d=<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">key = hashlib.sha256(<span class="built_in">str</span>(mh[<span class="number">0</span>] + mh[<span class="number">1</span>] + ZZ(a) + ZZ(b)).encode()).digest()</span><br><span class="line"></span><br><span class="line">cipher = ChaCha20.new(key=key, nonce=<span class="string">b&#x27;Pr3d1ctmyxjj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plaintext = cipher.decrypt(enc)</span><br><span class="line"><span class="built_in">print</span>(plaintext.decode())</span><br></pre></td></tr></table></figure></p><h3 id="复复复复数"><a href="#复复复复数" class="headerlink" title="复复复复数"></a>复复复复数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComComplex</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span>):  </span><br><span class="line">        self.value = value  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  </span><br><span class="line">        s = <span class="built_in">str</span>(self.value[<span class="number">0</span>])  </span><br><span class="line">        <span class="keyword">for</span> k,i <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.value[<span class="number">1</span>:]):  </span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span>:  </span><br><span class="line">                s += <span class="string">&#x27;+&#x27;</span>  </span><br><span class="line">            s += <span class="built_in">str</span>(i) +<span class="string">&#x27;ijk&#x27;</span>[k]  </span><br><span class="line">        <span class="keyword">return</span> s  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,x</span>):  </span><br><span class="line">        <span class="keyword">return</span> ComComplex([i+j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(self.value,x.value)])  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self,x</span>):  </span><br><span class="line">        a = self.value[<span class="number">0</span>]*x.value[<span class="number">0</span>]-self.value[<span class="number">1</span>]*x.value[<span class="number">1</span>]-self.value[<span class="number">2</span>]*x.value[<span class="number">2</span>]-self.value[<span class="number">3</span>]*x.value[<span class="number">3</span>]  </span><br><span class="line">        b = self.value[<span class="number">0</span>]*x.value[<span class="number">1</span>]+self.value[<span class="number">1</span>]*x.value[<span class="number">0</span>]+self.value[<span class="number">2</span>]*x.value[<span class="number">3</span>]-self.value[<span class="number">3</span>]*x.value[<span class="number">2</span>]  </span><br><span class="line">        c = self.value[<span class="number">0</span>]*x.value[<span class="number">2</span>]-self.value[<span class="number">1</span>]*x.value[<span class="number">3</span>]+self.value[<span class="number">2</span>]*x.value[<span class="number">0</span>]+self.value[<span class="number">3</span>]*x.value[<span class="number">1</span>]  </span><br><span class="line">        d = self.value[<span class="number">0</span>]*x.value[<span class="number">3</span>]+self.value[<span class="number">1</span>]*x.value[<span class="number">2</span>]-self.value[<span class="number">2</span>]*x.value[<span class="number">1</span>]+self.value[<span class="number">3</span>]*x.value[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">return</span> ComComplex([a,b,c,d])  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mod__</span>(<span class="params">self,x</span>):  </span><br><span class="line">        <span class="keyword">return</span> ComComplex([i % x <span class="keyword">for</span> i <span class="keyword">in</span> self.value])  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pow__</span>(<span class="params">self, x, n=<span class="literal">None</span></span>):  </span><br><span class="line">        tmp = ComComplex(self.value)  </span><br><span class="line">        a = ComComplex([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])  </span><br><span class="line">        <span class="keyword">while</span> x:  </span><br><span class="line">            <span class="keyword">if</span> x &amp; <span class="number">1</span>:  </span><br><span class="line">                a *= tmp  </span><br><span class="line">            tmp *= tmp  </span><br><span class="line">            <span class="keyword">if</span> n:  </span><br><span class="line">                a %= n  </span><br><span class="line">                tmp %= n  </span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> a  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, hint  </span><br><span class="line">  </span><br><span class="line">p = getPrime(<span class="number">256</span>)  </span><br><span class="line">q = getPrime(<span class="number">256</span>)  </span><br><span class="line">r = getPrime(<span class="number">256</span>)  </span><br><span class="line">n = p * q * r  </span><br><span class="line">  </span><br><span class="line">P = getPrime(<span class="number">512</span>)  </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(hint) == <span class="number">20</span>  </span><br><span class="line">hints = ComComplex([bytes_to_long(hint[i:i+<span class="number">5</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">20</span>,<span class="number">5</span>)])  </span><br><span class="line">keys = ComComplex([<span class="number">0</span>, p, q, r])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hint =&#x27;</span>,hints)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gift =&#x27;</span>,hints*keys%P)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;P =&#x27;</span>,P)  </span><br><span class="line">  </span><br><span class="line">e = <span class="number">65547</span>  </span><br><span class="line">m = ComComplex([bytes_to_long(flag[i:i+<span class="built_in">len</span>(flag)//<span class="number">4</span>+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(flag),<span class="built_in">len</span>(flag)//<span class="number">4</span>+<span class="number">1</span>)])  </span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>, n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)  </span><br></pre></td></tr></table></figure><p>这个显然是一个四元数的RSA问题，那么我们首先需要分解出$n$，设hint为$h$，keys为$k$，gifts为$g$，则在模$P$的四元数下有：</p><script type="math/tex; mode=display">g=hk</script><p>我们知道，四元数$a+bi+cj+dk$可以通过一个方阵等价表示：</p><script type="math/tex; mode=display">a+bi+cj+dk\rightarrow\left(\begin{matrix}a&b&c&d\\-b&a&-d&c\\-c&d&a&-b\\-d&-c&b&a\end{matrix}\right)</script><p>而四元数的乘法也可以等价地转换为矩阵的乘法，设$h$对应矩阵$H$，$k$对应矩阵$K$，$h$对应矩阵$G$，则上述计算可以等价于$G=HK$，这样的话我们就可以通过矩阵求逆得到$K$，从而得到$p,q,r$了（之后的操作都会将四元数处理为数组）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line">h = [<span class="number">375413371936</span>, <span class="number">452903063925</span>, <span class="number">418564633198</span>, <span class="number">452841062207</span>]</span><br><span class="line">g = [<span class="number">8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729</span>, <span class="number">20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171</span>, <span class="number">22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868</span>, <span class="number">40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863</span>]</span><br><span class="line">P = <span class="number">8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109</span></span><br><span class="line">n = <span class="number">408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367</span></span><br><span class="line"></span><br><span class="line">H = matrix(Zmod(P),</span><br><span class="line">[[h[<span class="number">0</span>], h[<span class="number">1</span>], h[<span class="number">2</span>], h[<span class="number">3</span>]],</span><br><span class="line">[-h[<span class="number">1</span>], h[<span class="number">0</span>], -h[<span class="number">3</span>], h[<span class="number">2</span>]],</span><br><span class="line">[-h[<span class="number">2</span>], h[<span class="number">3</span>], h[<span class="number">0</span>], -h[<span class="number">1</span>]],</span><br><span class="line">[-h[<span class="number">3</span>], -h[<span class="number">2</span>], h[<span class="number">1</span>], h[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">G = matrix(Zmod(P),</span><br><span class="line">[[g[<span class="number">0</span>], g[<span class="number">1</span>], g[<span class="number">2</span>], g[<span class="number">3</span>]],</span><br><span class="line">[-g[<span class="number">1</span>], g[<span class="number">0</span>], -g[<span class="number">3</span>], g[<span class="number">2</span>]],</span><br><span class="line">[-g[<span class="number">2</span>], g[<span class="number">3</span>], g[<span class="number">0</span>], -g[<span class="number">1</span>]],</span><br><span class="line">[-g[<span class="number">3</span>], -g[<span class="number">2</span>], g[<span class="number">1</span>], g[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">K = H^-<span class="number">1</span> * G</span><br><span class="line">_, p, q, r = K[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">assert</span> ZZ(p) * ZZ(q) * ZZ(r) == n</span><br><span class="line"></span><br><span class="line">p, q, r = ZZ(p), ZZ(q), ZZ(r)</span><br></pre></td></tr></table></figure><br>在此之后就要求解四元数RSA了，已知四元数可以用一个四阶方阵来表示，那么我们从<a href="https://mathoverflow.net/questions/109483/maximal-order-of-elements-in-gln-p">gr.group theory - maximal order of elements in GL(n,p) - MathOverflow</a>中很容易知道在模$n=pqr$下的最大阶应为$\varphi=(p^4-1)(q^4-1)(r^4-1)$，但是在这里$(65547, \varphi)=9$，而且通过测试可以知道：</p><script type="math/tex; mode=display">(65547, p^4-1)=(65547, q^4-1)=(65547, r^4-1)=3</script><p>我们猜测flag分块之后不可能大于$p,q,r$中任意一个，那么我们可以考虑尝试将该线性群的阶缩减为$\varphi/27$，此时通过普通的矩阵RSA就可以求得flag：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103</span>, <span class="number">24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825</span>, <span class="number">45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125</span>, <span class="number">96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385</span>]</span><br><span class="line"></span><br><span class="line">C = matrix(Zmod(n),</span><br><span class="line">[[c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>]],</span><br><span class="line">[-c[<span class="number">1</span>], c[<span class="number">0</span>], -c[<span class="number">3</span>], c[<span class="number">2</span>]],</span><br><span class="line">[-c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">0</span>], -c[<span class="number">1</span>]],</span><br><span class="line">[-c[<span class="number">3</span>], -c[<span class="number">2</span>], c[<span class="number">1</span>], c[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">e = <span class="number">65547</span></span><br><span class="line">phi = (p**<span class="number">4</span> - <span class="number">1</span>)*(q**<span class="number">4</span> - <span class="number">1</span>)*(r**<span class="number">4</span> - <span class="number">1</span>)//<span class="number">27</span></span><br><span class="line"></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">M = C^d</span><br><span class="line"></span><br><span class="line">res = M[<span class="number">0</span>]</span><br><span class="line">flag = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> res:</span><br><span class="line">    flag += long_to_bytes(ZZ(x))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></p><h3 id="reed"><a href="#reed" class="headerlink" title="reed"></a>reed</h3><blockquote><p>据说我的解法是非预期</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">&#x27;XYCTF&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">&#x27;&#125;&#x27;</span>)  </span><br><span class="line">flag = flag.rstrip(<span class="string">&#x27;&#125;&#x27;</span>).lstrip(<span class="string">&#x27;XYCTF&#123;&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">table = string.ascii_letters + string.digits  </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">all</span>(i <span class="keyword">in</span> table <span class="keyword">for</span> i <span class="keyword">in</span> flag)  </span><br><span class="line">r = random.Random()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PRNG</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed</span>):  </span><br><span class="line">        self.a = <span class="number">1145140</span>  </span><br><span class="line">        self.b = <span class="number">19198100</span>  </span><br><span class="line">        random.seed(seed)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):  </span><br><span class="line">        x = random.randint(self.a, self.b)  </span><br><span class="line">        random.seed(x ** <span class="number">2</span> + <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">round</span>(<span class="params">self, k</span>):  </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):  </span><br><span class="line">            x = self.<span class="built_in">next</span>()  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">msg, a, b</span>):  </span><br><span class="line">    c = [(a * table.index(m) + b) % <span class="number">19198111</span> <span class="keyword">for</span> m <span class="keyword">in</span> msg]  </span><br><span class="line">    <span class="keyword">return</span> c  </span><br><span class="line">  </span><br><span class="line">seed = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;give me seed: &#x27;</span>))  </span><br><span class="line">prng = PRNG(seed)  </span><br><span class="line">a = prng.<span class="built_in">round</span>(r.randrange(<span class="number">2</span>**<span class="number">16</span>))  </span><br><span class="line">b = prng.<span class="built_in">round</span>(r.randrange(<span class="number">2</span>**<span class="number">16</span>))  </span><br><span class="line">enc = encrypt(flag, a, b)  </span><br><span class="line"><span class="built_in">print</span>(enc)</span><br></pre></td></tr></table></figure><p>有个仿射，而且我们知道字母表下标的范围，直接爆破参数$a$以及第一个字母就可以了（下面是种子为1的数据）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">table = string.ascii_letters + string.digits  </span><br><span class="line">  </span><br><span class="line">enc = [<span class="number">10021509</span>, <span class="number">10021509</span>, <span class="number">13396490</span>, <span class="number">1722743</span>, <span class="number">10021509</span>, <span class="number">13396490</span>, <span class="number">13616146</span>, <span class="number">16991127</span>, <span class="number">14667921</span>, <span class="number">6091782</span>, <span class="number">17765529</span>, <span class="number">12067342</span>, <span class="number">4542978</span>, <span class="number">16991127</span>, <span class="number">16216725</span>, <span class="number">3768576</span>, <span class="number">16991127</span>, <span class="number">15442323</span>, <span class="number">15442323</span>, <span class="number">4542978</span>, <span class="number">17765529</span>, <span class="number">14390548</span>, <span class="number">16216725</span>, <span class="number">1942399</span>, <span class="number">6091782</span>, <span class="number">7917959</span>, <span class="number">4542978</span>, <span class="number">11292940</span>, <span class="number">15442323</span>, <span class="number">10021509</span>, <span class="number">12622088</span>, <span class="number">10021509</span>, <span class="number">12622088</span>, <span class="number">5097724</span>, <span class="number">10021509</span>, <span class="number">2497145</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> trange(<span class="number">114514</span>, <span class="number">19198100</span>):  </span><br><span class="line">    inva = inverse(a, <span class="number">19198111</span>)  </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):  </span><br><span class="line">        b = (enc[<span class="number">0</span>] - a * x) % <span class="number">19198111</span>  </span><br><span class="line">        <span class="keyword">if</span> b &gt; <span class="number">1145140</span> <span class="keyword">and</span> b &lt; <span class="number">19198100</span>:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                flag = <span class="string">&#x27;&#x27;</span>.join([table[(inva * (x - b)) % <span class="number">19198111</span>] <span class="keyword">for</span> x <span class="keyword">in</span> enc])  </span><br><span class="line">                <span class="built_in">print</span>(flag)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">except</span>:  </span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="勒索病毒（复现）"><a href="#勒索病毒（复现）" class="headerlink" title="勒索病毒（复现）"></a>勒索病毒（复现）</h3><p>给出一个exe，但是它的图标是：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102115091.png" alt="Pasted image 20250410113323"><br>看不出来是什么语言编译的，用DIE扫出来是C/C++：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102115066.png" alt="Pasted image 20250410113519"><br>拖进IDA里面看看，随便翻翻翻到：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102115104.png" alt="Pasted image 20250410113656"><br>有段代码提到了PyInstaller，初步判断是Python编译的，用pyinstxtractor解包可以得到task.pyc和res文件夹里的enc.txt和pub_key.txt，通过pycdc反编译得到如下代码（以下代码为反编译结果经过处理得到的)：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">import</span> binascii  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle, randrange  </span><br><span class="line">  </span><br><span class="line">N = <span class="number">49</span> </span><br><span class="line">p = <span class="number">3</span>  </span><br><span class="line">q = <span class="number">128</span>  </span><br><span class="line">d = <span class="number">3</span>  </span><br><span class="line"><span class="keyword">assert</span> q &gt; (<span class="number">6</span> * d + <span class="number">1</span>) * p  </span><br><span class="line">R.&lt;x&gt; = ZZ[]  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_T</span>(<span class="params">d1, d2</span>):  </span><br><span class="line">    <span class="keyword">assert</span> N &gt;= d1 + d2  </span><br><span class="line">    s = [<span class="number">1</span>] * d1 + [-<span class="number">1</span>] * d2 + [<span class="number">0</span>] * (N - d1 - d2)  </span><br><span class="line">    shuffle(s)  </span><br><span class="line">    <span class="keyword">return</span> R(s)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_mod_prime</span>(<span class="params">f, p</span>):  </span><br><span class="line">    Rp = R.change_ring(Integers(p)).quotient(x^N - <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> R(lift(<span class="number">1</span> / Rp(f)))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convolution</span>(<span class="params">f, g</span>):  </span><br><span class="line">    <span class="keyword">return</span> (f * g) % (x^N - <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lift_mod</span>(<span class="params">f, q</span>):  </span><br><span class="line">    <span class="keyword">return</span> R([((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poly_mod</span>(<span class="params">f, q</span>):  </span><br><span class="line">    <span class="keyword">return</span> R([f[i] % q <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_mod_pow2</span>(<span class="params">f, q</span>):  </span><br><span class="line">    <span class="keyword">assert</span> q.is_power_of(<span class="number">2</span>)  </span><br><span class="line">    g = invert_mod_prime(f, <span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        r = lift_mod(convolution(g, f), q)  </span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">return</span> g  </span><br><span class="line">        g = lift_mod(convolution(g, <span class="number">2</span> - r), q)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_message</span>():  </span><br><span class="line">    <span class="keyword">return</span> R([randrange(p) - <span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key</span>():  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            f = generate_T(d + <span class="number">1</span>, d)  </span><br><span class="line">            g = generate_T(d, d)  </span><br><span class="line">            Fp = poly_mod(invert_mod_prime(f, p), p)  </span><br><span class="line">            Fq = poly_mod(invert_mod_pow2(f, q), q)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">    h = poly_mod(convolution(Fq, g), q)  </span><br><span class="line">    <span class="keyword">return</span> h, (f, g)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_message</span>(<span class="params">m, h</span>):  </span><br><span class="line">    e = lift_mod(p * convolution(h, generate_T(d, d)) + m, q)  </span><br><span class="line">    <span class="keyword">return</span> e  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_ntru_keys</span>():  </span><br><span class="line">    h, secret = generate_key()  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pub_key.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(<span class="built_in">str</span>(h))  </span><br><span class="line">    m = generate_message()  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;priv_key.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(<span class="built_in">str</span>(m))  </span><br><span class="line">    e = encrypt_message(m, h)  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;enc.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(<span class="built_in">str</span>(e))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">terms</span>(<span class="params">poly_str</span>):  </span><br><span class="line">    terms = []  </span><br><span class="line">    pattern = <span class="string">r&#x27;([+-]?\s*x\^?\d*|[-+]?\s*\d+)&#x27;</span>  </span><br><span class="line">    matches = re.finditer(pattern, poly_str.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>))  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:  </span><br><span class="line">        term = <span class="keyword">match</span>.group()  </span><br><span class="line">        <span class="keyword">if</span> term == <span class="string">&#x27;+x&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;x&#x27;</span>:  </span><br><span class="line">            terms.append(<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">elif</span> term == <span class="string">&#x27;-x&#x27;</span>:  </span><br><span class="line">            terms.append(-<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x^&#x27;</span> <span class="keyword">in</span> term:  </span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">0</span>]  </span><br><span class="line">            exponent = <span class="built_in">int</span>(term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">1</span>])  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:  </span><br><span class="line">                coeff = <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:  </span><br><span class="line">                coeff = -<span class="number">1</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                coeff = <span class="built_in">int</span>(coeff_part)  </span><br><span class="line">            terms.append(coeff * exponent)  </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> term:  </span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x&#x27;</span>)[<span class="number">0</span>]  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:  </span><br><span class="line">                terms.append(<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:  </span><br><span class="line">                terms.append(-<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                terms.append(<span class="built_in">int</span>(coeff_part))  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">if</span> term == <span class="string">&#x27;+1&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;1&#x27;</span>:  </span><br><span class="line">                terms.append(<span class="number">0</span>)  </span><br><span class="line">                terms.append(-<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> terms  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">poly_terms</span>):  </span><br><span class="line">    binary = [<span class="number">0</span>] * <span class="number">128</span>  </span><br><span class="line">    <span class="keyword">for</span> term <span class="keyword">in</span> poly_terms:  </span><br><span class="line">        exponent = <span class="built_in">abs</span>(term)  </span><br><span class="line">        <span class="keyword">if</span> term &gt; <span class="number">0</span> <span class="keyword">and</span> exponent &lt;= <span class="number">127</span>:    </span><br><span class="line">            binary[<span class="number">127</span> - exponent] = <span class="number">1</span>  </span><br><span class="line">    binary_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, binary))  </span><br><span class="line">    hex_key = <span class="built_in">hex</span>(<span class="built_in">int</span>(binary_str, <span class="number">2</span>))[<span class="number">2</span>:].upper().zfill(<span class="number">32</span>)  </span><br><span class="line">    <span class="keyword">return</span> hex_key  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_polynomial_from_file</span>(<span class="params">filename</span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">        <span class="keyword">return</span> file.read().strip()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sm4_encrypt</span>(<span class="params">key, plaintext</span>):  </span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(key) == <span class="number">16</span>, <span class="string">&quot;SM4 key must be 16 bytes&quot;</span>  </span><br><span class="line">    cipher = sm4.CryptSM4()  </span><br><span class="line">    cipher.set_key(key, sm4.SM4_ENCRYPT)  </span><br><span class="line">    padded_plaintext = pad(plaintext, <span class="number">16</span>)  </span><br><span class="line">    <span class="keyword">return</span> cipher.crypt_ecb(padded_plaintext)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sm4_encrypt_file</span>(<span class="params">input_path, output_path, key</span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        plaintext = f.read()  </span><br><span class="line">      </span><br><span class="line">    ciphertext = sm4_encrypt(key, plaintext)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        f.write(ciphertext)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resource_path</span>(<span class="params">relative_path</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(sys, <span class="string">&#x27;frozen&#x27;</span>, <span class="literal">False</span>):  </span><br><span class="line">        base_path = sys._MEIPASS  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        base_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_path, relative_path)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_directory</span>(<span class="params">directory, sm4_key, extensions=[<span class="string">&quot;.txt&quot;</span>]</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Directory does not exist: <span class="subst">&#123;directory&#125;</span>&quot;</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(directory):  </span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(file.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> extensions):  </span><br><span class="line">                input_path = os.path.join(root, file)  </span><br><span class="line">                output_path = input_path + <span class="string">&quot;.enc&quot;</span>  </span><br><span class="line">                <span class="keyword">try</span>:  </span><br><span class="line">                    sm4_encrypt_file(input_path, output_path, sm4_key)  </span><br><span class="line">                    os.remove(input_path)  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Encrypted: <span class="subst">&#123;input_path&#125;</span> -&gt; <span class="subst">&#123;output_path&#125;</span>&quot;</span>)  </span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error encrypting <span class="subst">&#123;input_path&#125;</span>: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        save_ntru_keys()  </span><br><span class="line">        poly_str = read_polynomial_from_file(<span class="string">&quot;priv_key.txt&quot;</span>)  </span><br><span class="line">        poly_terms = terms(poly_str)  </span><br><span class="line">        sm4_key = binascii.unhexlify(poly_terms)  </span><br><span class="line">        user_name = os.getlogin()  </span><br><span class="line">        target_dir = os.path.join(<span class="string">&quot;C:\\Users&quot;</span>, user_name, <span class="string">&quot;Desktop&quot;</span>, <span class="string">&quot;test_files&quot;</span>)  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(target_dir):  </span><br><span class="line">            os.makedirs(target_dir, exist_ok=<span class="literal">True</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Created directory: <span class="subst">&#123;target_dir&#125;</span>&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">            txt_files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(target_dir)   </span><br><span class="line">                    <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">and</span> os.path.isfile(os.path.join(target_dir, f))]  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> txt_files:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No .txt files found in directory&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">            <span class="keyword">for</span> txt_file <span class="keyword">in</span> txt_files:  </span><br><span class="line">            file_path = os.path.join(target_dir, txt_file)  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                    test_data = f.read()  </span><br><span class="line">                  </span><br><span class="line">                ciphertext = sm4_encrypt(sm4_key, test_data)  </span><br><span class="line">                encrypted_path = file_path + <span class="string">&#x27;.enc&#x27;</span>  </span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(encrypted_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                f.write(ciphertext)  </span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error processing <span class="subst">&#123;txt_file&#125;</span>: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)  </span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Fatal error: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>可以看到上述代码生成一个随机多项式$m(x)$，并通过<code>terms</code>（以及反编译出来的代码中没有使用到的<code>gen_key</code>）来讲多项式转换为SM4的密钥对flag进行加密，之后使用NTRU加密多项式$m(x)$，最后将NTRU的公钥写入pub_key.txt，将NTRU的密文写入enc.txt，NTRU相关可以参考这篇博客：<a href="https://triodelzx.github.io/2025/04/09/NTRU/">NTRU | Triode Field</a>，通过如下代码就可以求解出flag：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">terms</span>(<span class="params">poly_str</span>):</span><br><span class="line">    terms = []</span><br><span class="line">    pattern = <span class="string">r&#x27;([+-]?\s*x\^?\d*|[-+]?\s*\d+)&#x27;</span></span><br><span class="line">    matches = re.finditer(pattern, poly_str.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:</span><br><span class="line">        term = <span class="keyword">match</span>.group()</span><br><span class="line">        <span class="keyword">if</span> term == <span class="string">&#x27;+x&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            terms.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> term == <span class="string">&#x27;-x&#x27;</span>:</span><br><span class="line">            terms.append(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x^&#x27;</span> <span class="keyword">in</span> term:</span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            exponent = <span class="built_in">int</span>(term.split(<span class="string">&#x27;x^&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                coeff = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                coeff = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coeff = <span class="built_in">int</span>(coeff_part)</span><br><span class="line">            terms.append(coeff * exponent)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> term:</span><br><span class="line">            coeff_part = term.split(<span class="string">&#x27;x&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> coeff_part <span class="keyword">or</span> coeff_part == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                terms.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> coeff_part == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                terms.append(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                terms.append(<span class="built_in">int</span>(coeff_part))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> term == <span class="string">&#x27;+1&#x27;</span> <span class="keyword">or</span> term == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                terms.append(<span class="number">0</span>)</span><br><span class="line">                terms.append(-<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> terms</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">poly_terms</span>):</span><br><span class="line">    binary = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line">    <span class="keyword">for</span> term <span class="keyword">in</span> poly_terms:</span><br><span class="line">        exponent = <span class="built_in">abs</span>(term)</span><br><span class="line">        <span class="keyword">if</span> term &gt; <span class="number">0</span> <span class="keyword">and</span> exponent &lt;= <span class="number">127</span>:</span><br><span class="line">            binary[<span class="number">127</span> - exponent] = <span class="number">1</span></span><br><span class="line">    binary_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, binary))</span><br><span class="line">    hex_key = <span class="built_in">hex</span>(<span class="built_in">int</span>(binary_str, <span class="number">2</span>))[<span class="number">2</span>:].upper().zfill(<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">return</span> hex_key</span><br><span class="line"></span><br><span class="line">N = <span class="number">49</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">q = <span class="number">128</span>  </span><br><span class="line">d = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(f).inverse()</span><br><span class="line"></span><br><span class="line">h = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">e = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]\</span><br><span class="line"></span><br><span class="line">res = L.BKZ()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">v = <span class="built_in">list</span>(res[:N])</span><br><span class="line">f = R([ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> v])</span><br><span class="line">Fp = Rp(<span class="built_in">list</span>(f)).inverse()</span><br><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br><span class="line">m = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line">poly_terms = terms(<span class="built_in">str</span>(m))</span><br><span class="line">key = gen_key(poly_terms)</span><br><span class="line">sm4_key = binascii.unhexlify(key)</span><br><span class="line"><span class="built_in">print</span>(sm4_key.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">sm4 = sm4.CryptSM4(sm4_key)</span><br><span class="line">sm4.set_key(sm4_key, gmssl.sm4.SM4_DECRYPT)</span><br><span class="line"></span><br><span class="line">ct = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;bf0cb5cc6bea6146e9c1f109df953a57daa416d38a8ffba6438e7e599613e01f3b9a53dace4ccd55cd3e55ef88e0b835&quot;</span>)</span><br><span class="line">pt = sm4.crypt_ecb(ct)</span><br><span class="line"><span class="built_in">print</span>(unpad(pt, <span class="number">16</span>))</span><br></pre></td></tr></table></figure><br>事实上，我们可以发现，在<code>enc.txt</code>中除了$e$之外还有一个多出来的多项式：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-x^<span class="number">48</span> - x^<span class="number">46</span> + x^<span class="number">45</span> + x^<span class="number">43</span> - x^<span class="number">42</span> + x^<span class="number">41</span> + x^<span class="number">40</span> + x^<span class="number">36</span> - x^<span class="number">35</span> + x^<span class="number">34</span> - x^<span class="number">33</span> + x^<span class="number">32</span> - x^<span class="number">30</span> + x^<span class="number">29</span> - x^<span class="number">28</span> - x^<span class="number">27</span> - x^<span class="number">26</span> - x^<span class="number">25</span> - x^<span class="number">23</span> - x^<span class="number">22</span> + x^<span class="number">21</span> + x^<span class="number">20</span> + x^<span class="number">19</span> + x^<span class="number">18</span> - x^<span class="number">17</span> - x^<span class="number">16</span> - x^<span class="number">15</span> - x^<span class="number">14</span> - x^<span class="number">12</span> + x^<span class="number">9</span> - x^<span class="number">7</span> - x^<span class="number">6</span> - x^<span class="number">5</span> - x^<span class="number">4</span> + x^<span class="number">3</span> - x + <span class="number">1</span></span><br></pre></td></tr></table></figure><br>这个多项式实际上就是NTRU加密一步使用的明文，也就是最后被用于转换为SM4的密钥的多项式.</p><h3 id="choice（复现）"><a href="#choice（复现）" class="headerlink" title="choice（复现）"></a>choice（复现）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">b&#x27;XYCTF&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)  </span><br><span class="line">flag = flag[<span class="number">6</span>:-<span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line">msg = bytes_to_long(flag)  </span><br><span class="line">rand = Random()  </span><br><span class="line">test = <span class="built_in">bytes</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>, -<span class="number">1</span>, -<span class="number">1</span>)])  </span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>).write(<span class="string">f&#x27;enc = <span class="subst">&#123;msg ^ rand.getrandbits(msg.bit_length())&#125;</span>\nr = <span class="subst">&#123;[rand.choice(test) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2496</span>)]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>给了上面的代码还有random.py，跟Python库里面的random.py差距挺大的，但是据出题人的说法修改的是第246行，对应的是<code>_randbelow_with_getrandbits</code>函数，原本的这个函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_randbelow_with_getrandbits</span>(<span class="params">self, n</span>):  </span><br><span class="line">    <span class="string">&quot;Return a random int in the range [0,n).  Defined for n &gt; 0.&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    getrandbits = self.getrandbits  </span><br><span class="line">    k = n.bit_length()  <span class="comment"># don&#x27;t use (n-1) here because n can be 1  </span></span><br><span class="line">    r = getrandbits(k)  <span class="comment"># 0 &lt;= r &lt; 2**k  </span></span><br><span class="line">    <span class="keyword">while</span> r &gt;= n:  </span><br><span class="line">        r = getrandbits(k)  </span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><br>修改后是这样的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_randbelow_with_getrandbits</span>(<span class="params">self, n</span>):  </span><br><span class="line">    <span class="string">&quot;Return a random int in the range [0,n).  Defined for n &gt; 0.&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    getrandbits = self.getrandbits  </span><br><span class="line">    k = n.bit_length() - <span class="number">1</span>  </span><br><span class="line">    r = getrandbits(k)  <span class="comment"># 0 &lt;= r &lt; 2**k  </span></span><br><span class="line">    <span class="keyword">while</span> r &gt;= n:  </span><br><span class="line">        r = getrandbits(k)  </span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><br>其实就是将<code>k = n.bit_length()</code>修改成了<code>k = n.bit_length() - 1</code>，再看到题目主要使用的<code>choice</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">self, seq</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;Choose a random element from a non-empty sequence.&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># As an accommodation for NumPy, we don&#x27;t use &quot;if not seq&quot;  </span></span><br><span class="line">    <span class="comment"># because bool(numpy.array()) raises a ValueError.    if not len(seq):  </span></span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Cannot choose from an empty sequence&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> seq[self._randbelow(<span class="built_in">len</span>(seq))]</span><br></pre></td></tr></table></figure><br>如果用原来的代码的话在进行<code>rand.choice(test)</code>的时候<code>_randbelow_with_getrandbits</code>就会生成9-bits的随机数，若大于等于256就会重新选取，这样的话得到的状态是不连续的，就没有办法恢复状态并倒推了，所以将<code>k = n.bit_length()</code>修改成了<code>k = n.bit_length() - 1</code>就可以避免这种情况，恢复状态的话GitHub上<a href="https://github.com/JuliaPoo/MT19937-Symbolic-Execution-and-Solver">这个项目</a>就可以做到，通过下述代码就可以恢复状态并实现倒推：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;MT19937-Symbolic-Execution-and-Solver/source&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> MT19937 <span class="keyword">import</span> MT19937</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">enc = <span class="number">5042764371819053176884777909105310461303359296255297</span></span><br><span class="line"></span><br><span class="line">r = [...]</span><br><span class="line">r = [<span class="number">255</span> - x <span class="keyword">for</span> x <span class="keyword">in</span> r]</span><br><span class="line"></span><br><span class="line">rng_clone = MT19937(state_from_data = (r, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">length = enc.bit_length()</span><br><span class="line"></span><br><span class="line">rng_clone.reverse_states(length//<span class="number">32</span>+<span class="number">1</span>) <span class="comment"># 括号内参数是要倒推的状态数</span></span><br></pre></td></tr></table></figure><br>恢复状态之后则需要通过手写<code>getrandbits</code>函数来得到（那个项目并没有实现这个功能），根据random库中<code>getrandbits</code>的规则实现<code>getrandbits</code>如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getrandbits</span>(<span class="params">n</span>):</span><br><span class="line">    out = <span class="number">0</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">32</span>:</span><br><span class="line">        out = rng_clone() &lt;&lt; offset | out</span><br><span class="line">        n -= <span class="number">32</span></span><br><span class="line">        offset += <span class="number">32</span></span><br><span class="line">    out = rng_clone() &gt;&gt; (<span class="number">32</span> - n) &lt;&lt; offset | out</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><br>最终可以直接恢复出flag：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = getrandbits(length + <span class="number">3</span>) <span class="comment"># 需要测试，因为不知道原来的位数是多少，只知道密文的位数</span></span><br><span class="line">pt = enc ^^ mask </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(pt))</span><br></pre></td></tr></table></figure></p><h3 id="prng-xxxx（待复现）"><a href="#prng-xxxx（待复现）" class="headerlink" title="prng_xxxx（待复现）"></a>prng_xxxx（待复现）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, b, seed  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, a, b</span>):  </span><br><span class="line">        self.seed = seed  </span><br><span class="line">        self.a = a  </span><br><span class="line">        self.b = b  </span><br><span class="line">        self.m = <span class="number">2</span>**<span class="number">128</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):  </span><br><span class="line">        self.seed = (self.seed * self.a + self.b) % self.m  </span><br><span class="line">        <span class="keyword">return</span> (self.seed &gt;&gt; <span class="number">64</span>) ^ (self.seed % <span class="number">2</span>**<span class="number">64</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lfsr</span>:  </span><br><span class="line">    <span class="comment"># 我被裁了/(ㄒoㄒ)/~~  </span></span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">a = <span class="number">47026247687942121848144207491837523525</span>  </span><br><span class="line"><span class="keyword">assert</span> b &lt; <span class="number">2</span>**<span class="number">128</span> <span class="keyword">and</span> seed &lt; <span class="number">2</span>**<span class="number">128</span>  </span><br><span class="line">lcg = LCG(seed, a, b)  </span><br><span class="line"><span class="built_in">print</span>([lcg.<span class="built_in">next</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> [<span class="number">0</span>] * <span class="number">64</span>])  </span><br><span class="line"><span class="built_in">print</span>(AES.new(key=md5(<span class="built_in">str</span>(seed).encode()).digest(), mode=AES.MODE_ECB).encrypt(pad(flag, <span class="number">16</span>)))  </span><br></pre></td></tr></table></figure><p>参考论文：<a href="https://tosc.iacr.org/index.php/ToSC/article/view/8700/8292">View of Practical seed-recovery for the PCG Pseudo-Random Number Generator</a></p><p><del>听说预期解的exp也要跑一个小时，有闲情雅致再复现</del></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签个到吧"><a href="#签个到吧" class="headerlink" title="签个到吧"></a>签个到吧</h3><p>经典Brainfuck，美化代码如下：<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure><br>可以知道这里在地址为0处写入数据之后会将它擦除，所以可以在擦除之前将地址为0的数据打印出来，修改代码如下：<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+++++++++++++++++++++++++</span></span><br><span class="line"><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-+-+-+-</span><span class="title">]</span></span><br><span class="line">&lt;<span class="string">.</span></span><br><span class="line"><span class="title">[</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure></p><h3 id="XGCTF"><a href="#XGCTF" class="headerlink" title="XGCTF"></a>XGCTF</h3><blockquote><p>题目描述：<br>2024年CTFshow举办了一场名为“西瓜杯”的比赛（XGCTF）。其中LamentXU在出题的时候，从某场比赛拉了道原题下来改了改，结果传文件的时候传错了传成原题了。因为这件事LamentXU的损友dragonkeep在他之前的博客上的原题wp上加了一段flag来嘲笑LamentXU。请你找到XGCTF中唯一由LamentXU出的题，并找出这题对应的原题，接着找到dragonkeep师傅的博客，并从博客上讲解该题的博文中找到flag。（hint：dragonkeep师傅因为比较穷买不起域名，因此他博客的域名在dragonkeep的基础上多了个字母）</p></blockquote><p>从题目描述中可以整理出三条线索：</p><ol><li>flag在dragonkeep的博客里</li><li>这道题的flag所在的位置与XGCTF的一道原题有关</li><li>相关题目在XGCTF中标注的出题人为LamentXU</li></ol><p>首先可以找到dragonkeep的博客为：<a href="https://dragonkeeep.top，可以看到这个师傅主攻的方向应该是web，所以可以大致将范围缩小到XGCTF的web题，直接到[XGCTF的复现平台](https://ctf.show/challenges)中可以找到唯一一道由LamentXU提供的题目：">https://dragonkeeep.top，可以看到这个师傅主攻的方向应该是web，所以可以大致将范围缩小到XGCTF的web题，直接到[XGCTF的复现平台](https://ctf.show/challenges)中可以找到唯一一道由LamentXU提供的题目：</a><br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102114116.png" alt="Pasted image 20250404173308"><br>关键词应该是polluted，回到dragonkeep的博客中可以发现一篇文章跟polluted有关：<a href="https://dragonkeeep.top/category/CISCN%E5%8D%8E%E4%B8%9C%E5%8D%97WEB-Polluted/">CISCN华东南WEB-Polluted | Dragonkeep</a>，在里面找一圈没找到flag，看看是不是在网页HTML源代码的注释里面，查看网页源代码可以找到：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Congratulations! You&#x27;ve got the flag:ZmxhZ3sxdF9JM190M0Vfc0BNZV9DaEFsMWVOZ2VfYVRfYTFMX1AxZUBzZV9mT3JnMXZlX01lfQ== --&gt;</span></span><br></pre></td></tr></table></figure><p>base64解码就是flag了.</p><h3 id="会飞的雷克萨斯"><a href="#会飞的雷克萨斯" class="headerlink" title="会飞的雷克萨斯"></a>会飞的雷克萨斯</h3><blockquote><p>在比赛群里给出flag的格式为flag{xx省xx市xx县xxx路xxxxxx内}，一个x对应一个字</p></blockquote><p>OSINT，给出一张图片：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102112308.jpeg" alt="ab3f53c6b3d2cfd23674a0c6e277d895"></p><p>直接搜索题目名字可以发现这是今年新年小孩玩炮仗炸化粪池把车炸飞的其中一个当事人在事发后改的网名，大多数新闻都显示发生的位置是四川省内江市资中县春岚北路，但是没有给出具体小区名，这个时候需要结合图片，注意到有一间叫唯曼医疗美容的店，百度地图搜索可以看到唯一结果：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102113751.png" alt="Pasted image 20250406232555"><br>可以知道事发地是在中铁城市中心内，所以flag就是flag{四川省内江市资中县春岚北路中铁城市中心内}</p><h3 id="曼波曼波曼波"><a href="#曼波曼波曼波" class="headerlink" title="曼波曼波曼波"></a>曼波曼波曼波</h3><p>给了个smn.txt，打开发现是倒过来的Base64，解码之后是张图片：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102113269.jpg" alt="smn"><br>附件里面还有个二维码，但是是假的flag，不用管，010可以看到上面图片的末尾有段zip，拉出来之后解压发现有一张图片，一个压缩包还有一个txt，txt里面是对压缩包密码的提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码是什么来着，有点记不清了，呜呜呜呜</span><br><span class="line">好像是什么比赛名字加年份</span><br></pre></td></tr></table></figure><p>不用想都知道是XYCTF2025，解压发现一张跟外面的图片看上去一模一样的图片，且尺寸也是一致的，考虑盲水印，解盲水印可以看到：<br><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504102113280.png" alt="out"><br>肉眼识别可以得到flag为XYCTF{easy_yin_xie_dfbfuj877}</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="WARMUP"><a href="#WARMUP" class="headerlink" title="WARMUP"></a>WARMUP</h3><p>vbs逆向，用记事本打开并将开头的<code>Execute</code>改成<code>wscript.echo</code>，然后在命令行用<code>cscript</code>运行可以得到源码：<br><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">MsgBox <span class="string">&quot;Dear CTFER. Have fun in XYCTF 2025!&quot;</span></span><br><span class="line">flag = InputBox(<span class="string">&quot;Enter the FLAG:&quot;</span>, <span class="string">&quot;XYCTF&quot;</span>)</span><br><span class="line">wefbuwiue = <span class="string">&quot;90df4407ee093d309098d85a42be57a2979f1e51463a31e8d15e2fac4e84ea0df622a55c4ddfb535ef3e51e8b2528b826d5347e165912e99118333151273cc3fa8b2b3b413cf2bdb1e8c9c52865efc095a8dd89b3b3cfbb200bbadbf4a6cd4&quot;</span></span><br><span class="line">qwfe = <span class="string">&quot;rc4key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> RunRC(sMessage, strKey)</span><br><span class="line">    <span class="keyword">Dim</span> kLen, i, j, temp, pos, outHex</span><br><span class="line">    <span class="keyword">Dim</span> s(<span class="number">255</span>), k(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    kLen = Len(strKey)</span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">0</span> <span class="keyword">To</span> <span class="number">255</span></span><br><span class="line">        s(i) = i</span><br><span class="line">        k(i) = Asc(<span class="keyword">Mid</span>(strKey, (i <span class="built_in">Mod</span> kLen) + <span class="number">1</span>, <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">0</span> <span class="keyword">To</span> <span class="number">255</span></span><br><span class="line">        j = (j + s(i) + k(i)) <span class="built_in">Mod</span> <span class="number">256</span></span><br><span class="line">        temp = s(i)</span><br><span class="line">        s(i) = s(j)</span><br><span class="line">        s(j) = temp</span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span> : j = <span class="number">0</span> : outHex = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">For</span> pos = <span class="number">1</span> <span class="keyword">To</span> Len(sMessage)</span><br><span class="line">        i = (i + <span class="number">1</span>) <span class="built_in">Mod</span> <span class="number">256</span></span><br><span class="line">        j = (j + s(i)) <span class="built_in">Mod</span> <span class="number">256</span></span><br><span class="line">        temp = s(i)</span><br><span class="line">        s(i) = s(j)</span><br><span class="line">        s(j) = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Dim</span> plainChar, cipherByte</span><br><span class="line">        plainChar = Asc(<span class="keyword">Mid</span>(sMessage, pos, <span class="number">1</span>)) </span><br><span class="line">        cipherByte = s((s(i) + s(j)) <span class="built_in">Mod</span> <span class="number">256</span>) <span class="built_in">Xor</span> plainChar</span><br><span class="line">        outHex = outHex &amp; Right(<span class="string">&quot;0&quot;</span> &amp; Hex(cipherByte), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    RunRC = outHex</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> LCase(RunRC(flag, qwfe)) = LCase(wefbuwiue) <span class="keyword">Then</span></span><br><span class="line">    MsgBox <span class="string">&quot;Congratulations! Correct FLAG!&quot;</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    MsgBox <span class="string">&quot;Wrong flag.&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure><br>就是RC4加密，密钥为<code>rc4key</code>，用CyberChef解密就可以得到flag了.</p>]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Misc </tag>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTRU</title>
      <link href="/2025/04/09/NTRU/"/>
      <url>/2025/04/09/NTRU/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://link.springer.com/book/10.1007/978-1-4939-1711-2">An Introduction to Mathematical Cryptography | SpringerLink</a></p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="格">格</h3><p>与格相关的前置知识在<a href="https://triodelzx.github.io/2025/03/31/%E6%A0%BC%E5%AF%86%E7%A0%81/">这篇博客</a>里面都有提及</p><h3 id="卷积多项式环">卷积多项式环</h3><p>对于一个整数<span class="math inline">\(N\)</span>，秩为<span class="math inline">\(N\)</span>的卷积多项式环即为如下商环： <span class="math display">\[R=\frac{\mathbb{Z}[x]}{(x^{N}-1)}\]</span> 类似的我们也可以定义出模<span class="math inline">\(q\)</span>的卷积多项式环为如下商环： <span class="math display">\[R_q=\frac{(\mathbb{Z}/q\mathbb{Z})[x]}{(x^{N}-1)}\]</span> 可以知道卷积多项式环中每一个多项式<span class="math inline">\(a(x)\)</span>都有唯一的表示（在这之后，我们默认卷积多项式环内的多项式都是如下表示）： <span class="math display">\[a(x)=a_0+a_1x+a_2x^2+\cdots+a_{N-1}x^{N-1}\]</span> 其中<span class="math inline">\(a_0,a_1,\cdots,a_{N-1}\in \mathbb{Z}\)</span>（或者<span class="math inline">\(\mathbb{Z}/q\mathbb{Z}\)</span>，这取决于这个卷积多项式环是一般的卷积多项式环还是模<span class="math inline">\(q\)</span>的卷积多项式环） 卷积多项式环是NTRU密码体系的基础。</p><h3 id="center-lift">center-lift</h3><p>对于<span class="math inline">\(R_q\)</span>上一个多项式<span class="math inline">\(a(x)\)</span>，<span class="math inline">\(a(x)\)</span>到<span class="math inline">\(R\)</span>上的center-lift即为一个多项式<span class="math inline">\(a&#39;(x)\)</span>满足： <span class="math display">\[a&#39;(x)\equiv a(x)\pmod{q}\]</span> 其中<span class="math inline">\(a&#39;(x)\)</span>的系数<span class="math inline">\(a_i&#39;\in(-\frac{q}{2},-\frac{q}{2}]\)</span>. 对于一个多项式，要获得其center-lift有如下算法： <span class="math display">\[a_i&#39;=\begin{cases}a_i&amp;,0\le a_i\le\frac{q}{2}\\a_i-q&amp;,\frac{q}{2}&lt; a_i&lt; q\end{cases}\]</span> center-lift可以通过如下代码实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br></pre></td></tr></table></figure></p><h3 id="三元多项式ternary-polynomial">三元多项式（ternary polynomial）</h3><p>对于卷积多项式环<span class="math inline">\(R=\frac{\mathbb{Z}[x]}{(x^{N}-1)}\)</span>，对于任意正数<span class="math inline">\(d_1,d_2\)</span>，若多项式<span class="math inline">\(a(x)\in R\)</span>满足以下条件：</p><ol type="1"><li><span class="math inline">\(a(x)\)</span>中有<span class="math inline">\(d_1\)</span>个系数为<span class="math inline">\(1\)</span>；</li><li><span class="math inline">\(a(x)\)</span>中有<span class="math inline">\(d_2\)</span>个系数为<span class="math inline">\(-1\)</span>；</li><li><span class="math inline">\(a(x)\)</span>中其余系数均为<span class="math inline">\(0\)</span>.</li></ol><p>则称这个多项式为一个三元多项式（ternary polynomial，或称trinary polynomial），对于一个卷积多项式环<span class="math inline">\(R\)</span>，其上的所有三元多项式的集合记为： <span class="math display">\[\mathcal{T}(d_1,d_2)=\left\{a(x)\in R| a(x)\text{ is a ternary polynomial}\right\}\]</span></p><h2 id="ntru算法细节">NTRU算法细节</h2><p>取整数<span class="math inline">\(N\ge1\)</span>以及两个模数<span class="math inline">\(p,q\)</span>（其中<span class="math inline">\(N\)</span>为质数，且<span class="math inline">\(N\)</span>与<span class="math inline">\(q\)</span>互质，<span class="math inline">\(p\)</span>与<span class="math inline">\(q\)</span>互质），得到如下三个卷积多项式环： <span class="math display">\[R=\frac{\mathbb{Z}[x]}{(x^{N}-1)},\quad R_p=\frac{(\mathbb{Z}/p\mathbb{Z})[x]}{(x^{N}-1)},\quad R_q=\frac{(\mathbb{Z}/q\mathbb{Z})[x]}{(x^{N}-1)}\]</span> 在此我们将消息传递的双方分别称为Alice和Bob，Alice选取公共参数<span class="math inline">\((N,p,q,d)\)</span>（<span class="math inline">\(d\)</span>也是个整数，公共参数的选择应满足<span class="math inline">\(q&gt;(6d+1)p\)</span>），并在<span class="math inline">\(R\)</span>上随机选取三元多项式<span class="math inline">\(f(x)\in\mathcal{T}(d+1,d)\)</span>以及<span class="math inline">\(g(x)\in\mathcal{T}(d,d)\)</span>，计算： <span class="math display">\[\begin{aligned}F_p\equiv f^{-1}\pmod{p}\\F_q\equiv f^{-1}\pmod{q}\end{aligned}\]</span> 这样就可以得到一个<span class="math inline">\(R_p\)</span>上的多项式<span class="math inline">\(F_p\)</span>以及一个<span class="math inline">\(R_q\)</span>上的多项式<span class="math inline">\(F_q\)</span>，在此之后Alice在<span class="math inline">\(R_q\)</span>上计算： <span class="math display">\[h(x)=F_q(x)\star g(x)\]</span> 在这里“<span class="math inline">\(\star\)</span>”表示卷积多项式环上多项式的乘法，对于两个卷积多项式环<span class="math inline">\(R\)</span>上的多项式<span class="math inline">\(a(x),b(x)\)</span>，其乘积定义如下： <span class="math display">\[a(x)\star b(x)=c(x),\quad c_k=\sum_{i+j\equiv k\pmod{N}}{a_{i}b_{j}}\]</span> 由此计算出的多项式<span class="math inline">\(h(x)\)</span>即为<strong>公钥</strong>，前面生成的<span class="math inline">\((f,F_p)\)</span>就是<strong>私钥</strong>（实际上私钥只需要<span class="math inline">\(f\)</span>，Alice可以通过<span class="math inline">\(f\)</span>来计算出<span class="math inline">\(F_p\)</span>）。 在此之后Bob需要通过公钥<span class="math inline">\(h(x)\)</span>来加密明文<span class="math inline">\(m(x)\)</span>（其中明文<span class="math inline">\(m(x)\in R\)</span>，而且其中系数<span class="math inline">\(m_i\)</span>满足<span class="math inline">\(-\frac{p}{2}&lt;m_i\le \frac{p}{2}\)</span>，实际上<span class="math inline">\(m(x)\)</span>就是<span class="math inline">\(R_p\)</span>上某个多项式的center-lift），Bob先选取一个随机三元多项式<span class="math inline">\(r(x)\in\mathcal{T}(d,d)\)</span>，计算： <span class="math display">\[e(x)\equiv ph(x)\star r(x)+m(x)\pmod{q}\]</span> 得到的多项式<span class="math inline">\(e(x)\)</span>就是Bob的密文，Alice得到Bob发送的密文之后要进行解密，则需先在<span class="math inline">\(R_q\)</span>上计算： <span class="math display">\[a(x)\equiv f(x)\star e(x)\pmod{q}\]</span> 然后得到<span class="math inline">\(a(x)\)</span>的center-lift，然后再在<span class="math inline">\(R_p\)</span>中计算： <span class="math display">\[b(x)\equiv F_p(x)\star a(x)\pmod{p}\]</span> 这样得到的<span class="math inline">\(R_p\)</span>上的多项式<span class="math inline">\(b(x)\)</span>就是明文<span class="math inline">\(m(x)\)</span>. NTRU大致流程如下图所示（在参考资料里截的）： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202504092251259.png" alt="Pasted image 20250408212029" /></p><h3 id="ntru的实现">NTRU的实现</h3><p>在这里通过sage实现参考资料中的一个例子（Example 7.53）： 取<span class="math inline">\((N, p, q, d) = (7, 3, 41, 2)\)</span>，显然有<span class="math inline">\((6d+1)p=39&lt;q\)</span>，而且<span class="math inline">\((p,q)=1,(N,q)=1\)</span>，符合参数选择的条件，那么可以通过如下代码构造出三个卷积多项式环： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure> 对固定的卷积多项式环<span class="math inline">\(R\)</span>，可以通过如下代码来获得随机三元多项式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">T</span>(<span class="params">R, N, d1, d2</span>):</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line">    coef = [<span class="number">1</span>] * d1 + [-<span class="number">1</span>] * d2 + [<span class="number">0</span>] * (N - d1 - d2)</span><br><span class="line">    shuffle(coef)</span><br><span class="line">    <span class="keyword">return</span> R(coef)</span><br></pre></td></tr></table></figure> 随机选取两个<span class="math inline">\(R\)</span>上的三元多项式<span class="math inline">\(f(x)\in\mathcal{T}(3,2)\)</span>以及<span class="math inline">\(g(x)\in\mathcal{T}(2,2)\)</span>（并保证<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(R_p\)</span>以及<span class="math inline">\(R_q\)</span>上均可逆），根据给出的例子，选取的两个多项式如下： <span class="math display">\[\begin{aligned}&amp;f(x)=x^6−x^4+x^3+x^2−1\\&amp;g(x)=x^6+x^4−x^2−x\end{aligned}\]</span> 然后分别在<span class="math inline">\(R_p,R_q\)</span>上计算<span class="math inline">\(f(x)\)</span>的逆，按道理，我们可以通过如下代码来求多项式<span class="math inline">\(f(x)\)</span>在任意模卷积多项式环<span class="math inline">\(R_m\)</span>的逆： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(<span class="built_in">list</span>(f)).inverse()</span><br></pre></td></tr></table></figure> 但是如果环<span class="math inline">\(R_m\)</span>的模数为合数的时候就跑不动了，找了一圈在<a href="https://latticehacks.cr.yp.to/ntru.html">这里</a>找到了一种名为<code>invertmodpowerof2</code>的算法，经过修改得到了下面的版本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertmodpowerof2</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> modulo.is_power_of(<span class="number">2</span>)</span><br><span class="line">    _R2 = PolynomialRing(Zmod(<span class="number">2</span>), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    R2 = _R2.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    g = R2(<span class="built_in">list</span>(f)).inverse()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = center_lift(Rm, R, Rm(<span class="built_in">list</span>(f * g)))</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        g = center_lift(Rm, R, Rm(<span class="built_in">list</span>(g * (<span class="number">2</span> - r))))</span><br></pre></td></tr></table></figure> 不过这个算法只能用于模数为<span class="math inline">\(2^k\)</span>的情况，对一般合数暂时还没找到合适的方案. 回到例子，通过如下代码可以计算出<span class="math inline">\(F_p\)</span>以及<span class="math inline">\(F_q\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fp = inv(Rp, f)</span><br><span class="line">Fq = inv(Rq, f)</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[\begin{aligned}&amp;F_p=x^{6} + 2 x^{5} + x^{3} + x^{2} + x + 1\in R_p\\&amp;F_q=8 x^{6} + 26 x^{5} + 31 x^{4} + 21 x^{3} + 40 x^{2} + 2 x + 37\in R_q\end{aligned}\]</span> 可以得到<span class="math inline">\((f,F_p)\)</span>作为私钥，并通过如下代码计算公钥<span class="math inline">\(h(x)=F_q(x)\star g(x)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = Fq * Rq(<span class="built_in">list</span>(g))</span><br></pre></td></tr></table></figure> 得到： <span class="math display">\[h(x)=F_q(x)\star g(x)=20 x^{6} + 40 x^{5} + 2 x^{4} + 38 x^{3} + 8 x^{2} + 26 x + 30\in R_q\]</span> 欲加密消息<span class="math inline">\(m(x)=−x^5+x^3+x^2−x+1\)</span>，取<span class="math inline">\(R\)</span>上随机三元多项式<span class="math inline">\(r(x)=x^6 −x^5 +x−1\in\mathcal{T}(2,2)\)</span>，通过<code>e = Rq(list(p*r*h + m))</code>在<span class="math inline">\(R_q\)</span>上计算<span class="math inline">\(e(x)\equiv pr(x)\star h(x)+m(x)\pmod{q}\)</span>，得到密文： <span class="math display">\[e(x)=31 x^{6} + 19 x^{5} + 4 x^{4} + 2 x^{3} + 40 x^{2} + 3 x + 25\]</span> 参数选取以及加密全流程代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(N, p, q, d) = (<span class="number">7</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">T</span>(<span class="params">R, N, d1, d2</span>):</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line">    coef = [<span class="number">1</span>] * d1 + [-<span class="number">1</span>] * d2 + [<span class="number">0</span>] * (N - d1 - d2)</span><br><span class="line">    shuffle(coef)</span><br><span class="line">    <span class="keyword">return</span> R(coef)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(f).inverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertmodpowerof2</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> modulo.is_power_of(<span class="number">2</span>)</span><br><span class="line">    _R2 = PolynomialRing(Zmod(<span class="number">2</span>), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    R2 = _R2.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    g = R2(<span class="built_in">list</span>(f)).inverse()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = center_lift(Rm, R, Rm(<span class="built_in">list</span>(f * g)))</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        g = center_lift(Rm, R, Rm(<span class="built_in">list</span>(g * (<span class="number">2</span> - r))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># f = T(R, N, d + 1, d)</span></span><br><span class="line">f = R(<span class="string">&quot;x^6 - x^4 + x^3 + x^2 - 1&quot;</span>) <span class="comment"># private key</span></span><br><span class="line"><span class="comment"># g = T(R, N, d, d)</span></span><br><span class="line">g = R(<span class="string">&quot;x^6 + x^4 - x^2 - x&quot;</span>)</span><br><span class="line"></span><br><span class="line">Fp = inv(Rp, f)</span><br><span class="line">Fq = inv(Rq, f)</span><br><span class="line"></span><br><span class="line">h = Fq * Rq(<span class="built_in">list</span>(g)) <span class="comment"># public key</span></span><br><span class="line"></span><br><span class="line">m = R(<span class="string">&quot;-x^5+x^3+x^2-x+1&quot;</span>)</span><br><span class="line"><span class="comment"># r = T(R, N, d, d)</span></span><br><span class="line">r = R(<span class="string">&quot;x^6-x^5+x-1&quot;</span>)</span><br><span class="line"></span><br><span class="line">e = Rq(<span class="built_in">list</span>(p*r*h + m))</span><br></pre></td></tr></table></figure> 在获取密文之后，需要首先在<span class="math inline">\(R_q\)</span>上计算<span class="math inline">\(f(x)\star e(x)\)</span>并获取其center-lift得到<span class="math inline">\(a(x)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br></pre></td></tr></table></figure> 得到： <span class="math display">\[a(x)=x^{6} + 10x^{5} - 8x^{4} - x^{3} - x^{2} + x - 1\]</span></p><p>然后在<span class="math inline">\(R_p\)</span>上计算<span class="math inline">\(F_p\star a(x)\)</span>并获取其center-lift得到<span class="math inline">\(b(x)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br></pre></td></tr></table></figure> 此时可以得到： <span class="math display">\[b(x)=-x^{5} + x^{3} + x^{2} - x + 1\]</span> 可以看到<span class="math inline">\(b(x)=m(x)\)</span>，说明此时计算出来的就是明文，如此可以得到解密流程如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br><span class="line">b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br></pre></td></tr></table></figure></p><h2 id="ntru的格攻击">NTRU的格攻击</h2><p>回到公钥计算这一步，我们需要在<span class="math inline">\(R_q\)</span>上计算<span class="math inline">\(h(x)=F_q(x)\star g(x)\)</span>，两边乘上<span class="math inline">\(f(x)\)</span>可以得到： <span class="math display">\[f(x)\star h(x)\equiv g(x)\pmod{q}\]</span> 与对数的处理方法类似的，可以将上式变为： <span class="math display">\[f(x)\star h(x)=g(x)+q\cdot u(x)\]</span> 其中<span class="math inline">\(u(x)\in R\)</span>，我们想要的是私钥<span class="math inline">\(f(x)\)</span>，那么可以构造出如下方程： <span class="math display">\[(f(x),-u(x))\left(\begin{matrix}1&amp;h(x)\\0&amp;q\end{matrix}\right)=(f(x),g(x))\tag{1}\]</span> 但是直接对多项式矩阵进行规约应该是不太可能的，那么需要找到一种方法来将多项式矩阵转换为一般的矩阵，先前提到对于两个卷积多项式环<span class="math inline">\(R\)</span>上的多项式<span class="math inline">\(a(x),b(x)\)</span>，其乘积定义为： <span class="math display">\[a(x)\star b(x)=c(x),\quad c_k=\sum_{i+j\equiv k\pmod{N}}{a_{i}b_{j}}\]</span> 显然有： <span class="math display">\[c_k=(a_0,a_1,\cdots,a_{N-1})\cdot(b_{k\mod{N}},b_{k-1\mod{N}},\cdots,b_{k-N+1\mod{N}})^T\]</span> 那么可以得到： <span class="math display">\[(c_0,c_1,\cdots, c_{N-1})=(a_0,a_1,\cdots,a_{N-1})\left(\begin{matrix}b_0&amp;b_1&amp;\cdots&amp;b_{N-1}\\b_{N-1}&amp;b_0&amp;\cdots&amp;b_{N-2}\\\vdots&amp;\vdots&amp;&amp;\vdots\\b_{1}&amp;b_{2}&amp;\cdots&amp;b_{0}\end{matrix}\right)\]</span> 实际上等式右边的矩阵是<span class="math inline">\(b(x)\)</span>的系数的循环排列，这样我们就可以将矩阵内的<span class="math inline">\(h(x)\)</span>转换为一个<span class="math inline">\(n\times n\)</span>的矩阵： <span class="math display">\[H=\left(\begin{matrix}h_0&amp;h_1&amp;\cdots&amp;h_{N-1}\\h_{N-1}&amp;h_0&amp;\cdots&amp;h_{N-2}\\\vdots&amp;\vdots&amp;&amp;\vdots\\h_{1}&amp;h_{2}&amp;\cdots&amp;h_{0}\end{matrix}\right)\]</span> 同理，由于<span class="math inline">\(1\)</span>以及<span class="math inline">\(q\)</span>也可以看作是仅有常数项不为<span class="math inline">\(0\)</span>的多项式，所以可以将它们分别转换为单位矩阵<span class="math inline">\(I\)</span>以及<span class="math inline">\(q\)</span>倍的单位矩阵<span class="math inline">\(qI\)</span>，而行向量内的多项式<span class="math inline">\(f(x)\)</span>可以转换为其对应的系数向量<span class="math inline">\(\pmb{f}=(f_0,f_1,\cdots,f_{N-1})\)</span>，同理<span class="math inline">\(u(x),g(x)\)</span>也可以转换为对应的系数向量<span class="math inline">\(\pmb{u}\)</span>以及<span class="math inline">\(\pmb{g}\)</span>，那么我们就可以得到方程<span class="math inline">\((1)\)</span>的等价表示： <span class="math display">\[(\pmb{f},-\pmb{u})\left(\begin{matrix}I&amp;H\\0&amp;qI\end{matrix}\right)=(\pmb{f},\pmb{g})\]</span> 其中<span class="math inline">\(2N\times2N\)</span>矩阵<span class="math inline">\(\left(\begin{matrix}I&amp;H\\0&amp;qI\end{matrix}\right)\)</span>所确定的格被称为NTRU格（NTRU Lattice）一般记为<span class="math inline">\(\mathcal{L}_h^{\text{NTRU}}\)</span>，方便起见，后续将其记作<span class="math inline">\(\mathcal{L}_h\)</span>，显然向量<span class="math inline">\((\pmb{f},\pmb{g})\in\mathcal{L}_h\)</span>，接下来分析通过对<span class="math inline">\(\mathcal{L}_h\)</span>进行格基规约得到向量<span class="math inline">\((\pmb{f},\pmb{g})\)</span>的可能性： 因为<span class="math inline">\(\det(\mathcal{L}_h)=q^N\)</span>，所以有： <span class="math display">\[\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2N}\cdot|\det(\mathcal{L}_h)|^{1/2N}=\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2Nq}\]</span> 取<span class="math inline">\(\delta=\frac{3}{4}\)</span>，有： <span class="math display">\[\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2Nq}=(\sqrt{2})^{2N-1}\cdot\sqrt{2Nq}=2^N\sqrt{Nq}\]</span> 而因为<span class="math inline">\(f(x),g(x)\)</span>都是三元多项式，所以： <span class="math display">\[||(\pmb{f},\pmb{g})||=\sqrt{4d+1}\le2^N\sqrt{Nq}=\left(\frac{2}{\sqrt{4\delta-1}}\right)^{2N-1}\sqrt{2N}\cdot|\det(\mathcal{L}_h)|^{1/2N}\]</span> 很显然，<span class="math inline">\((\pmb{f},\pmb{g})\)</span>可以通过BKZ算法对格<span class="math inline">\(\mathcal{L}_h\)</span>进行格基规约得到（LLL有时候不行），通过如下代码就可以构造出格并进行规约： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)] <span class="comment"># 有时候可能h要乘上一个pow(q, -1, p)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]</span><br><span class="line"></span><br><span class="line">res = L.BKZ()</span><br></pre></td></tr></table></figure> 但是目标向量并不一定在第一条，所以需要遍历每一行，判断前<span class="math inline">\(N\)</span>个分量表示的多项式是否属于<span class="math inline">\(\mathcal{T}(d+1, d)\)</span>再尝试求解，经过测试发现，一个公钥可以通过格攻击获取多个私钥，并且这些私钥都可以成功进行解密，例如对于前面的例子，假设我们只知道公钥： <span class="math display">\[h(x)=20 x^{6} + 40 x^{5} + 2 x^{4} + 38 x^{3} + 8 x^{2} + 26 x + 30\]</span> 以及密文： <span class="math display">\[e(x)=31 x^{6} + 19 x^{5} + 4 x^{4} + 2 x^{3} + 40 x^{2} + 3 x + 25\]</span> 可以通过构造格进行私钥的恢复： <span class="math display">\[\mathcal{L}_h=\left(\begin{array}{rrrrrrrrrrrrrr} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 30 &amp; 26 &amp; 8 &amp; 38 &amp; 2 &amp; 40 &amp; 20 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 20 &amp; 30 &amp; 26 &amp; 8 &amp; 38 &amp; 2 &amp; 40 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 40 &amp; 20 &amp; 30 &amp; 26 &amp; 8 &amp; 38 &amp; 2 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 40 &amp; 20 &amp; 30 &amp; 26 &amp; 8 &amp; 38 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 38 &amp; 2 &amp; 40 &amp; 20 &amp; 30 &amp; 26 &amp; 8 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 8 &amp; 38 &amp; 2 &amp; 40 &amp; 20 &amp; 30 &amp; 26 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 26 &amp; 8 &amp; 38 &amp; 2 &amp; 40 &amp; 20 &amp; 30 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 41 \end{array}\right)\]</span> 恢复私钥并解密的代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]</span><br><span class="line"></span><br><span class="line">res = L.BKZ()[<span class="number">1</span>]</span><br><span class="line">ff = R([ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> res[:N]])</span><br><span class="line"><span class="built_in">print</span>(ff)</span><br><span class="line"></span><br><span class="line">fp = inv(Rp, ff)</span><br><span class="line">a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(ff * e)))</span><br><span class="line">b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(fp * a)))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure> 得到多项式<span class="math inline">\(f&#39;=-x^{6} - x^{5} + x^{3} - x^{2} + 1\)</span>，显然其不等于前面的私钥<span class="math inline">\(f=x^6−x^4+x^3+x^2−1\)</span>，但是计算出来的<span class="math inline">\(b=-x^{5} + x^{3} + x^{2} - x + 1\)</span>却等于前面选择的明文.</p><h3 id="例题sctf-2020lattice">例题：[SCTF 2020]Lattice</h3><p>题目地址：<a href="https://www.nssctf.cn/problem/1399">SCTF 2020：Lattice</a> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b16encode  </span><br><span class="line">  </span><br><span class="line">Zx.&lt;x&gt; = ZZ[]  </span><br><span class="line">n = <span class="number">109</span>   </span><br><span class="line">q = <span class="number">2048</span>  </span><br><span class="line">p = <span class="number">3</span>  </span><br><span class="line">Df = <span class="number">9</span>  </span><br><span class="line">Dg = <span class="number">10</span>  </span><br><span class="line">Dr = <span class="number">11</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">f,g</span>):  </span><br><span class="line">    <span class="keyword">return</span> (f * g) % (x^n-<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bal_mod</span>(<span class="params">f,q</span>):  </span><br><span class="line">    g = <span class="built_in">list</span>(((f[i] + q//<span class="number">2</span>) % q) - q//<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))  </span><br><span class="line">    <span class="keyword">return</span> Zx(g)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_poly</span>(<span class="params">d</span>):  </span><br><span class="line">    <span class="keyword">assert</span> d &lt;= n  </span><br><span class="line">    result = n*[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            r = randrange(n)  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result[r]: <span class="keyword">break</span>  </span><br><span class="line">        result[r] = <span class="number">1</span>-<span class="number">2</span>*randrange(<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">return</span> Zx(result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv_mod_prime</span>(<span class="params">f,p</span>):  </span><br><span class="line">    T = Zx.change_ring(Integers(p)).quotient(x^n-<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> Zx(lift(<span class="number">1</span> / T(f)))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv_mod_powerof2</span>(<span class="params">f,q</span>):  </span><br><span class="line">    <span class="keyword">assert</span> q.is_power_of(<span class="number">2</span>)  </span><br><span class="line">    g = inv_mod_prime(f,<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        r = bal_mod(mul(g,f),q)  </span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>: <span class="keyword">return</span> g  </span><br><span class="line">        g = bal_mod(mul(g,<span class="number">2</span> - r),q)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>():  </span><br><span class="line">    f = random_poly(Df)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            fp = inv_mod_prime(f,p)  </span><br><span class="line">            fq = inv_mod_powerof2(f,q)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            f = random_poly(Df)  </span><br><span class="line">    g = random_poly(Dg)  </span><br><span class="line">    h = bal_mod(p * mul(fq,g),q)  </span><br><span class="line">    pub_key = h  </span><br><span class="line">    pri_key = [f,fp]  </span><br><span class="line">    <span class="keyword">return</span> pub_key,pri_key  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m,h</span>):  </span><br><span class="line">    r = random_poly(Dr)  </span><br><span class="line">    e = bal_mod(mul(h,r) + m,q)  </span><br><span class="line">    <span class="keyword">return</span> e  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    pub_key,pri_key = keygen()  </span><br><span class="line">    flag=<span class="string">b&#x27;SCTF&#123;***********&#125;&#x27;</span>[<span class="number">5</span>:-<span class="number">1</span>]  </span><br><span class="line">    m = Zx(<span class="built_in">list</span>(<span class="built_in">bin</span>(<span class="built_in">int</span>(b16encode(flag), <span class="number">16</span>))[<span class="number">2</span>:]))  </span><br><span class="line">    <span class="built_in">print</span>(m)  </span><br><span class="line">    e = encrypt(m,pub_key)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pub_key=&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(pub_key)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;e=&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure> 显然这是NTRU加密，题目代码将flag转换为二进制然后转化为一个多项式<span class="math inline">\(m(x)\)</span>，给出了公钥<span class="math inline">\(h(x)\)</span>以及密文<span class="math inline">\(e(x)\)</span>，要恢复出明文<span class="math inline">\(m(x)\)</span>，则需要先恢复出私钥，通过下面的代码就可以通过格攻击恢复出明文<span class="math inline">\(m(x)\)</span>，并恢复出flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">N = <span class="number">109</span></span><br><span class="line">q = <span class="number">2048</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">_R = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">R = _R.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rp = PolynomialRing(Zmod(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rp = _Rp.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_Rq = PolynomialRing(Zmod(q), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">Rq = _Rq.quotient(x^N - <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">center_lift</span>(<span class="params">Rm, R, f</span>):</span><br><span class="line">    modulo = ZZ(Rm(<span class="built_in">list</span>(f)).base_ring()(-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">    l = [ZZ(x) <span class="keyword">if</span> x &lt;= modulo // <span class="number">2</span> <span class="keyword">else</span> ZZ(x) - modulo <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(f)]</span><br><span class="line">    <span class="keyword">return</span> R(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">Rm, f</span>):</span><br><span class="line">    <span class="keyword">return</span> Rm(f).inverse()</span><br><span class="line"></span><br><span class="line">h = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">e = R(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">L = matrix(ZZ, <span class="number">2</span>*N, <span class="number">2</span>*N)</span><br><span class="line"></span><br><span class="line">h_coeff = [ZZ(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(h)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    L[i, i] = <span class="number">1</span></span><br><span class="line">    L[N + i, N + i] = q</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        L[i, N + j] = h_coeff[(j - i) % N]</span><br><span class="line"></span><br><span class="line">res = L.BKZ(blocksize=<span class="number">24</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> res:</span><br><span class="line">    fc = <span class="built_in">list</span>(v[:N])</span><br><span class="line">    c0, c1, c_1 = fc.count(<span class="number">0</span>), fc.count(<span class="number">1</span>), fc.count(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> c0 == <span class="number">100</span> <span class="keyword">and</span> c1 + c_1 == <span class="number">9</span>:</span><br><span class="line">        f = R(fc)</span><br><span class="line">        Fp = inv(Rp, f)</span><br><span class="line">        a = center_lift(Rq, R, Rq(<span class="built_in">list</span>(f * e)))</span><br><span class="line">        b = center_lift(Rp, R, Rp(<span class="built_in">list</span>(Fp * a)))</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> ct])</span><br><span class="line">        pad = <span class="number">8</span> - <span class="built_in">len</span>(s) % <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pad + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(<span class="string">&#x27;0&#x27;</span> * i + s + <span class="string">&#x27;0&#x27;</span> * (pad - i), <span class="number">2</span>)))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure> 可以得到flag：<code>SCTF&#123;@#26f35b89d3#@&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格密码</title>
      <link href="/2025/03/31/%E6%A0%BC%E5%AF%86%E7%A0%81/"/>
      <url>/2025/03/31/%E6%A0%BC%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://eprint.iacr.org/2023/032.pdf">A Gentle Tutorial for Lattice-Based Cryptanalysis</a></p></li><li><p><a href="https://link.springer.com/article/10.1007/BF01201999">Improved low-density subset sum algorithms</a></p></li><li><p><a href="https://link.springer.com/article/10.1007/s11424-015-3324-9">Solving low-density multiple subset sum problems with SVP oracle</a></p></li><li><p><a href="https://link.springer.com/chapter/10.1007/978-3-540-74462-7_9">Extended Hidden Number Problem and Its Cryptanalytic Applications</a></p></li><li><p><a href="https://link.springer.com/chapter/10.1007/3-540-46701-7_14">Extending Wiener’s Attack in the Presence of Many Decrypting Exponents</a></p></li></ol></blockquote><h2 id="格lattice">格（Lattice）</h2><h3 id="格的概念">格的概念</h3><p><strong>定义</strong>：一个<span class="math inline">\(n\)</span>维的格<span class="math inline">\(\mathcal{L}\)</span>是<span class="math inline">\(\mathbb{R}^{n}\)</span>的一个离散可加的子群. 对于格<span class="math inline">\(\mathcal{L}\)</span>，其可以被表示为由<span class="math inline">\(\mathbb{R}^{n}\)</span>上<span class="math inline">\(m\)</span>个线性无关的基向量<span class="math inline">\(\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_m\}\)</span>组成的基<span class="math inline">\(\pmb{B}\)</span>，向量的个数<span class="math inline">\(m\)</span>被称为格<span class="math inline">\(\mathcal{L}\)</span>的秩，所以格<span class="math inline">\(\mathcal{L}\)</span>也能表示为： <span class="math display">\[\mathcal{L}=\mathcal{L}(\pmb{B})=\left\{\sum_{i=1}^{m}a_i\pmb{b}_i|a_i\in\mathbb{Z},i=1,2,\cdots,m\right\}\]</span> 格的很多性质与记号与线性空间（向量空间）类似。 <strong>逐次最小长度</strong>：对于一个秩维<span class="math inline">\(n\)</span>的格<span class="math inline">\(\mathcal{L}\)</span>，对于<span class="math inline">\(i\in\{1,2,\cdots n\}\)</span>，若<span class="math inline">\(r\)</span>是使得格<span class="math inline">\(\mathcal{L}\)</span>拥有<span class="math inline">\(i\)</span>个长度最大为<span class="math inline">\(r\)</span>且线性无关的向量的最小值，则称<span class="math inline">\(r\)</span>为格<span class="math inline">\(\mathcal{L}\)</span>的第<span class="math inline">\(i\)</span>逐次最小长度，记为<span class="math inline">\(\lambda_i(\mathcal{L})=r\)</span> 关于逐次最小长度，我们有闵可夫斯基（Minkowski）第一定理： <strong>闵可夫斯基（Minkowski）第一定理</strong>：设<span class="math inline">\(\mathcal{L}\)</span>是一个<span class="math inline">\(n\)</span>维满秩格，则： <span class="math display">\[\lambda_1(\mathcal{L})\le\sqrt{n}|\det(\mathcal{L})|^{1/n}\]</span> 闵可夫斯基第一定理表明我们可以以<span class="math inline">\(\lambda_1(\mathcal{L})\)</span>为标准来评判格中向量的长度.</p><h3 id="关于格的问题">关于格的问题</h3><p><strong>最短向量问题</strong>（Shortest Vector Problem, <span class="math inline">\(\text{SVP}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>，找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足<span class="math inline">\(||\pmb{v}||=\lambda_1(\mathcal{L})\)</span>. <strong>最近向量问题</strong>（Closest Vector Problem, <span class="math inline">\(\text{CVP}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>以及一个目标向量<span class="math inline">\(\pmb{t}\)</span>（不一定在格<span class="math inline">\(\mathcal{L}\)</span>上），找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足 <span class="math display">\[||\pmb{v}-\pmb{t}||=\min_{\pmb{w}\in\mathcal{L}}||\pmb{w}-\pmb{t}||\]</span> 上述问题均为NP-Hard问题，这些问题的宽松版本如下： <strong>近似最短向量问题</strong>（Approximate Shortest Vector Problem, <span class="math inline">\(\text{SVP}_{\gamma}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>与近似因子<span class="math inline">\(\gamma\)</span>，找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足<span class="math inline">\(||\pmb{v}||\le\gamma\cdot\lambda_1(\mathcal{L})\)</span>. <strong>近似最近向量问题</strong>（Approximate Closest Vector Problem, <span class="math inline">\(\text{CVP}_{\gamma}\)</span>）：给定格<span class="math inline">\(\mathcal{L}\)</span>的基<span class="math inline">\(\pmb{B}\)</span>、一个目标向量<span class="math inline">\(\pmb{t}\)</span>（不一定在格<span class="math inline">\(\mathcal{L}\)</span>上）以及一个近似因子<span class="math inline">\(\gamma\)</span>，找到格<span class="math inline">\(\mathcal{L}\)</span>上的一个非零向量<span class="math inline">\(\pmb{v}\)</span>满足 <span class="math display">\[||\pmb{v}-\pmb{t}||=\gamma\cdot\min_{\pmb{w}\in\mathcal{L}}||\pmb{w}-\pmb{t}||\]</span> 而<span class="math inline">\(\text{SVP}_{\gamma}\)</span>与<span class="math inline">\(\text{CVP}_{\gamma}\)</span>对于确定的参数均存在有效的解决方案，所以我们可以通过解决<span class="math inline">\(\text{SVP}_{\gamma}\)</span>与<span class="math inline">\(\text{CVP}_{\gamma}\)</span>来近似地解决<span class="math inline">\(\text{SVP}\)</span>与<span class="math inline">\(\text{CVP}\)</span>. 我们可以通过格基规约来解决上述两个可计算问题.</p><h3 id="格基规约">格基规约</h3><p>格基规约的目标是将一个任意一个格转化为另外一个基相同但是具有更短、更多的正交向量。由于我们要找的是“短向量”，所以格基规约可能会提供解决近似最短向量问题的方法.</p><h4 id="lll算法">LLL算法</h4><p>LLL算法是一个迭代算法，由Lenstra、Lenstra与Lovász提出. 这个迭代算法的第一步是通过施密特正交化获得基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>的一组正交基，通过施密特正交化，我们可以将格基进行约减，对于上面的基<span class="math inline">\(\pmb{B}\)</span>，施密特正交化过程如下： <span class="math display">\[\begin{cases}\pmb{b}_i^{*}=\pmb{b}_i,&amp;i=1\\\pmb{b}_i^{*}=\pmb{b}_i-\sum_{j=1}^{i-1}\mu_{i,j}\pmb{b}_j^{*},&amp;1&lt;i\le n\end{cases}\kern{25pt}\mu_{i,j}=\frac{\langle\pmb{b}_i,\pmb{b}_{j}^{*}\rangle}{\langle\pmb{b}^{*}_{j},\pmb{b}^{*}_{j}\rangle}\]</span> 而对于<span class="math inline">\(\delta\in(\frac{1}{4},1)\)</span>，如果基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>满足：</p><ol type="1"><li>（尺寸约减，size-reduction）对于任意<span class="math inline">\(i&gt;j\)</span>，有<span class="math inline">\(|\mu_{i,j}|\le\frac{1}{2}\)</span>；</li><li>（Lovász条件，Lovász condition）对于任意<span class="math inline">\(i\in\{1,2,\cdots,n-1\}\)</span>，有<span class="math inline">\((\delta-\mu_{i+1,i}^{2})||\pmb{b}_{i}^{*}||^{2}\le||\pmb{b}_{i+1}^{*}||^2\)</span></li></ol><p>则称基<span class="math inline">\(\pmb{B}\)</span>为<span class="math inline">\(\delta\)</span>-LLL约减基，通过结合这两个条件，Lenstra、Lenstra与Lovász给出了LLL算法： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311318467.png" alt="Pasted image 20250203175051" /> 而对于格中最短向量的下界，我们有如下定理： 设格基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>对应的施密特正交基为基<span class="math inline">\(\pmb{B}^*=\{\pmb{b}_1^*,\pmb{b}_2^*,\cdots,\pmb{b}_n^*\}\)</span>，则有： <span class="math display">\[\lambda_1(\mathcal{L}(\pmb{B}))\ge\min_{i\in\{1,\cdots,n\}}||\pmb{b}^{*}_{i}||\]</span> 通过这个定理，我们可以导出如下命题： 假若<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>是一个<span class="math inline">\(\delta\)</span>-LLL约减基，则必然有： <span class="math display">\[||\pmb{b}_1||\le\left(\frac{2}{\sqrt{4\delta-1}}\right)^{n-1}\sqrt{n}\cdot|\det(\mathcal{L})|^{1/n}\]</span></p><p>这条式子往往可以帮助我们判断一个格基是否能通过LLL来约减出最短向量. 在sage中内置了现成的LLL算法，例如我们要解决<a href="https://eprint.iacr.org/2023/032.pdf">A Gentle Tutorial for Lattice-Based Cryptanalysis</a>中的例3.12（如下图）： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311317528.png" alt="Pasted image 20250203182155" /> 则可以通过下面的步骤来获得结果： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311318138.png" alt="Pasted image 20250203182349" /> 显然可以得到结果为<span class="math inline">\(\pmb{b}_1^*=(0,-1),\pmb{b}_2^*=(-2,0)\)</span>.</p><h3 id="解决cvp">解决CVP</h3><p>LLL算法同样可以用来解决近似最近向量问题，但是需要结合Babai最近平面算法或者Kannan嵌入法</p><h4 id="babai最近平面算法babais-nearest-plane-algorithm">Babai最近平面算法（Babai’s Nearest Plane Algorithm）</h4><p>Babai最近平面算法首先要获得输入格的约减基<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>，然后对于目标向量<span class="math inline">\(\pmb{t}\)</span>，我们令<span class="math inline">\(\pmb{t}&#39;=\pmb{t}-c_n\pmb{b}_n\)</span>，其中：<span class="math inline">\(c_n=\lceil\langle\pmb{t},\pmb{b}^*_{n}\rangle/\langle\pmb{b}^*_{n},\pmb{b}^*_{n}\rangle\rfloor\)</span>（其中<span class="math inline">\(\lceil\cdot\rfloor\)</span>表示四舍五入），然后对前<span class="math inline">\(n-1\)</span>个向量与<span class="math inline">\(\pmb{t}&#39;\)</span>进行操作，得到<span class="math inline">\(\pmb{t}&#39;&#39;=\pmb{t}&#39;-c_{n-1}\pmb{b}_{n-1}\)</span>，其中<span class="math inline">\(c_n=\lceil\langle\pmb{t}&#39;,\pmb{b}^*_{n-1}\rangle/\langle\pmb{b}^*_{n-1},\pmb{b}^*_{n-1}\rangle\rfloor\)</span>，以此类推，就可以得到完整的Babai最近平面算法： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311319585.png" alt="Pasted image 20250204163747" /></p><h4 id="kannan嵌入法">Kannan嵌入法</h4><p>Kannan嵌入法是通过将目标向量嵌入格基，从而将CVP转化为SVP进行求解，设输入的格基为<span class="math inline">\(\pmb{B}=\{\pmb{b}_1,\pmb{b}_2,\cdots,\pmb{b}_n\}\)</span>，而目标向量为<span class="math inline">\(\pmb{t}=(t_1,t_2,\cdots,t_n)\)</span>，我们设CVP的解为<span class="math inline">\(c_1\pmb{b}_1+c_2\pmb{b}_2+\cdots+c_n\pmb{b}_n\)</span>，即： <span class="math display">\[\pmb{t}\approx\sum_{i=1}^{n}c_i\pmb{b}_i\]</span> 也就有： <span class="math display">\[\pmb{t}=\sum_{i=1}^{n}c_i\pmb{b}_i+\pmb{e}\]</span> 其中<span class="math inline">\(||\pmb{e}||\)</span>很小，所以我们就可以构造出一个<span class="math inline">\(n+1\)</span>维的格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}\pmb{B}&amp;0\\\pmb{t}&amp;q\end{matrix}\right)\]</span> 因为有： <span class="math display">\[(-c_1,-c_2,\cdots,-c_n,1)\pmb{B}&#39;=(\pmb{e},q)\]</span> 所以这个格显然包含短向量<span class="math inline">\((\pmb{e},q)\)</span>，由此我们就可以得到CVP的解为<span class="math inline">\(\pmb{t}-\pmb{e}\)</span>. 在这里，整数<span class="math inline">\(q\)</span>称为嵌入因子，它会影响到通过LLL算法寻找正确向量的成功率，应根据实际情况选取.</p><h2 id="格在密码学中的应用">格在密码学中的应用</h2><h3 id="背包问题knapsack-problem">背包问题（Knapsack Problem）</h3><p>背包问题是NP完全问题，其经常被用于作为公钥密码体系的陷阱门。在密码学中，背包问题的常见版本为子集和问题，即：给定<span class="math inline">\(n\)</span>个正数<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>与一个整数<span class="math inline">\(s\)</span>，寻找集合<span class="math inline">\(\{a_1,a_2,\cdots,a_n\}\)</span>的子集使得其和为<span class="math inline">\(s\)</span>。也就是找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>使得： <span class="math display">\[s=\sum_{i=1}^{n}e_ia_i\]</span></p><h4 id="低密度子集和问题">低密度子集和问题</h4><p>集合<span class="math inline">\(\{a_1,a_2,\cdots,a_n\}\)</span>的密度<span class="math inline">\(d\)</span>可以通过下式计算： <span class="math display">\[d=\frac{n}{\log_2{\max_{i\in\{1,2,\cdots,n\}}(a_i)}}\]</span> 研究表明，当<span class="math inline">\(d&lt;0.9408\)</span>时，我们可以将子集和问题转换为求解SVP. 一般策略为构造一个格，其中有一个短向量包含<span class="math inline">\(\{e_1,e_2,\cdots,e_n\}\)</span>，这样我们就可以构造出下面的格基矩阵： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;&amp;&amp;&amp;a_1\\&amp;1&amp;&amp;&amp;a_2\\&amp;&amp;\ddots&amp;&amp;\vdots\\&amp;&amp;&amp;1&amp;a_n\\&amp;&amp;&amp;&amp;s\end{matrix}\right)\]</span> 显然线性组合<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\)</span>会生成一个短向量<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\pmb{B}=(e_1,e_2,\cdots,e_n,0)\)</span>，所以我们的预期是通过LLL算法对上述格进行规约得到这个短向量，但是这个方法在密度比较高的时候会失效，所以Coster等人提出了CJLOSS算法，使得我们可以在<span class="math inline">\(d&lt;0.9408\)</span>的时候通过将子集和问题转换为SVP从而在多项式时间内求解这个问题，CJLOSS算法中构造的格为： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}1&amp;&amp;&amp;&amp;Na_1\\&amp;1&amp;&amp;&amp;Na_2\\&amp;&amp;\ddots&amp;&amp;\vdots\\&amp;&amp;&amp;1&amp;Na_n\\\frac{1}{2}&amp;\frac{1}{2}&amp;\cdots&amp;\frac{1}{2}&amp;Ns\end{matrix}\right)\]</span> 其中整数<span class="math inline">\(N&gt;\sqrt{n}\)</span>，在这个格内，线性组合<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\)</span>会生成另外一个短向量： <span class="math display">\[(e_1,e_2,\cdots,e_n,-1)\pmb{B}&#39;=(e_1-\frac{1}{2},e_2-\frac{1}{2},\cdots,e_n-\frac{1}{2},0)\]</span> 显然这条短向量的模为<span class="math inline">\(\frac{\sqrt{n}}{2}\)</span>，我们很容易可以通过LLL算法求解出这条短向量（这个短向量一般是规约后的格的第一个向量，且前<span class="math inline">\(n\)</span>个元素往往为<span class="math inline">\(\frac{1}{2}-e_i\)</span>）。 使用sage通过CJLOSS算法求解低密度子集和的代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CJLOSS</span>(<span class="params">A, s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    N = ceil(sqrt(n))</span><br><span class="line">    L = matrix(QQ, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        L[i, i] = <span class="number">1</span></span><br><span class="line">        L[n, i] = <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">        L[i, n] = N * A[i]</span><br><span class="line">    L[n, n] = N * s</span><br><span class="line">    res = L.LLL()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> res:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(x <span class="keyword">in</span> [-<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>] <span class="keyword">for</span> x <span class="keyword">in</span> v[:-<span class="number">1</span>]):</span><br><span class="line">            out = [<span class="number">1</span>/<span class="number">2</span> - a <span class="keyword">for</span> a <span class="keyword">in</span> v[:-<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure> 例如，对于一个集合<span class="math inline">\(\{71, 73, 79, 107, 89, 91\}\)</span>，求出满足和为<span class="math inline">\(269\)</span>的一个子集，我们就可以通过CJLOSS算法进行求解（计算可得<span class="math inline">\(d=\frac{6}{\log_2{107}}\approx0.8900&lt;0.9408\)</span>）： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503311321632.png" alt="Pasted image 20250204213311" /> 所以可以得到和为<span class="math inline">\(269\)</span>的一个子集为<span class="math inline">\(\{73,107,89\}\)</span>.</p><h4 id="低密度多重子集和问题">低密度多重子集和问题</h4><p>通过对子集和问题的扩展，我们可以得到多重子集和问题：给定<span class="math inline">\(kn\)</span>个正整数<span class="math inline">\(a_{1,1},a_{1,2}\cdots,a_{k,n}\)</span>以及<span class="math inline">\(k\)</span>个整数<span class="math inline">\(s_1,\cdots,s_k\)</span>，找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>满足对任意<span class="math inline">\(j\in{1,2,\cdots,k}\)</span>： <span class="math display">\[s_j=\sum_{i=1}^{n}e_ia_{j,i}\]</span> 实际上多重子集和问题总体与普通子集和问题差不多，但是集合更多，此时我们通过下式对密度<span class="math inline">\(d\)</span>进行计算： <span class="math display">\[d=\frac{n}{k\log_2{\max_{\begin{matrix}\end{matrix}}(a_{j,i})}}\]</span> 根据潘彦斌等人研究可以得出，当<span class="math inline">\(d&lt;0.9408\)</span>时，我们可以通过构造如下格来将低密度多重子集和问题转换为SVP进行求解： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;&amp;&amp;&amp;0&amp;Na_{1,1}&amp;Na_{2,1}&amp;\cdots&amp;Na_{k,1}\\&amp;1&amp;&amp;&amp;0&amp;Na_{1,2}&amp;Na_{2,2}&amp;\cdots&amp;Na_{k,2}\\&amp;&amp;\ddots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1&amp;0&amp;Na_{1,n}&amp;Na_{2,n}&amp;\cdots&amp;Na_{k,n}\\\frac{1}{2}&amp;\frac{1}{2}&amp;\cdots&amp;\frac{1}{2}&amp;\frac{1}{2}&amp;Ns_1&amp;Ns_2&amp;\cdots&amp;Ns_k\end{matrix}\right)\]</span> 其中整数<span class="math inline">\(N&gt;\sqrt{\frac{n+1}{4}}\)</span>，此时在这个格内，线性组合<span class="math inline">\((e_1,e_2,\cdots,e_n,-1)\)</span>会生成一个短向量： <span class="math display">\[(e_1,e_2,\cdots,e_n,-1)\pmb{B}=(e_1-\frac{1}{2},e_2-\frac{1}{2},\cdots,e_n-\frac{1}{2},-\frac{1}{2},0,\cdots,0)\]</span> 通过LLL算法我们就可以得到这个短向量.</p><h4 id="低密度模子集和问题与低密度多重模子集和问题">低密度模子集和问题与低密度多重模子集和问题</h4><p>通过对子集和问题的扩充，我们可以得到模子集和问题：给定<span class="math inline">\(n\)</span>个模<span class="math inline">\(M\)</span>下的正整数<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，再给出一个整数<span class="math inline">\(s\)</span>，找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>，使得： <span class="math display">\[s\equiv\sum_{i=1}^{n}e_ia_i\pmod{M}\]</span> 从而可以推广为多重模子集和问题：给定<span class="math inline">\(kn\)</span>个模<span class="math inline">\(M\)</span>下的正整数<span class="math inline">\(a_{1,1},a_{1,2}\cdots,a_{k,n}\)</span>以及<span class="math inline">\(k\)</span>个整数<span class="math inline">\(s_1,\cdots,s_k\)</span>，找到<span class="math inline">\(e_1,e_2,\cdots,e_n\in\{0,1\}\)</span>满足对任意<span class="math inline">\(j\in{1,2,\cdots,k}\)</span>： <span class="math display">\[s_j\equiv\sum_{i=1}^{n}e_ia_{j,i}\pmod{M}\]</span> 实际上，模子集和问题问题可以视作<span class="math inline">\(k=1\)</span>的多重模子集和问题，我们可以通过下式对多重模子集和问题的密度<span class="math inline">\(d\)</span>进行计算： <span class="math display">\[d=\frac{n}{k\log_2M}\]</span> 根据潘彦斌等人研究可以得出，当<span class="math inline">\(d&lt;0.9408\)</span>且<span class="math inline">\(k=\omicron\left(\frac{n}{\log_2((n+1)\sqrt{n}+1)}\right)\)</span>时，我们可以通过构造如下格来将低密度多重模子集和问题转换为SVP进行求解： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;&amp;&amp;&amp;0&amp;Na_{1,1}&amp;Na_{2,1}&amp;\cdots&amp;Na_{k,1}\\&amp;1&amp;&amp;&amp;0&amp;Na_{1,2}&amp;Na_{2,2}&amp;\cdots&amp;Na_{k,2}\\&amp;&amp;\ddots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1&amp;0&amp;Na_{1,n}&amp;Na_{2,n}&amp;\cdots&amp;Na_{k,n}\\&amp;&amp;&amp;&amp;&amp;NM&amp;&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;NM&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;NM\\\frac{1}{2}&amp;\frac{1}{2}&amp;\cdots&amp;\frac{1}{2}&amp;\frac{1}{2}&amp;Ns_1&amp;Ns_2&amp;\cdots&amp;Ns_k\end{matrix}\right)\]</span> 使用LLL算法进行规约就可以得到目标短向量<span class="math inline">\((e_1-\frac{1}{2},e_2-\frac{1}{2},\cdots,e_n-\frac{1}{2},-\frac{1}{2},0,\cdots,0)\)</span>.</p><h3 id="隐藏数问题hidden-number-problemhnp">隐藏数问题（Hidden Number Problem，HNP）</h3><p>隐藏数问题的形式一般为给定一个质数<span class="math inline">\(p\)</span>，令<span class="math inline">\(\alpha\in[1,p-1]\)</span>作为“被隐藏的数字”，给定<span class="math inline">\(m\)</span>个数对<span class="math inline">\(\{(t_i,a_i)\}^{m}_{i=1}\)</span>使得： <span class="math display">\[\beta_i-t_i\alpha+a_i\equiv0\pmod{p}\]</span> 其中<span class="math inline">\(|\beta_i|&lt;K&lt;p\)</span>，我们需要从中恢复出<span class="math inline">\(\alpha\)</span>. 为解决这类问题，我们可以重写<span class="math inline">\(\beta_i-t_i\alpha+a_i\equiv0\pmod{p}\)</span>为<span class="math inline">\(\beta_i+a_i=t_i\alpha+k_ip\)</span>，这样我们就可以构造出下面的格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}p&amp;&amp;&amp;&amp;\\&amp;p&amp;&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;p&amp;\\t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{1}{p}\end{matrix}\right)\]</span> 对于向量<span class="math inline">\(\pmb{v}=(k_1,\cdots,k_m,\alpha)\)</span>有<span class="math inline">\(\pmb{v}\pmb{B}=(\beta_1+a_1,\cdots,\beta_m+a_m,\alpha/p)\)</span>，显然这个向量并不是很短，但是我们注意到： <span class="math display">\[\pmb{v}\pmb{B}=(a_1,\cdots,a_m,0)+(\beta_1,\cdots,\beta_m,\alpha/p)\]</span> 那么令<span class="math inline">\(\pmb{t}=(a_1,\cdots,a_m,0),\pmb{u}=(\beta_1,\cdots,\beta_m,\alpha/p)\)</span>，我们就可以得到： <span class="math display">\[\pmb{v}\pmb{B}-\pmb{t}=\pmb{u}\]</span> 其中<span class="math inline">\(||\pmb{u}||&lt;\sqrt{m+1}K\)</span>，显然我们可以通过将求解HNP转换为求解CVP，通过Kannan嵌入法，令嵌入因子为<span class="math inline">\(K\)</span>，我们就可以得到下面的格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}p&amp;&amp;&amp;&amp;&amp;\\&amp;p&amp;&amp;&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;&amp;\\&amp;&amp;&amp;p&amp;&amp;\\t_1&amp;t_2&amp;\cdots&amp;t_m&amp;\frac{K}{p}&amp;\\a_1&amp;a_2&amp;\cdots&amp;a_m&amp;&amp;K\end{matrix}\right)\]</span> 其包含向量<span class="math inline">\(\pmb{u}&#39;=(\beta_1,\cdots,\beta_m,K\alpha/p,-K)\)</span>，且<span class="math inline">\(||\pmb{u}&#39;||&lt;\sqrt{m+2}K\)</span>，<span class="math inline">\(\det(\pmb{B}&#39;)=p^{m-1}K^2\)</span>，显然有： <span class="math display">\[||\pmb{u}&#39;||&lt;\sqrt{m+2}K&lt;\left(\frac{2}{\sqrt{4\delta-1}}\right)^{m+1}\sqrt{m+2}|\det(\pmb{B}&#39;)|^{1/(m+2)}\]</span> 所以我们可以通过LLL来找到短向量<span class="math inline">\(\pmb{u}&#39;\)</span>，但是这个向量并不是最短的，因为格上存在另一个向量<span class="math inline">\((0,\cdots,0,K,0)\)</span>，它比<span class="math inline">\(\pmb{u}&#39;\)</span>更短，所以<span class="math inline">\(\pmb{u}&#39;\)</span>一般在规约后的第二个向量.</p><h4 id="扩展隐藏数问题extended-hidden-number-problemehnp">扩展隐藏数问题（Extended Hidden Number Problem，EHNP）</h4><p>通过对一般的隐藏数问题的扩展我们可以得到扩展隐藏数问题：给定素数<span class="math inline">\(p\)</span>，对整数<span class="math inline">\(x\in[1,p-1]\)</span>，有： <span class="math display">\[x=\overline{x}+\sum_{j=1}^{m}2^{\pi_{j}}x_j\]</span> 其中<span class="math inline">\(\overline{x}\)</span>以及<span class="math inline">\(\pi_j\)</span>均已知，而未知整数<span class="math inline">\(x_j\)</span>对于一个已知的整数<span class="math inline">\(\nu_j\)</span>满足<span class="math inline">\(0\le x_{j}&lt;2^{\nu_j}\)</span>，给出<span class="math inline">\(d\)</span>条方程： <span class="math display">\[\alpha_i\sum_{j=1}^{m}2^{\pi_j}x_j+\sum_{j=1}^{l_i}{\rho_{i,j}k_{i,j}}\equiv\beta_{i}-\alpha_i\overline{x}\pmod{p}\]</span> 其中对于<span class="math inline">\(1\le i\le d\)</span>，<span class="math inline">\(\alpha_i\not\equiv 0\pmod{p}\)</span>，<span class="math inline">\(\rho_{i,j}\)</span>以及<span class="math inline">\(\beta_i\)</span>均为已知的整数，未知正整数<span class="math inline">\(k_{i,j}\)</span>的上界为<span class="math inline">\(2^{\mu_{i,j}}\)</span>且<span class="math inline">\(\mu_{i,j}\)</span>已知，则扩展隐藏数问题（EHNP）则是通过上述条件恢复<span class="math inline">\(x\)</span>. 为解决EHNP，我们可以构造格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}p\pmb{I}_d&amp;&amp;\\\pmb{A}&amp;\pmb{X}&amp;\\\pmb{R}&amp;&amp;\pmb{K}\end{matrix}\right)\]</span> 其中： <span class="math display">\[\begin{aligned}&amp;\pmb{A}=\left(\begin{matrix}\alpha_{1}2^{\pi_1}&amp;\alpha_{2}2^{\pi_1}&amp;\cdots&amp;\alpha_{d}2^{\pi_1}\\\alpha_{1}2^{\pi_2}&amp;\alpha_{2}2^{\pi_2}&amp;\cdots&amp;\alpha_{d}2^{\pi_2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\\alpha_{1}2^{\pi_m}&amp;\alpha_{2}2^{\pi_m}&amp;\cdots&amp;\alpha_{d}2^{\pi_m}\\\end{matrix}\right)\\&amp;\pmb{X}=diag\left(\frac{\delta}{2^{\nu_{1}}},\frac{\delta}{2^{\nu_{2}}},\cdots,\frac{\delta}{2^{\nu_{m}}}\right)\\&amp;\pmb{R}=\left(\begin{matrix}\rho_{1,1}&amp;&amp;\\\rho_{1,2}&amp;&amp;\\\vdots\\\rho_{1,l_1}&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;\rho_{d,1}\\&amp;&amp;\rho_{d,2}\\&amp;&amp;\vdots\\&amp;&amp;\rho_{d,l_{d}}\end{matrix}\right)\\&amp;\pmb{K}=diag\left(\frac{\delta}{2^{\mu_{1,1}}},\cdots,\frac{\delta}{2^{\mu_{1,l_{1}}}},\cdots,\frac{\delta}{2^{\mu_{d,1}}},\cdots,\frac{\delta}{2^{\mu_{d,l_d}}}\right)\end{aligned}\]</span> 设<span class="math inline">\(L=l_1+l_2+\cdots+l_d\)</span>，<span class="math inline">\(D=d+m+L\)</span>，计算： <span class="math display">\[\kappa_{D}=\frac{2^{D/4}(m+L)^{1/2}+1}{2}\]</span> 通过<span class="math inline">\(\kappa_{D}\)</span>，我们可以得到<span class="math inline">\(\delta\)</span>满足<span class="math inline">\(0&lt;\delta\kappa_{D}&lt;1\)</span>。令 <span class="math display">\[\pmb{v}=(\beta_{1}-\alpha_{i}\overline{x},\cdots,\beta_{d}-\alpha_{d}\overline{x},\frac{\delta}{2},\cdots,\frac{\delta}{2})\]</span> 我们需要根据上述的<span class="math inline">\(\delta\)</span>构造格<span class="math inline">\(\mathcal{L}=\mathcal{L}(\pmb{B},\delta)\)</span>，在格<span class="math inline">\(\mathcal{L}\)</span>中找到向量<span class="math inline">\(\pmb{u}\)</span>使得： <span class="math display">\[||\pmb{u}-\pmb{v}||\le 2^{\frac{D}{4}}\min_{\pmb{t}\in\mathcal{L}}||\pmb{v}-\pmb{t}||\]</span> 通过LLL算法对我们构造的格进行规约可以得到： <span class="math display">\[\pmb{u}=\left(\beta_{1}-\alpha_{i}\overline{x},\cdots,\beta_{d}-\alpha_{d}\overline{x},\frac{x_1\delta}{2^{\nu_1}},\cdots,\frac{x_m\delta}{2^{\nu_m}},\frac{k_{1,1}\delta}{2^{\mu_{1,1}}},\cdots,\frac{k_{1,l_1}\delta}{2^{\mu_{1,l_{1}}}},\cdots,\frac{k_{d,1}\delta}{2^{\mu_{d,1}}},\cdots,\frac{k_{d,l_d}\delta}{2^{\mu_{d,l_d}}}\right)\]</span> 然后令<span class="math inline">\(x_{j}&#39;=\frac{1}{\delta}(\pmb{u}_{d+j}2^{\nu_{j}})\)</span>（<span class="math inline">\(1\le j\le m\)</span>），最后计算： <span class="math display">\[x&#39;=\overline{x}+\sum_{j=1}^{m}2^{\pi_j}x&#39;_{j}\mod{p}\]</span> 这样得到的<span class="math inline">\(x&#39;\)</span>就是我们需要的<span class="math inline">\(x\)</span>. 在论文<a href="https://link.springer.com/chapter/10.1007/978-3-540-74462-7_9">Extended Hidden Number Problem and Its Cryptanalytic Applications</a>中还提及了一种通过狄利克雷近似计算双洞隐藏数问题（Hidden Number Problem with Two Holes， HNP-2H），具体方法与步骤在<a href="https://triodelzx.github.io/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/">通过狄利克雷近似解决HNP-2H | Triode Field</a>有写.</p><h3 id="coppersmith方法">Coppersmith方法</h3><h4 id="howgrave-graham定理">Howgrave-Graham定理</h4><p>设<span class="math inline">\(h(x_1,\cdots,x_n)\in\mathbb{Z}[x_1,\cdots,x_n]\)</span>是一个由<span class="math inline">\(\omega\)</span>个单项式组成的多项式，如果：</p><ol type="1"><li>存在<span class="math inline">\(|r_1|&lt;X_1,\cdots,|r_n|&lt;X_n\)</span>，有<span class="math inline">\(f(r_1,\cdots,r_n)\equiv0\pmod{N}\)</span></li><li><span class="math inline">\(||h(x_1X_1,\cdots,x_nX_n)||&lt;\frac{N}{\sqrt{\omega}}\)</span></li></ol><p>那么<span class="math inline">\(f(r_1,\cdots,r_n)=0\)</span>在整数域同样成立.</p><p>这个定理是Coppersmith方法的关键所在。</p><h4 id="一元coppersmith">一元Coppersmith</h4><p>对于度为<span class="math inline">\(k\)</span>的一元本原多项式<span class="math inline">\(p(x)=x^{k}+a_{k-1}x^{k-1}+\cdots+a_{1}x+a_{0}\in\mathbb{Z}[x]\)</span>，Coppersmith方法可以找到方程<span class="math inline">\(p(x)\equiv0\pmod{N}\)</span>（其中<span class="math inline">\(N\)</span>是一个合数）的一个小根<span class="math inline">\(x\equiv x_0\pmod{N}\)</span>（<span class="math inline">\(|x_{0}|&lt;X\)</span>，其中<span class="math inline">\(X\)</span>是一个自然数，且<span class="math inline">\(X\le N^{1/k}\)</span>） 这个算法的主要思想就是构造一个多项式<span class="math inline">\(h(x)\)</span>使得<span class="math inline">\(h(x_0)=0\)</span>，而求解<span class="math inline">\(h(x)=0\)</span>这个方程是很简单的，所以我们可以将求解<span class="math inline">\(p(x)\equiv0\pmod{N}\)</span>这一任务转化为求解<span class="math inline">\(h(x)=0\)</span>。我们可以构造格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}N&amp;&amp;&amp;&amp;&amp;\\&amp;XN&amp;&amp;&amp;&amp;\\&amp;&amp;X^2N&amp;&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;&amp;X^{k-1}N&amp;\\a_0&amp;a_1X&amp;a_2X^2&amp;\cdots&amp;a_{d-1}X^{d-1}&amp;X^{d}\end{matrix}\right)\]</span> 然后通过LLL规约得到一个矩阵： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}b_0&amp;b_1&amp;\cdots&amp;b_{d-1}&amp;b_{d}\\*&amp;*&amp;\cdots&amp;*&amp;*\\\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\*&amp;*&amp;\cdots&amp;*&amp;*\end{matrix}\right)\]</span> 则有： <span class="math display">\[h(Xx)=b_dx^{d}+b_{d-1}x^{d-1}+\cdots+b_{1}x+b_0\]</span> 可以得到： <span class="math display">\[h(x)=\left(\frac{b_d}{X^d}\right)x^{d}+\left(\frac{b_{d-1}}{X^{d-1}}\right)x^{d-1}+\cdots+\left(\frac{b_1}{X}\right)x+b_0\]</span> 解该方程得到的整数解就有可能是我们要的<span class="math inline">\(x_0\)</span>。 在实际应用中，我们可以直接利用sage的<code>small_roots</code>来进行求解。</p><h4 id="多元coppersmith">多元Coppersmith</h4><blockquote><p>那堆东西暂时没看懂，先贴个从某些地方搜刮来的板子</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line">    B, monomials = G.coefficients_monomials()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="一般维纳攻击的格方法">一般维纳攻击的格方法</h3><p><strong>维纳方法</strong>：对于<span class="math inline">\(N=pq\)</span>，假设<span class="math inline">\(\lambda({N})\)</span>与<span class="math inline">\(e\)</span>均与<span class="math inline">\(N\)</span>接近，而且解密指数<span class="math inline">\(d&lt;N^{1/4}\)</span>，那么因为<span class="math inline">\(e\)</span>与<span class="math inline">\(d\)</span>满足<span class="math inline">\(ed-k\lambda(N)=1\)</span>，所以令<span class="math inline">\(\lambda(N)=(p-1)(q-1)/g\)</span>，又令<span class="math inline">\(s=1-p-q\)</span>，就可以得到： <span class="math display">\[edg-kN=g+ks\]</span> 那么有： <span class="math display">\[\frac{e}{N}-\frac{k}{dg}=\frac{ks}{dgN}+\frac{1}{dN}\]</span> 由于<span class="math inline">\(e\approx N\)</span>，<span class="math inline">\(|s|\approx N^{1/2}\)</span>，那么可以得到<span class="math inline">\(\frac{k}{dg}\approx1\)</span>，所以上述方程的值约等于<span class="math inline">\(N^{-1/2}\)</span>，由勒让德定理，如果<span class="math inline">\(N^{-1/2}&lt;1/[2(dg)^2]\)</span>，那么<span class="math inline">\(\frac{k}{dg}\)</span>会是<span class="math inline">\(e/N\)</span>的渐进分数，所以我们可以通过连分数来得到<span class="math inline">\(d\)</span>，或者分解出<span class="math inline">\(p,q\)</span>，上述讨论中一般情况下<span class="math inline">\(g=1\)</span>。 令<span class="math inline">\(g=1\)</span>，实际上此时<span class="math inline">\(\lambda(N)=\varphi(N)\)</span>，我们注意到，在上述条件下得到的<span class="math inline">\(ed-kN=1+ks\)</span>一式存在线性关系，所以可以考虑使用格来求解，考虑构造如下格： <span class="math display">\[\pmb{B}=\left(\begin{matrix}1&amp;e\\0&amp;-N\end{matrix}\right)\]</span> 其中目标向量为<span class="math inline">\(\pmb{v}=(d,1+ks)\)</span>，其中<span class="math inline">\(s=1-p-q\)</span>，可以知道<span class="math inline">\(|s|\approx N^{1/2}\)</span>，<span class="math inline">\(d&lt;N^{1/4}\)</span>，则有<span class="math inline">\(|\det(\pmb{B})|=N\)</span>，可以知道 <span class="math display">\[||\pmb{v}||=\sqrt{d^2+(1+ks)^2}&gt;\sqrt{2}N^{1/2}&gt;\sqrt{2}|\det(\pmb{B})|^{1/2}\]</span> 显然，通过闵可夫斯基第一定理，我们几乎不可能通过规约得到我们的目标向量，那么我们要进行格基配平，根据分析，我们构造如下格： <span class="math display">\[\pmb{B}&#39;=\left(\begin{matrix}2^{\alpha}&amp;e\\0&amp;-N\end{matrix}\right)\]</span> （其中<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(N\)</span>的比特数的<span class="math inline">\(1/2\)</span>），这样就可以通过LLL算法规约得到目标向量<span class="math inline">\((2^{\alpha}d,1+ks)\)</span>.</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源（2）——SIDH通解</title>
      <link href="/2025/03/03/%E5%90%8C%E6%BA%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94SIDH%E9%80%9A%E8%A7%A3/"/>
      <url>/2025/03/03/%E5%90%8C%E6%BA%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94SIDH%E9%80%9A%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://eprint.iacr.org/2022/975">An efficient key recovery attack on SIDH</a></p></blockquote><p>前文再续，书接<a href="https://triodelzx.github.io/2025/02/26/同源（1）——SIDH/">上一回</a>，上回讲到，SIDH喺2022年就被宣布畀人完全破解咗……</p><h2 id="前言">前言</h2><p>本来没想过写这一篇的，因为‘本来想着既然都有现成代码了，那用起来应该会很方便吧，但是在NSS上刷题的时候做到CryptoCTF 2023的一道题：<a href="https://www.nssctf.cn/problem/4387">[CryptoCTF 2023]Shevid | NSSCTF</a>，其实就是SIDH中已知Alice私钥以及双方公钥来恢复Bob私钥，但是在用<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>给出的代码时四处碰壁，所以想着写这篇博客记录一下如何使用这些代码。</p><h2 id="对sidh的破解">对SIDH的破解</h2><p><del>有现成代码，原理似乎也不是很重要</del> 大致扫了一眼论文和GitHub项目上的样例代码（<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath/blob/main/baby_SIDH.sage">baby_SIDH.sage</a>），发现我们要做的似乎其实仅仅是需要构造一个曲线上的自同态<span class="math inline">\([2i]\)</span>，使得<span class="math inline">\([2i]\circ[2i]=[-4]\)</span>（实际上就是<span class="math inline">\(2i\)</span>倍点映射吧，但是sage并不能直接给<span class="math inline">\(GF(p^2)\)</span>上的点乘上<span class="math inline">\(2i\)</span>），所以这个过程其实要我们自己写，但是在Github的项目里面其实是有给由方程<span class="math inline">\(y^2=x^3+6x^2+x\)</span>所定义的椭圆曲线上的<span class="math inline">\(2i\)</span>倍点映射的算法，而通过阅读论文，我们也可以写出由方程<span class="math inline">\(y^2=x^3+x\)</span>所定义的椭圆曲线上的<span class="math inline">\(2i\)</span>倍点映射：<span class="math inline">\([2i]:(x,y)\mapsto[2](-x,iy)\)</span>（其中<span class="math inline">\([2]\)</span>为二倍点映射），在论文里面也只讨论了这两种方程定义的曲线。</p><h3 id="代码使用实例">代码使用实例</h3><p>在这里通过两个例子来公式化地使用Github项目中给出的代码解决分别由<span class="math inline">\(y^2=x^3+6x^2+x\)</span>与<span class="math inline">\(y^2=x^3+x\)</span>定义的曲线上的SIDH：</p><h4 id="cryptoctf-2023shevid">[CryptoCTF 2023]Shevid</h4><p>题目给出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_param</span>(<span class="params">B</span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">       a = randint(B &gt;&gt; <span class="number">1</span>, B)  </span><br><span class="line">       b = randint(B &gt;&gt; <span class="number">2</span>, B &gt;&gt; <span class="number">1</span>)  </span><br><span class="line">       p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">       <span class="keyword">if</span> is_prime(p):  </span><br><span class="line">          <span class="keyword">return</span> a, b  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_dmap</span>(<span class="params">E</span>):  </span><br><span class="line">    <span class="keyword">return</span> E.isogeny(E.lift_x(ZZ(<span class="number">1</span>)), codomain = E)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_tpt</span>(<span class="params">E, a, b</span>):  </span><br><span class="line">    P, Q = [((p + <span class="number">1</span>) // <span class="number">2</span>**a) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    R, S = [((p + <span class="number">1</span>) // <span class="number">3</span>**b) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    <span class="keyword">return</span> P, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">EC, b, P, Q, R, S</span>):  </span><br><span class="line">    skey = randint(<span class="number">1</span>, <span class="number">3</span>**b)  </span><br><span class="line">    T = R + skey * S  </span><br><span class="line">    phi = EC.isogeny(T, algorithm = <span class="string">&quot;factored&quot;</span>)  </span><br><span class="line">    _phi_dom, _phi_P, _phi_Q = phi.codomain(), phi(P), phi(Q)  </span><br><span class="line">    <span class="keyword">return</span> skey, _phi_dom, _phi_P, _phi_Q  </span><br><span class="line">  </span><br><span class="line">a, b = gen_param(<span class="number">190</span>)  </span><br><span class="line">p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">F.&lt;x&gt; = GF(p^<span class="number">2</span>, modulus = x**<span class="number">2</span> + <span class="number">1</span>)  </span><br><span class="line">EC = EllipticCurve(F, [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])  </span><br><span class="line">P, Q, R, S = gen_tpt(EC, a, b)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;P = <span class="subst">&#123;P.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Q = <span class="subst">&#123;Q.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;R = <span class="subst">&#123;R.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;S = <span class="subst">&#123;S.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">skey, _phi_dom, _phi_P, _phi_Q = keygen(EC, b, P, Q, R, S)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_dom = <span class="subst">&#123;_phi_dom&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_P   = <span class="subst">&#123;_phi_P.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;_phi_Q   = <span class="subst">&#123;_phi_Q.xy()&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">key = md5(long_to_bytes(skey)).digest()  </span><br><span class="line">iv = md5(<span class="built_in">str</span>(skey).encode()).digest()  </span><br><span class="line">  </span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv=iv)  </span><br><span class="line">enc = cipher.encrypt(flag)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;enc = <span class="subst">&#123;enc.<span class="built_in">hex</span>()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure> 其实就是要我们通过Alice的公开点<span class="math inline">\(P,Q\)</span>和Bob的公钥<span class="math inline">\((\phi(E),\phi(P),\phi(Q))\)</span>还原Bob的秘密值<span class="math inline">\(k_B\)</span>，这里定义的曲线是由<span class="math inline">\(y^2=x^3+6x^2+x\)</span>所定义的，所以我们可以用<code>public_values_aux.py</code>中的<code>generate_distortion_map</code>函数来计算该曲线上的<span class="math inline">\([2i]\)</span>，那么可以写出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> public_values_aux <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;castryck_decru_shortcut.sage&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Fd.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(Fd, [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E.set_order((p+<span class="number">1</span>)^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">142</span></span><br><span class="line">b = <span class="number">69</span></span><br><span class="line"></span><br><span class="line">a2 = <span class="number">6</span></span><br><span class="line">a4 = <span class="number">2070374075904221348548347954672740119972290047985052548426161483408084160515</span>*i+<span class="number">896749506444795652787374405713981306103783874504413776724865996633074195878</span></span><br><span class="line">a6 = <span class="number">2497300913991521538985990865799426081199023429830552981773916386651958830387</span>*i+<span class="number">4243320791854592301388975795466391442631117041175807728844738724691845270777</span></span><br><span class="line"></span><br><span class="line">_phi_dom = EllipticCurve(Fd, [<span class="number">0</span>, a2, <span class="number">0</span>, a4, a6])</span><br><span class="line"></span><br><span class="line">_phi_P = _phi_dom(...)</span><br><span class="line">_phi_Q = _phi_dom(...)</span><br><span class="line"></span><br><span class="line">P2 = E(...)</span><br><span class="line">Q2 = E(...)</span><br><span class="line">P3 = E(...)</span><br><span class="line">Q3 = E(...)</span><br><span class="line">two_i = generate_distortion_map(E)</span><br><span class="line">check_torsion_points(E, a, b, P2, Q2, P3, Q3)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line">recovered_key = CastryckDecruAttack(E, P2, Q2, _phi_dom, _phi_P, _phi_Q, two_i, num_cores=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">key = md5(long_to_bytes(<span class="built_in">int</span>(recovered_key))).digest()</span><br><span class="line">iv = md5(<span class="built_in">str</span>(recovered_key).encode()).digest()</span><br><span class="line"></span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv=iv)</span><br><span class="line">flag = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(enc))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 注意，这里的<code>P2,Q2,P3,Q3</code>分别对应的是题目代码中的<code>P,Q,R,S</code>，我们可以修改函数<code>CastryckDecruAttack</code>中的<code>num_cores</code>参数可以改变并行进程数，从而提高运行效率，开4个线程运行结果如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503032230423.png" alt="Pasted image 20250303200634" /></p><h4 id="一道自制题">一道自制题</h4><p>找不到<span class="math inline">\(y^2=x^3+x\)</span>的题目，自己出一道举个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;Test_Flag_for_Isogeny_with_y^2=x^3+x&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_param</span>(<span class="params">B</span>):  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">       a = randint(B &gt;&gt; <span class="number">1</span>, B)  </span><br><span class="line">       b = randint(B &gt;&gt; <span class="number">2</span>, B &gt;&gt; <span class="number">1</span>)  </span><br><span class="line">       p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span>  </span><br><span class="line">       <span class="keyword">if</span> is_prime(p):  </span><br><span class="line">          <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_tpt</span>(<span class="params">E, a, b</span>):  </span><br><span class="line">    P, Q = [((p + <span class="number">1</span>) // <span class="number">2</span>**a) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    R, S = [((p + <span class="number">1</span>) // <span class="number">3</span>**b) * _ <span class="keyword">for</span> _ <span class="keyword">in</span> E.gens()]  </span><br><span class="line">    <span class="keyword">return</span> P, Q, R, S  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">shared_key, plaintext</span>):</span><br><span class="line">    key = sha256(<span class="built_in">str</span>(shared_key).encode()).digest()[:<span class="number">16</span>]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(pad(plaintext, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">a, b = gen_param(<span class="number">64</span>)</span><br><span class="line">p = <span class="number">2</span>**a * <span class="number">3</span>**b - <span class="number">1</span></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">E = EllipticCurve(F, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">P1, Q1, P2, Q2 = gen_tpt(E, a, b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P1 = E<span class="subst">&#123;P1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q1 = E<span class="subst">&#123;Q1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P2 = E<span class="subst">&#123;P2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q2 = E<span class="subst">&#123;Q2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alice</span></span><br><span class="line">ka = randint(<span class="number">1</span>, <span class="number">2</span>**a)</span><br><span class="line">RA = P1 + ka * Q1</span><br><span class="line">phiA = E.isogeny(RA, algorithm=<span class="string">&#x27;factored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">phiA_P2 = phiA(P2)</span><br><span class="line">phiA_Q2 = phiA(Q2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;EA = <span class="subst">&#123;phiA.codomain()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiA_P2 = EA<span class="subst">&#123;phiA_P2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiA_Q2 = EA<span class="subst">&#123;phiA_Q2.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bob</span></span><br><span class="line">kb = randint(<span class="number">1</span>, <span class="number">3</span>**b)</span><br><span class="line">RB = P2 + kb * Q2</span><br><span class="line">phiB = E.isogeny(RB, algorithm=<span class="string">&#x27;factored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">phiB_P1 = phiB(P1)</span><br><span class="line">phiB_Q1 = phiB(Q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;EB = <span class="subst">&#123;phiB.codomain()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiB_P1 = EB<span class="subst">&#123;phiB_P1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;phiB_Q1 = EB<span class="subst">&#123;phiB_Q1.xy()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">RA1 = phiB_P1 + ka * phiB_Q1</span><br><span class="line">shared1 = EB.isogeny(RA1, algorithm=<span class="string">&#x27;factored&#x27;</span>).codomain().j_invariant()</span><br><span class="line"></span><br><span class="line">RB1 = phiA_P2 + kb * phiA_Q2</span><br><span class="line">shared2 = EA.isogeny(RB1, algorithm=<span class="string">&#x27;factored&#x27;</span>).codomain().j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> shared1 == shared2</span><br><span class="line">shared_key = shared1</span><br><span class="line"></span><br><span class="line">enc = encrypt(shared_key, flag)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;enc = <span class="subst">&#123;enc.<span class="built_in">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p = 69007679864054552199167 </span></span><br><span class="line"><span class="string">a = 41 </span></span><br><span class="line"><span class="string">b = 22 </span></span><br><span class="line"><span class="string">P1 = E(42941883561232695204126*i + 41565179451593292417697, 32012113025288545049970*i + 67447792731782782239107) </span></span><br><span class="line"><span class="string">Q1 = E(25302850366663243334175*i + 28499745867760697777766, 45519069949265761361669*i + 38091523002955621484376) </span></span><br><span class="line"><span class="string">P2 = E(64295307603787694858622*i + 23124820300292317471971, 56390657452217097859549*i + 36392449137376185120691) </span></span><br><span class="line"><span class="string">Q2 = E(5592769293100950710186*i + 10812888045531269729601, 6826865383103204422537*i + 20863179574507545233583) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EA = Elliptic Curve defined by y^2 = x^3 + (55136237696257287853765*i+57833844773073644952221)*x + (52942153600632609877190*i+15361822390228021806871) over Finite Field in i of size 69007679864054552199167^2 </span></span><br><span class="line"><span class="string">phiA_P2 = EA(62489625132170888252802*i + 63808521833396900819332, 49433807014900669675197*i + 38317557157701506341329) </span></span><br><span class="line"><span class="string">phiA_Q2 = EA(3850966740889085851852*i + 45392830987593111886391, 14326935923982120143676*i + 32443933495898500654626) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EB = Elliptic Curve defined by y^2 = x^3 + (535570609910458761019*i+55847628242608619214131)*x + (52895838204408953951990*i+40402487899485896459107) over Finite Field in i of size 69007679864054552199167^2 </span></span><br><span class="line"><span class="string">phiB_P1 = EB(67880173178064709758833*i + 5128007695857513878729, 67090026125242047708224*i + 36228875668588115708933) </span></span><br><span class="line"><span class="string">phiB_Q1 = EB(42637972539717898085377*i + 30589197453944790040489, 62900893992599911017947*i + 53504295506770245599626) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">enc = c63958e914ecac186888aa578719cc8e21bd3f1df3eba0a36dee5a425e487db180f52502552e19495ca7fdf0071fe8cb</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure> 可以通过如下代码来获得flag： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> public_values_aux <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;castryck_decru_shortcut.sage&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two_i</span>(<span class="params">P</span>):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    <span class="keyword">if</span> P == E(<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> E(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y = P.xy()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*E(-x, i*y)</span><br><span class="line"></span><br><span class="line">p = <span class="number">69007679864054552199167</span></span><br><span class="line">a = <span class="number">41</span></span><br><span class="line">b = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(F, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">P2 = E(<span class="number">42941883561232695204126</span>*i + <span class="number">41565179451593292417697</span>, <span class="number">32012113025288545049970</span>*i + <span class="number">67447792731782782239107</span>)</span><br><span class="line">Q2 = E(<span class="number">25302850366663243334175</span>*i + <span class="number">28499745867760697777766</span>, <span class="number">45519069949265761361669</span>*i + <span class="number">38091523002955621484376</span>)</span><br><span class="line">P3 = E(<span class="number">64295307603787694858622</span>*i + <span class="number">23124820300292317471971</span>, <span class="number">56390657452217097859549</span>*i + <span class="number">36392449137376185120691</span>)</span><br><span class="line">Q3 = E(<span class="number">5592769293100950710186</span>*i + <span class="number">10812888045531269729601</span>, <span class="number">6826865383103204422537</span>*i + <span class="number">20863179574507545233583</span>)</span><br><span class="line">check_torsion_points(E, a, b, P2, Q2, P3, Q3)</span><br><span class="line"></span><br><span class="line">EA = EllipticCurve(F, [<span class="number">55136237696257287853765</span>*i+<span class="number">57833844773073644952221</span>, <span class="number">52942153600632609877190</span>*i+<span class="number">15361822390228021806871</span>])</span><br><span class="line">phiA_P3 = EA(<span class="number">62489625132170888252802</span>*i + <span class="number">63808521833396900819332</span>, <span class="number">49433807014900669675197</span>*i + <span class="number">38317557157701506341329</span>)</span><br><span class="line">phiA_Q3 = EA(<span class="number">3850966740889085851852</span>*i + <span class="number">45392830987593111886391</span>, <span class="number">14326935923982120143676</span>*i + <span class="number">32443933495898500654626</span>)</span><br><span class="line"></span><br><span class="line">EB = EllipticCurve(F, [<span class="number">535570609910458761019</span>*i+<span class="number">55847628242608619214131</span>, <span class="number">52895838204408953951990</span>*i+<span class="number">40402487899485896459107</span>])</span><br><span class="line">phiB_P2 = EB(<span class="number">67880173178064709758833</span>*i + <span class="number">5128007695857513878729</span>, <span class="number">67090026125242047708224</span>*i + <span class="number">36228875668588115708933</span>)</span><br><span class="line">phiB_Q2 = EB(<span class="number">42637972539717898085377</span>*i + <span class="number">30589197453944790040489</span>, <span class="number">62900893992599911017947</span>*i + <span class="number">53504295506770245599626</span>)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;c63958e914ecac186888aa578719cc8e21bd3f1df3eba0a36dee5a425e487db180f52502552e19495ca7fdf0071fe8cb&quot;</span></span><br><span class="line"></span><br><span class="line">kb = CastryckDecruAttack(E, P2, Q2, EB, phiB_P2, phiB_Q2, two_i, num_cores=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">R = phiA_P3 + kb * phiA_Q3</span><br><span class="line">R._order = <span class="number">3</span>^b</span><br><span class="line">phi = EA.isogeny(R, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">shared_key = phi.codomain().j_invariant()</span><br><span class="line"></span><br><span class="line">key = sha256(<span class="built_in">str</span>(shared_key).encode()).digest()[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">flag = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(enc))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure> 注意，这里的<code>P2,Q2,P3,Q3</code>对应题目代码中的<code>P1,Q1,P2,Q2</code>，运行结果如下： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202503032231783.png" alt="Pasted image 20250303222653" /></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源（1）——SIDH</title>
      <link href="/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/"/>
      <url>/2025/02/26/%E5%90%8C%E6%BA%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94SIDH/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ol type="1"><li><p><a href="https://arxiv.org/pdf/1711.04062">Mathematics of Isogeny Based Cryptography</a></p></li><li><p><a href="https://eprint.iacr.org/2019/1321.pdf">Supersingular isogeny key exchange for beginners</a></p></li><li><p><a href="https://link.springer.com/book/10.1007/b97292">Elliptic Curves | SpringerLink</a></p></li><li><p><a href="https://tangcuxiaojikuai.xyz/post/e06139e7.html">Isogeny | 糖醋小鸡块的blog</a></p></li><li><p><a href="https://languag3.github.io/2025/02/04/isogeny/#sidh">isogeny | languag3</a></p></li><li><p><a href="https://huangx607087.online/2025/02/01/ECCNotes4/">ECCNotes4 - huangx607087's Blog</a></p></li></ol></blockquote><h2 id="前置知识">前置知识</h2><h3 id="超奇异supersingular椭圆曲线">超奇异（supersingular）椭圆曲线</h3><p>对于<span class="math inline">\(GF(p^r)\)</span>下的椭圆曲线<span class="math inline">\(E\)</span>，若<span class="math inline">\(|E|\equiv 1\pmod{p}\)</span>，则称该曲线为超奇异椭圆曲线</p><h3 id="j-不变量j-invariant"><span class="math inline">\(j\)</span>-不变量（<span class="math inline">\(j\)</span>-invariant）</h3><p>对于一条由方程<span class="math inline">\(y^2=x^3+ax+b\)</span>定义的椭圆曲线<span class="math inline">\(E\)</span>，其<span class="math inline">\(j\)</span>-不变量的定义为： <span class="math display">\[j(E)=1728\cdot\frac{4a^3}{4a^3+27b^2}\]</span> 当且仅当两条定义在代数闭包<span class="math inline">\(\overline{k}\)</span>上的曲线<span class="math inline">\(E\)</span>与<span class="math inline">\(E&#39;\)</span>的<span class="math inline">\(j\)</span>-不变量相同时这两条曲线同构，即存在点到点之间的双射<span class="math inline">\(\phi\)</span>使得： <span class="math display">\[\phi:E\mapsto E&#39;\]</span> 通过参考资料2我们可以知道对于SIDH，其主要作用于有限域<span class="math inline">\(GF(p)\)</span>的二次扩展（即<span class="math inline">\(GF(p^2)\)</span>，其中<span class="math inline">\(p\equiv 3\pmod{4}\)</span>），方便起见，我们通常将这个二次扩展域中的元素表示为<span class="math inline">\(u+vi\)</span>（其中<span class="math inline">\(u,v\in GF(p)\)</span>，<span class="math inline">\(i^2\equiv-1\pmod{p}\)</span>），定义在这个二次扩展域上的超奇异<span class="math inline">\(j\)</span>-不变量的个数为<span class="math inline">\(\lfloor p/12\rfloor+z\)</span>，这些超奇异<span class="math inline">\(j\)</span>-不变量每一个都对应一条同构意义下的超奇异曲线，其中<span class="math inline">\(z\in\{0,1,2\}\)</span>，<span class="math inline">\(z\)</span>的取值取决于<span class="math inline">\(p\mod 12\)</span>，具体如下（参考资料3，P264）： <span class="math display">\[z=\begin{cases}0&amp;,p\equiv1\pmod{12}\\1&amp;,p\equiv5\pmod{12}\\1&amp;,p\equiv7\pmod{12}\\2&amp;,p\equiv11\pmod{12}\\\end{cases}\]</span> 例如对于参考资料2中的例子（即<span class="math inline">\(p=431\)</span>），<span class="math inline">\(GF(p^2)\)</span>中的<span class="math inline">\(\lfloor p/12\rfloor+2=37\)</span>个<span class="math inline">\(j\)</span>-不变量分别对应一条同构意义下的超奇异曲线，这些<span class="math inline">\(j-\)</span>不变量如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006712.png" alt="image-20250226200636189" /> 关于<span class="math inline">\(j\)</span>-不变量与曲线间同构的关系，参考资料2给出了一个例子：对于<span class="math inline">\(GF(431^2)\)</span>下的两条曲线： <span class="math display">\[\begin{aligned}E_1:y^2=x^3+(208i+161)x^2+x\\E_2:y^2=x^3+(172i+162)x^2+x\\\end{aligned}\]</span> 可以计算出<span class="math inline">\(j(E_1)=j(E_2)=364i+304\)</span>，那么我们可以通过如下代码来求出<span class="math inline">\(E_1\)</span>到<span class="math inline">\(E_2\)</span>的同构映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line"></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E1 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">E2 = EllipticCurve(R, [<span class="number">0</span>, <span class="number">172</span>*i+<span class="number">162</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(E1.j_invariant())</span><br><span class="line"><span class="built_in">print</span>(E2.j_invariant())</span><br><span class="line"></span><br><span class="line">phi = E1.isomorphism_to(E2)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[\begin{aligned}\phi:&amp;E_1\mapsto E_2\\&amp;(x,y)\mapsto((66i + 182)x + (-131i + 109), (122i + 159)y)\end{aligned}\]</span></p><h3 id="蒙哥马利montgomery曲线">蒙哥马利（Montgomery）曲线</h3><p>在椭圆曲线密码学中常用的椭圆曲线为形如<span class="math inline">\(y^2=x^3+ax+b\)</span>方程所确定的曲线，这类方程一般称为魏尔斯特拉斯（Weierstrass）方程，这类方程确定的曲线一般称为魏尔斯特拉斯形式的椭圆曲线，还有另外一种形式的椭圆曲线是由方程<span class="math inline">\(y^2=x^3+Ax^2+x\)</span>所定义的，这类椭圆曲线被称为蒙哥马利曲线，对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+Ax^2+x\)</span>，其<span class="math inline">\(j\)</span>-不变量为： <span class="math display">\[j(E)=\frac{256(A^2-3)^3}{A^2-4}\]</span> 任意一条椭圆曲线都可以转换为<span class="math inline">\(j\)</span>-不变量相同（亦即同构）的蒙哥马利曲线，在sage中，我们可以通过<code>montgomery_model</code>来将一条椭圆曲线转换为蒙哥马利曲线，例如我们要将魏尔斯特拉斯形式的椭圆曲线： <span class="math display">\[E:y^2=x^3+312589632x+654443578\pmod{1912812599}\]</span> 转换为对应的蒙哥马利曲线，则可以通过如下代码进行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">1912812599</span></span><br><span class="line">a = <span class="number">312589632</span></span><br><span class="line">b = <span class="number">654443578</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line">E_M = <span class="built_in">print</span>(E.montgomery_model()</span><br></pre></td></tr></table></figure> 可以得到其对应的蒙哥马利曲线为： <span class="math display">\[E_M:y^2 = x^3 + 723347356x^2 + x\pmod{1912812599}\]</span></p><h3 id="同源">同源</h3><p>同源实际上就是一条曲线到另一条曲线或者一条曲线到自身的映射，其本质为同态，可以简单地表达为<span class="math inline">\((x,y)\mapsto(f(x,y),g(x,y))\)</span>，其中<span class="math inline">\(f,g\)</span>是两个函数。在之后的讨论中将主要以蒙哥马利曲线为主，因为蒙哥马利曲线之间的映射可以单纯通过对<span class="math inline">\(x\)</span>进行映射<span class="math inline">\(x\mapsto f(x)\)</span>来表示出曲线间完整的映射，其完整映射形式为： <span class="math display">\[(x,y)\mapsto(f(x),cyf&#39;(x))\]</span> 其中<span class="math inline">\(c\)</span>是固定常数，<span class="math inline">\(f&#39;\)</span>为<span class="math inline">\(f\)</span>的导函数. 对于一条蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，可以得到一个<span class="math inline">\(E\)</span>到<span class="math inline">\(E\)</span>的同构映射： <span class="math display">\[[2]:E\mapsto E, x\mapsto\frac{(x^2-1)^2}{4x(x^2+ax+1)}\]</span> 这个映射一般称为二倍点映射，事实上，我们令分母<span class="math inline">\(4x(x^2+ax+1)=0\)</span>，可以得到三个根<span class="math inline">\(0,\alpha,\frac{1}{\alpha}\)</span>（其中<span class="math inline">\(\alpha\)</span>满足<span class="math inline">\(\alpha^2+a\alpha+1\)</span>），我们就可以得到曲线上阶为<span class="math inline">\(2\)</span>的点：<span class="math inline">\((0,0),(\alpha,0),(\frac{1}{\alpha},0)\)</span>，这三个点的集合就是映射<span class="math inline">\([2]\)</span>的核，记为<span class="math inline">\(\ker([2])\)</span>，它是椭圆曲线群<span class="math inline">\(E\)</span>的一个子群，同构于<span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，这上面的点称为<span class="math inline">\(2\)</span>-torsion，事实上对于任意一条椭圆曲线都有其对应的<span class="math inline">\(\ker([2])\)</span> 例如对于<span class="math inline">\(GF(431^2)\)</span>下的椭圆曲线<span class="math inline">\(E:y^2=x^3+x\)</span>，可以通过如下代码得到对应的上述映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_numerator(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(E._multiple_x_denominator(<span class="number">2</span>))</span><br></pre></td></tr></table></figure> 可以得到： <span class="math display">\[[2]:E\mapsto E,x\mapsto\frac{x^4 + 429x^2 + 1}{4x^3 + 4x}\]</span> 我们令分母<span class="math inline">\(4x^3+4x=4(x^3+x)=0\)</span>，得到三个解<span class="math inline">\(0,i,-i\)</span>，据此我们就可以得到一个<span class="math inline">\(E\)</span>的一个子群<span class="math inline">\(\ker([2])=\{(0,0),(i,0),(-i,0),\mathcal{O}\}\)</span>，而且这三个点都可以确定一个二阶循环子群，我们可以通过sage的<code>division_points</code>方法对<span class="math inline">\(E\)</span>的零元开二次根来达到这一目的：<code>E(0).division_points(2)</code>，参考资料2中给出了这样一个图来描述<span class="math inline">\(\ker([2])\)</span>： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261959041.png" alt="image-20250226195932625" /> 在这里每个“花瓣”对应一个二阶循环子群。相应的，还有三倍点映射<span class="math inline">\([3]\)</span>，对于蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>，其对应三倍点映射为： <span class="math display">\[[3]:E\mapsto E:x\mapsto\frac{x(x^4-6x^2-4ax^3-3)^2}{(3x^4+4ax^3+6x^2-1)^2}\]</span> 通过令分母等于<span class="math inline">\(0\)</span>我们可以得到四个根<span class="math inline">\(\beta,\delta,\zeta,\theta\)</span>，通过这四个根我们可以得到八个阶为<span class="math inline">\(3\)</span>的点：<span class="math inline">\((\beta,\pm\gamma),(\delta,\pm\epsilon),(\zeta,\pm\eta),(\theta,\pm\iota)\)</span>，这八个点加上无穷远点可以构成子群<span class="math inline">\(\ker([3])\simeq\mathbb{Z}_3\times\mathbb{Z}_3\)</span>，也可以叫做<span class="math inline">\(3\)</span>-torsion，<span class="math inline">\(3\)</span>-torsion的结构如下图所示： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262000994.png" alt="image-20250226200054634" /></p><p>这里每个“花瓣”对应一个三阶循环子群。推广到一般情况，所有阶为<span class="math inline">\(l\)</span>的点（<span class="math inline">\(p\nmid l\)</span>）与<span class="math inline">\(\mathcal{O}\)</span>构成的子群就是<span class="math inline">\(\ker([l])\simeq \mathbb{Z}_l\times\mathbb{Z}_l\)</span>（或者称为<span class="math inline">\(l\)</span>-torsion)，而若<span class="math inline">\(l\)</span>为质数，则可以得到<span class="math inline">\(l+1\)</span>个<span class="math inline">\(l\)</span>阶循环子群</p><h4 id="可分同源">可分同源</h4><p>可分同源的定义为对于一条曲线<span class="math inline">\(E\)</span>上的椭圆曲线群以及它的一个子群<span class="math inline">\(G\)</span>，可以构造出唯一的同源<span class="math inline">\(\phi:E\mapsto E&#39;\)</span>，使得<span class="math inline">\(\ker(\phi)=G\)</span>，这样得到的曲线<span class="math inline">\(E&#39;\)</span>称为该同源的陪域（codomain），可以表示为<span class="math inline">\(E/G\)</span>。可分同源的另一种定义（Velu's formulas）是：输入一条椭圆曲线<span class="math inline">\(E\)</span>以及其子群<span class="math inline">\(G\)</span>的所有点，输出陪域<span class="math inline">\(E/G\)</span>以及对应的映射<span class="math inline">\(\phi\)</span>。</p><blockquote><p>由于<span class="math inline">\(\ker(\phi)=G\)</span>，所以对于任意点<span class="math inline">\(P\in G\)</span>，都有<span class="math inline">\(\phi(P)=\mathcal{O}\)</span></p></blockquote><p>以蒙哥马利曲线<span class="math inline">\(E:y^2=x^3+ax^2+x\)</span>为例，设其上一个二阶子群为<span class="math inline">\(G=\{\mathcal{O},(\alpha,0)\}\)</span>，我们可以以<span class="math inline">\(G,E\)</span>作为输入，得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{x(\alpha x-1)}{x-\alpha}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2=x^3+2(1-2\alpha^2)x^2+x\)</span>，这个映射被用于计算蒙哥马利曲线的2-同源（2-isogeny），对<span class="math inline">\(GF(431^2)\)</span>下的超奇异曲线<span class="math inline">\(E:y^2=x^3+(208i+161)x^2+x\)</span>，我们知道<span class="math inline">\(j(E)=364i+304\)</span>，则可以通过如下代码求得其一个<span class="math inline">\(2\)</span>-同源并确保其输出的陪域为蒙哥马利曲线： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">431</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, <span class="number">208</span>*i+<span class="number">161</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">ker2 = E(<span class="number">0</span>).division_points(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [(0 : 1 : 0), (0 : 0 : 1), (350*i + 68 : 0 : 1), (304*i + 202 : 0 : 1)]</span></span><br><span class="line"></span><br><span class="line">alpha = ker2[<span class="number">2</span>]</span><br><span class="line">phi = E.isogeny(alpha, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(phi.rational_maps())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">E_ = phi.codomain()</span><br><span class="line"><span class="built_in">print</span>(E_)</span><br><span class="line"><span class="built_in">print</span>(E_.j_invariant())</span><br></pre></td></tr></table></figure> 可以得到映射<span class="math inline">\(\phi\)</span>： <span class="math display">\[\phi:x\mapsto\frac{(-81i + 68)x^2 - x}{x + (81i - 68)}\]</span> 以及陪域<span class="math inline">\(E&#39;:y^2 = x^3 + (102i+423)x^2 + x\)</span>，其<span class="math inline">\(j\)</span>-不变量<span class="math inline">\(j(E&#39;)=344i+190\)</span>，所以我们可以知道：同源会使其<span class="math inline">\(j\)</span>不变量发生变化。</p><h4 id="d-同源"><span class="math inline">\(d\)</span>-同源</h4><p>对于同源<span class="math inline">\(\phi\)</span>，我们称<span class="math inline">\(|\ker(\phi)|\)</span>为同源的度，度为<span class="math inline">\(d\)</span>的同源称为<span class="math inline">\(d\)</span>-同源，例如前面提到的<span class="math inline">\(2\)</span>-同源.</p><h4 id="sage上的同源">sage上的同源</h4><p>我们一般用sage的<code>isogeny</code>方法来计算同源，其函数原型如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isogeny(_kernel_, _codomain=None_, _degree=None_, _model=None_, _check=True_, _algorithm=None_, _velu_sqrt_bound=None_)</span><br></pre></td></tr></table></figure> 重要的参数如下：</p><ul><li><p><code>_kernel_</code>：就是前面提到输入的<span class="math inline">\(G\)</span>，可以是一个点，可以是点列，也可以是本原核多项式</p></li><li><p><code>codomain</code>：陪域，输入为一条椭圆曲线，这样生成的同源的陪域就是这条椭圆曲线</p></li><li><p><code>model</code>：输出的陪域的形式，有三种可选参数：</p></li></ul><ol type="1"><li><code>'minimal'</code>，输出全局最小的椭圆曲线</li><li><code>'short_weierstrass'</code>，输出short Weierstrass曲线，即由<span class="math inline">\(y^2=x^3+ax+b\)</span>形式的方程所定义的椭圆曲线</li><li><code>'montgomery'</code>输出蒙哥马利曲线</li></ol><ul><li><code>algorithm</code>：算法，有三种可选参数（均为自己的理解，可能不准确）：</li></ul><ol type="1"><li><code>'velusqrt'</code>，使用平方根Vélu算法</li><li><code>'factored'</code>，将度分解到为质因子之后再求解</li><li><code>'traditional'</code>，传统算法</li></ol><h3 id="同源图isogeny-graph">同源图（Isogeny graph）</h3><p>对于一个固定的<span class="math inline">\(p\)</span>，我们用<span class="math inline">\(GF(p^2)\)</span>中所有的超奇异<span class="math inline">\(j\)</span>-不变量各构造一条曲线，在每条曲线的<span class="math inline">\(\ker([l])\)</span>中取除了无穷远点外的所有点分别进行同源，将原来曲线的<span class="math inline">\(j\)</span>-不变量作为起点，同源得到的陪域的<span class="math inline">\(j\)</span>-不变量作为终点，就可以得到一个无向图，称为同源图，例如在参考资料2中给出的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262006853.png" alt="image-20250226200558759" /> 通过同源图，我们可以知道超奇异曲线的<span class="math inline">\(j\)</span>-不变量在同源时的变化路线. 可以通过如下算法求<span class="math inline">\(GF(p^2)\)</span>下的<span class="math inline">\(\ker([l])\)</span>的同源图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">IsogenyGraph</span>(<span class="params">p, l=<span class="number">2</span>, vertex_size=<span class="number">3750</span>, size=[<span class="number">20</span>, <span class="number">20</span>]</span>):</span><br><span class="line">    R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    jlist = &#123;&#125;</span><br><span class="line">    Elist = []</span><br><span class="line"></span><br><span class="line">    E = EllipticCurve(R, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span> E.is_supersingular()</span><br><span class="line">    jlist[E.j_invariant()] = <span class="built_in">set</span>()</span><br><span class="line">    Elist.append(E)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Elist:</span><br><span class="line">        tmp = Elist.pop()</span><br><span class="line">        kerl = tmp(<span class="number">0</span>).division_points(l)</span><br><span class="line">        <span class="keyword">for</span> P <span class="keyword">in</span> kerl:</span><br><span class="line">            <span class="keyword">if</span> P != tmp(<span class="number">0</span>):</span><br><span class="line">                phi = tmp.isogeny(P, model = <span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">                E2 = phi.codomain()</span><br><span class="line">                j = E2.j_invariant()</span><br><span class="line">                <span class="comment"># print(tmp.j_invariant(), j)</span></span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist:</span><br><span class="line">                    jlist[j] = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> jlist[tmp.j_invariant()]:</span><br><span class="line">                    jlist[tmp.j_invariant()].add(j)</span><br><span class="line">                    Elist.append(E2)</span><br><span class="line"></span><br><span class="line">    Tab = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> jlist:</span><br><span class="line">        Tab[x] = <span class="built_in">list</span>(jlist[x])</span><br><span class="line">    G = Graph(Tab)</span><br><span class="line"></span><br><span class="line">    G.set_pos(G.layout_circular())</span><br><span class="line">    G.plot(vertex_labels=<span class="literal">True</span>,vertex_size=vertex_size).show(figsize=size)</span><br></pre></td></tr></table></figure><p>通过这个算法画出来的<span class="math inline">\(GF(431^2)\)</span>下的<span class="math inline">\(\ker([2])\)</span>的同源图长这样： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502261957075.png" alt="output" /></p><h2 id="超奇异同源diffie-hellman密钥交换体系sidh">超奇异同源Diffie-Hellman密钥交换体系（SIDH）</h2><h3 id="sidh协议细节">SIDH协议细节</h3><p>首先密钥交换双方（以下称为Alice和Bob）协商选取模数<span class="math inline">\(p=2^a3^b-1\)</span>，其中<span class="math inline">\(2^a\approx 3^b\)</span>，然后选取一条<span class="math inline">\(GF(p^2)\)</span>下的超奇异椭圆曲线<span class="math inline">\(E\)</span>，在此之后，Alice选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(2^a\)</span>的两点<span class="math inline">\(P_A,Q_A\)</span>并公开，Bob选取<span class="math inline">\(E\)</span>上阶为<span class="math inline">\(3^b\)</span>的两点<span class="math inline">\(P_B,Q_B\)</span>并公开（在选取的时候，需要保证<span class="math inline">\(P_A,Q_A\)</span>线性无关，<span class="math inline">\(P_B,Q_B\)</span>线性无关）。 Alice随机选取秘密值<span class="math inline">\(k_A\in\{0,1,\cdots,2^a-1\}\)</span>，计算<span class="math inline">\(S_A=P_A+k_AQ_A\)</span>，并通过<span class="math inline">\(S_A\)</span>计算同源<span class="math inline">\(\phi_A:E\mapsto E_A\)</span>，其中<span class="math inline">\(E_A=E/\langle S_A\rangle\)</span>，<span class="math inline">\(\phi_A\)</span>由<span class="math inline">\(a\)</span>个<span class="math inline">\(2\)</span>-同源组合而成，最后使用<span class="math inline">\((E_A,\phi_A(P_B),\phi_A(Q_B))\)</span>作为公钥，<span class="math inline">\((k_A,S_A)\)</span>作为私钥； 同样的，Bob随机选取秘密值<span class="math inline">\(k_B\in\{0,1,\cdots,3^b-1\}\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B\)</span>，通过<span class="math inline">\(S_B\)</span>计算同源<span class="math inline">\(\phi_B:E\mapsto E_B\)</span>，其中<span class="math inline">\(\phi_B\)</span>由<span class="math inline">\(b\)</span>个<span class="math inline">\(3\)</span>-同源组合而成，使用<span class="math inline">\((E_B,\phi_B(P_A),\phi_B(Q_A))\)</span>作为公钥，<span class="math inline">\((k_B,S_B)\)</span>作为私钥。 通过上述计算得到的公钥，Alice可以计算出<span class="math inline">\(S_{A}&#39;=\phi_B(P_A)+k_A\phi_B(Q_A)\)</span>，计算同源<span class="math inline">\(\phi_A&#39;:E_B\mapsto E_{AB}\)</span>，就可以计算出<span class="math inline">\(j_{AB}=j(E_{AB})\)</span>，同样的，Bob可以计算出<span class="math inline">\(S_{B}&#39;=\phi_A(P_B)+k_B\phi_A(Q_B)\)</span>，然后计算同源<span class="math inline">\(\phi_B&#39;:E_A\mapsto E_{BA}\)</span>，从而可以计算出<span class="math inline">\(j_{BA}=j(E_{BA})\)</span>，有<span class="math inline">\(j_{AB}=j_{BA}\)</span>，所以共享密钥值为<span class="math inline">\(j=j_{AB}=j_{BA}\)</span>.</p><h4 id="sidh实例">SIDH实例</h4><blockquote><p>本样例来源于参考资料2</p></blockquote><p>Alice和Bob协商选取模数<span class="math inline">\(p=2^43^3-1=431\)</span>，并选取<span class="math inline">\(GF(p^2)\)</span>上的一条超奇异椭圆曲线： <span class="math display">\[E:y^2=x^3+(329i+423)x^2+x\]</span> 有<span class="math inline">\(j(E)=87i+190\)</span>，Alice从中选取两个阶为<span class="math inline">\(2^4\)</span>的点： <span class="math display">\[P_A=(100i+248,304i+199),Q_A=(426i+394,51i+79)\]</span> 同时Bob从中选取两个阶为<span class="math inline">\(3^3\)</span>的点： <span class="math display">\[P_B = (358i+275, 410i+104),Q_B = (20i+185, 281i+239)\]</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">2</span>^<span class="number">4</span> * <span class="number">3</span>^<span class="number">3</span> - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">a = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, a, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span></span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure> 然后Alice从<span class="math inline">\(\{0,1,\cdots,2^4-1\}\)</span>中选择<span class="math inline">\(k_A=11\)</span>，据此计算<span class="math inline">\(S_A=P_A+k_AQ_A=(271i + 79, 153i + 430)\)</span>，我们可以通过如下算法计算同源路径从而得到<span class="math inline">\(S_A\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262005508.png" alt="image-20250226200532409" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line"></span><br><span class="line">SA_, EA_, PB_, QB_ = SA, E, PB, QB</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(a-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RA_ = SA_ * <span class="number">2</span>^e</span><br><span class="line">    phi = EA_.isogeny(-RA_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SA_, EA_, PB_, QB_ = phi(SA_), phi.codomain(), phi(PB_), phi(QB_)</span><br><span class="line"></span><br><span class="line">phiA = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiA = phiA * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_A:y^2 = x^3 + (128i+19)x^2 + x\)</span>，<span class="math inline">\(\phi_A(P_B)=(130i + 170,428i + 290)\)</span>，<span class="math inline">\(\phi_A(Q_B)=(235i+209,126i+15)\)</span>； 同理，Bob在<span class="math inline">\(\{0,1,\cdots,3^3-1\}\)</span>中选择<span class="math inline">\(k_B=2\)</span>，计算<span class="math inline">\(S_B=P_B+k_BQ_B=(122i +309, 291i+374)\)</span>，那么我们可以通过如下算法计算出<span class="math inline">\(S_B\)</span>对应的同源： <img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202502262003851.png" alt="image-20250226200334440" /> 其中<span class="math inline">\(e\)</span>表示恒等映射，sage代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phis = []</span><br><span class="line">SB_, EB_, PA_, QA_ = SB, E, PA, QA</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(b-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    RB_ = SB_ * <span class="number">3</span>^e</span><br><span class="line">    phi = EB_.isogeny(RB_, model=<span class="string">&quot;montgomery&quot;</span>)</span><br><span class="line">    phis.append(phi)</span><br><span class="line">    SB_, EB_, PA_, QA_ = phi(SB_), phi.codomain(), phi(PA_), phi(QA_)</span><br><span class="line"></span><br><span class="line">phiB = phis[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phis) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    phiB = phiB * phis[i]</span><br></pre></td></tr></table></figure><p>计算得到<span class="math inline">\(E_B:y^2 = x^3 + (329i+8)x^2 + x\)</span>，<span class="math inline">\(\phi_B(P_A)=(160i + 421, 246i + 252)\)</span>，<span class="math inline">\(\phi_B(Q_A)=(119i+14, 246i + 138)\)</span> 这样双方的公钥均已经计算出来，最后Alice就可以通过自己的私钥计算出： <span class="math display">\[S_{A}&#39;=\phi_B(P_A)+k_A\phi{(Q_A)}\]</span> 再通过上述算法计算出Alice侧<span class="math inline">\(S_{A}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_A/\langle S_{A}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，同样的，Bob可以通过自己的私钥计算出： <span class="math display">\[S_{B}&#39;=\phi_A(P_B)+k_B\phi{(Q_A)}\]</span> 再通过上述算法计算出Bob侧<span class="math inline">\(S_{B}&#39;\)</span>对应的同源的陪域<span class="math inline">\(E_B/\langle S_{B}&#39;\rangle\)</span>，那么这个陪域的<span class="math inline">\(j\)</span>-不变量就是共享密钥，可以通过下列代码计算出共享密钥： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA_.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Bob_shared_secret)</span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB_.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 可以计算出共享密钥为<span class="math inline">\(234\)</span>，整理并优化代码后可以得到： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">p = <span class="number">2</span>^a * <span class="number">3</span>^b - <span class="number">1</span></span><br><span class="line">R.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">A = <span class="number">329</span>*i + <span class="number">423</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(R, [<span class="number">0</span>, A, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">PA = E(<span class="number">100</span>*i+<span class="number">248</span>, <span class="number">304</span>*i+<span class="number">199</span>)</span><br><span class="line">QA = E(<span class="number">426</span>*i+<span class="number">394</span>, <span class="number">51</span>*i+<span class="number">79</span>)</span><br><span class="line"></span><br><span class="line">PB = E(<span class="number">358</span>*i+<span class="number">275</span>, <span class="number">410</span>*i+<span class="number">104</span>)</span><br><span class="line">QB = E(<span class="number">20</span>*i+<span class="number">185</span>, <span class="number">281</span>*i+<span class="number">239</span>)</span><br><span class="line"><span class="keyword">assert</span> PA.order() == QA.order() == <span class="number">2</span>^<span class="number">4</span> <span class="keyword">and</span> PB.order() == QB.order() == <span class="number">3</span>^<span class="number">3</span></span><br><span class="line"></span><br><span class="line">kA = <span class="number">11</span></span><br><span class="line">SA = PA + kA * QA</span><br><span class="line">phiA = E.isogeny(SA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EA = phiA.codomain()</span><br><span class="line">PB_ = phiA(PB)</span><br><span class="line">QB_ = phiA(QB)</span><br><span class="line"></span><br><span class="line">kB = <span class="number">2</span></span><br><span class="line">SB = PB + kB * QB</span><br><span class="line">phiB = E.isogeny(SB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">EB = phiB.codomain()</span><br><span class="line">PA_ = phiB(PA)</span><br><span class="line">QA_ = phiB(QA)</span><br><span class="line"></span><br><span class="line">SAB = phiA(PB) + kB * phiA(QB)</span><br><span class="line">EAB = EA.isogeny(SAB, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Bob_shared_secret = EAB.j_invariant()</span><br><span class="line"></span><br><span class="line">SBA = phiB(PA) + kA * phiB(QA)</span><br><span class="line">EBA = EB.isogeny(SBA, model=<span class="string">&quot;montgomery&quot;</span>, algorithm=<span class="string">&quot;factored&quot;</span>).codomain()</span><br><span class="line">Alice_shared_secret = EBA.j_invariant()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> Bob_shared_secret == Alice_shared_secret</span><br><span class="line"><span class="built_in">print</span>(Alice_shared_secret)</span><br></pre></td></tr></table></figure> 或者可以将封装公钥和计算私钥封装为函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_public_key</span>(<span class="params">E, P1, Q1, s, P2, Q2</span>):</span><br><span class="line">    S = P1 + s*Q1</span><br><span class="line">    phi = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi, (phi.codomain(), phi(P2), phi(Q2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_shared_secret</span>(<span class="params">E, P, Q, s</span>):</span><br><span class="line">    S = P + s*Q</span><br><span class="line">    phi1 = E.isogeny(S, model=<span class="string">&#x27;montgomery&#x27;</span>, algorithm=<span class="string">&quot;factored&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> phi1.codomain().j_invariant()</span><br></pre></td></tr></table></figure></p><h3 id="sidh的安全性">SIDH的安全性</h3><p>理论上SIDH的安全性主要依赖于通过公钥中给出的曲线来求出它对应的同源。但是在2022年SIDH就被宣布完全破解，在Github上就有代码：<a href="https://github.com/GiacomoPope/Castryck-Decru-SageMath">GiacomoPope/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH</a>，<del>要用的话拔出来用就行</del></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过狄利克雷近似解决HNP-2H</title>
      <link href="/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/"/>
      <url>/2024/11/30/%E9%80%9A%E8%BF%87%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E8%BF%91%E4%BC%BC%E8%A7%A3%E5%86%B3HNP-2H/</url>
      
        <content type="html"><![CDATA[<p>最近在复现Crypto CTF 2024的时候碰到一道题考察了HNP-2H（Hidden Number Problem with 2 Holes，双洞隐藏数问题），在做题的时候，找到了一篇论文：<a href="https://link.springer.com/content/pdf/10.1007/978-3-540-74462-7_9.pdf?pdf=inline+link">Extended Hidden Number Problem and Its Cryptanalytic Applications</a>，并通过这篇论文了解到可以通过狄利克雷近似定理来将HNP-2H约化为我们熟悉的HNP来解决。</p><h2 id="hnp-2h的定义">HNP-2H的定义</h2><p>这里直接引用论文中的定义：</p><p>设<span class="math inline">\(N\)</span>是一个质数，并设<span class="math inline">\(x\in \mathbb{Z}_n\)</span>是一个部分未知的整数满足以下<span class="math inline">\(d\)</span>条同余式： <span class="math display">\[\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N},\ 1\le i\le d\]</span> 其中<span class="math inline">\(\alpha_i\)</span>满足<span class="math inline">\(\alpha_i\mod{N}\neq0\)</span>，<span class="math inline">\(\alpha_i,\rho_{i,1},\rho_{i,2}\)</span>以及<span class="math inline">\(\beta_i\)</span>（<span class="math inline">\(1\le i\le d\)</span>）为已知量，未知量<span class="math inline">\(k_{i,1}\)</span>与<span class="math inline">\(k_{i,2}\)</span>满足<span class="math inline">\(0\le k_{i,1}\le2^{\mu_1}\)</span>及<span class="math inline">\(0\le k_{i,2}\le2^{\mu_2}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），其中<span class="math inline">\(\mu_1,\mu_2\)</span>为已知有理常量，则双洞隐藏数问题（Hidden Number Problem with 2 Holes）就是通过以上条件求出<span class="math inline">\(x\)</span>。</p><h2 id="使用狄利克雷近似解决hnp-2h">使用狄利克雷近似解决HNP-2H</h2><p>在使用狄利克雷近似解决HNP-2H之前，我们需要先了解何谓狄利克雷近似，其阐述如下</p><h3 id="狄利克雷近似dirichlets-approximation定理以及其推论">狄利克雷近似（Dirichlet's approximation）定理以及其推论</h3><p><strong>狄利克雷近似定理：</strong>设<span class="math inline">\(\alpha\in\mathbb{R}\)</span>以及<span class="math inline">\(0&lt;\varepsilon\le1\)</span>为两已知量，那么存在<span class="math inline">\(p,q\in\mathbb{Z}\)</span>使得<span class="math inline">\(1\le q\le\frac{1}{\varepsilon}\)</span>以及<span class="math inline">\(|\alpha-\frac{p}{q}|&lt;\frac{\varepsilon}{q}\)</span>成立。</p><p>通过这个定理，我们可以得到如下推论：</p><p>假定我们已知<span class="math inline">\(A,N\in\mathbb{Z}\)</span>与<span class="math inline">\(B\in\mathbb{R}\)</span>满足<span class="math inline">\(B\ge1\)</span>且<span class="math inline">\(N&gt;0\)</span>那么存在<span class="math inline">\(\lambda\in\mathbb{Z}\)</span>满足<span class="math inline">\(1\le\lambda\le B\)</span>且<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>.（<span class="math inline">\(|a|_N\)</span>表示<span class="math inline">\(min_{k\in\mathbb{Z}}|a-kN|\)</span>）</p><p>通过狄利克雷近似定理以及其推论，我们可以知道，在已知<span class="math inline">\(B\)</span>的情况下，我们可以通过连分数在多项式时间内通过<span class="math inline">\(|\lambda A|_N&lt;\frac{N}{B}\)</span>求解出<span class="math inline">\(\lambda\)</span></p><h3 id="借助狄利克雷近似解决hnp-2h">借助狄利克雷近似解决HNP-2H</h3><blockquote><p>本部分摘自论文第三部分的 Theorem 3 的证明</p></blockquote><p>令<span class="math inline">\(A_i=(\rho_{i,1})^{-1}\rho_{i,2}\mod{N}\)</span>，<span class="math inline">\(\gamma_i=k_{i,1}+A_ik_{i,2}\)</span>，<span class="math inline">\(\alpha_i&#39;=(\rho_{i,1})^{-1}\alpha_i\mod{N}\)</span>以及<span class="math inline">\(\beta_i&#39;=(\rho_{i,1})^{-1}\beta_i\mod{N}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），则同余式<span class="math inline">\(\alpha_ix+\rho_{i,1}k_{i,1}+\rho_{i,2}k_{i,2}\equiv \beta_i\pmod{N}\)</span>可以转化为： <span class="math display">\[\alpha_i&#39;x+\gamma_i\equiv\beta&#39;_i\pmod{N}\]</span> 我们选定一个大于1的实数<span class="math inline">\(B\)</span>，由狄利克雷近似的推论，我们可以通过连分数找到一个非零整数<span class="math inline">\(\lambda_{i,B}\)</span>满足<span class="math inline">\(|\lambda_{i,B}A_i|&lt;\frac{N}{B}\)</span>，且有<span class="math inline">\(1\le\lambda_{i,B}\le B\)</span>（<span class="math inline">\(1\le i\le d\)</span>），使得下面的关系成立： <span class="math display">\[\begin{aligned}|\lambda_{i,B}\gamma_i|_N&amp;=|\lambda_{i,B}k_{i,1}+\lambda_{i,B}A_ik_{i,2}|_N\\&amp;\le|\lambda_{i,B}|_Nk_{i,1}+|\lambda_{i,B}A_i|_Nk_{i,2}\\&amp;&lt;B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\end{aligned}\]</span> 选择<span class="math inline">\(B_{min}=N^{\frac{1}{2}}2^{\frac{\mu_2-\mu_1}{2}}\)</span>可以最大限度地减少<span class="math inline">\(B2^{\mu_1}+\frac{N}{B}2^{\mu_2}\)</span>的上界（此时<span class="math inline">\(B_{min}2^{\mu_1}+\frac{N}{B_{min}}2^{\mu_2}=N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\)</span>）.</p><p>在此之后，我们设<span class="math inline">\(k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{N}\)</span>，可以知道：<span class="math inline">\(k_i&#39;&lt;N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}\)</span>，那么通过下述步骤，我们就可以将HNP-2H转化为HNP，从而通过一般HNP的解决方法来解决HNP-2H了： <span class="math display">\[\begin{aligned}\alpha_i&#39;x+\gamma_i&amp;\equiv\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+\lambda_{i,B_{min}}\gamma_i&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i\pmod{N}\\(\lambda_{i,B_{min}}\alpha_i&#39;)x+k_i&#39;&amp;\equiv\lambda_{i,B_{min}}\beta&#39;_i+\lfloor N^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\pmod{N}\\\alpha_i&#39;&#39;x+k_i&#39;&amp;\equiv\beta_i&#39;&#39;\pmod{N},\ (1\le i\le d)\end{aligned}\]</span></p><h2 id="例crypto-ctf-2024-honey">例：[Crypto CTF 2024] Honey</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt  </span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_params</span>(<span class="params">nbit</span>):  </span><br><span class="line">    p, Q, R, S = getPrime(nbit), [], [], []  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(nbit &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       Q.append(getRandomRange(<span class="number">1</span>, p - <span class="number">1</span>))  </span><br><span class="line">       R.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">       S.append(getRandomRange(<span class="number">0</span>, p - <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">return</span> p, Q, R, S  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m, params</span>):  </span><br><span class="line">    p, Q, R, S = params  </span><br><span class="line">    <span class="keyword">assert</span> m &lt; p  </span><br><span class="line">    d = <span class="built_in">int</span>(sqrt(p.bit_length() &lt;&lt; <span class="number">1</span>))  </span><br><span class="line">    C = []  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d):  </span><br><span class="line">       r, s = [getRandomNBitInteger(d) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&#x27;01&#x27;</span>]  </span><br><span class="line">       c = Q[_] * m + r * R[_] + s * S[_]  </span><br><span class="line">       C.append(c % p)  </span><br><span class="line">    <span class="keyword">return</span> C  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">nbit = <span class="number">512</span>  </span><br><span class="line">params = gen_params(<span class="number">512</span>)  </span><br><span class="line">m = bytes_to_long(flag)  </span><br><span class="line">C = encrypt(m, params)  </span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;params_enc.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;p = <span class="subst">&#123;params[<span class="number">0</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;Q = <span class="subst">&#123;params[<span class="number">1</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;R = <span class="subst">&#123;params[<span class="number">2</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;S = <span class="subst">&#123;params[<span class="number">3</span>]&#125;</span>\n&#x27;</span>)  </span><br><span class="line">f.write(<span class="string">f&#x27;C = <span class="subst">&#123;C&#125;</span>&#x27;</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>整理可得方程组： <span class="math display">\[C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\]</span> 其中<span class="math inline">\(i=1,2,\cdots,d\)</span>，而<span class="math inline">\(C_i,Q_i,R_i,S_i\)</span>以及<span class="math inline">\(p\)</span>均已知，而且知道<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，要求<span class="math inline">\(m\)</span>，显然，这是HNP-2H，那么我们可以通过上面讲的方法来将其约化为HNP来求解，有<span class="math inline">\(A_i=R_i^{-1}S_i\mod{p}\)</span>，<span class="math inline">\(\gamma_{i}=r_i+A_is_i\)</span>，<span class="math inline">\(\alpha_i&#39;= R_i^{-1}Q_i\mod{p}\)</span>，<span class="math inline">\(\beta_i&#39;=R_i^{-1}C_i\mod{p}\)</span>（<span class="math inline">\(1\le i\le d\)</span>），可以将方程<span class="math inline">\(C_i\equiv Q_im+R_ir_i+S_is_i\pmod{p}\)</span>变为： <span class="math display">\[\alpha_i&#39;m+\gamma_i\equiv \beta_i&#39;\pmod{p}\]</span> 由于<span class="math inline">\(0\le r_i,s_i\le2^d=2^{32}\)</span>，那么我们可以取<span class="math inline">\(\mu_1=\mu_2=32\)</span>，那么我们取<span class="math inline">\(B_{min}=p^{\frac{1}{2}}2^{\frac{\mu_2-\mu_i}{2}}=p^{\frac{1}{2}}\)</span>，则可以利用连分数计算出满足条件的<span class="math inline">\(\lambda_{i,B_{min}}\)</span>，算法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在求出<span class="math inline">\(\lambda_{i,B_{min}}\)</span>之后，我们可以得到： <span class="math display">\[k_i&#39;=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+2}{2}}\rfloor\right)\mod{p}=\left(\lambda_{i,B_{min}}\gamma_i+\lfloor p^{\frac{1}{2}}2^{33}\rfloor\right)\mod{p}\]</span> 可以得到<span class="math inline">\(\{k_1,k_2,\cdots,k_d\}\)</span>的上界<span class="math inline">\(K=p^{\frac{1}{2}}2^{\frac{\mu_1+\mu_2+4}{2}}=p^{\frac{1}{2}}2^{34}\)</span>.这样我们就可以将这个问题约化为一般的HNP进行求解，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = ...</span><br><span class="line">Q = [...]</span><br><span class="line">R = [...]</span><br><span class="line">S = [...]</span><br><span class="line">C = [...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLambda</span>(<span class="params">A</span>):</span><br><span class="line">    B = p.isqrt()</span><br><span class="line">    cf = (A/p).continued_fraction()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cf)):</span><br><span class="line">        <span class="keyword">if</span> cf.denominator(i) &lt; B <span class="keyword">and</span> cf.denominator(i+<span class="number">1</span>) &gt; B:</span><br><span class="line">            <span class="keyword">return</span> cf.denominator(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">len</span>(Q)</span><br><span class="line">A = []</span><br><span class="line">B = p.isqrt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    a = inverse(R[i], p) * S[i] % p</span><br><span class="line">    A.append(a)</span><br><span class="line"></span><br><span class="line">alpha = []</span><br><span class="line">beta = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    lambda_i = getLambda(A[i])</span><br><span class="line">    a = inverse(R[i], p) * Q[i] * lambda_i % p</span><br><span class="line">    b = (inverse(R[i], p) * C[i] * lambda_i + floor(B * <span class="number">2</span>^<span class="number">33</span>)) % p</span><br><span class="line">    alpha.append(a)</span><br><span class="line">    beta.append(b)</span><br><span class="line"></span><br><span class="line">K = p.isqrt() * <span class="number">2</span>^<span class="number">34</span></span><br><span class="line"></span><br><span class="line">L = matrix(QQ, d+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">    L[i, i] = p</span><br><span class="line">    L[-<span class="number">2</span>, i] = alpha[i]</span><br><span class="line">    L[-<span class="number">1</span>, i] = beta[i]</span><br><span class="line"></span><br><span class="line">L[-<span class="number">2</span>, -<span class="number">2</span>] = K / p</span><br><span class="line">L[-<span class="number">1</span>, -<span class="number">1</span>] = K</span><br><span class="line"></span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line">v = res[<span class="number">1</span>]</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">abs</span>(v[-<span class="number">2</span>] * p / K))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行可得flag：<code>CCTF&#123;3X7eNdED_H!dD3n_nNm8eR_pR0Bl3m_iN_CCTF!!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 格密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>已知两质因数半数以上随机位的大整数分解</title>
      <link href="/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/"/>
      <url>/2024/11/27/%E5%B7%B2%E7%9F%A5%E4%B8%A4%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8D%8A%E6%95%B0%E4%BB%A5%E4%B8%8A%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在解决RSA问题的过程中，我们往往会需要对一个大整数<span class="math inline">\(n\)</span>进行质因数分解，在已知部分连续位的时候，我们经常会考虑使用Copper Smith方法来进行分解，但是若我们知道的是随机分散的位，Copper Smith方法将会失效，例如我们知道由两个质因数相乘得到的一个大整数<span class="math inline">\(n=pq\)</span>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span><br></pre></td></tr></table></figure><p>又已知<span class="math inline">\(p\)</span>的部分已知位（二进制表示，其中下划线为未知位，下同）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___</span><br></pre></td></tr></table></figure><p>与<span class="math inline">\(q\)</span>的部分已知位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___</span><br></pre></td></tr></table></figure><p>显然，我们不能使用Copper Smith方法进行分解。</p><p>为应对这种情况，大佬y011d4在Github上发布了一个项目：<a href="https://github.com/y011d4/factor-from-random-known-bits">y011d4/factor-from-random-known-bits</a>，我们可以使用这个项目对上述的情况进行分解。</p><p>下载方法（推荐Linux）：</p><ul><li><p>首先确保系统中有Rust环境（因为这个项目主要是由Rust语言编写的）</p></li><li>使用<code>git clone https://github.com/y011d4/factor-from-random-known-bits.git</code>从Github上将该项目拉下来</li><li><p><code>cd factor-from-random-known-bits</code>进入项目文件夹后依次运行<code>pip install -r requirements.txt</code>以及<code>python setup.py install</code></p></li></ul><p>在此之后就可以通过在Python中<code>import factor</code>后使用这个方法进行分解了。</p><blockquote><p>假若安装时报错，则有可能是系统中缺少 <code>m4</code> 这个宏处理器，可以通过<code>sudo apt-get install m4</code>来安装这个宏处理器.</p></blockquote><h2 id="适用条件">适用条件</h2><ul><li>已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位</li></ul><h2 id="使用方法">使用方法</h2><p>这个库有两种使用方法：<code>from_str</code>以及<code>from_vector</code></p><h3 id="from_str"><code>from_str</code></h3><p>以前面的数据为例，则可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = <span class="string">&quot;1010101111000___11000___11100___11010___0___0___0___100110000___0___0___0___11000___0___0___110110010___11001100100111010___100011000___0___0___0___11111000111111100___1101110010000___0___0___0___10110___0___0___0___0___0___1100101111000___0___1001111011110___0___10000___0___0___11010___1010101110110___0___0___0___0___10010___1011101011100___110111010___0___0___0___101010110___0___10000___1000101011000___0___0___0___101010000___11010___111010000___0___11110___0___10010___111010010___0___0___10100___0___0___&quot;</span></span><br><span class="line">q_known = <span class="string">&quot;110111010___111011110___0___1000100110001110100111100___0___10110___11000___0___10110___11100___10000___0___0___11111100110010100___10000___11100___0___110010110___101110010___10010___11110___11110___0___1101111011000___101010110___10100___0___10100___1010101011010___0___0___100110110___0___10000___0___0___1000101110010___1111110010110___0___0___0___101110100___0___1100101111000___10100___0___0___0___0___0___0___10010___0___0___10100___10010___0___0___0___101011110___0___111110000___0___11110___0___10100___&quot;</span></span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">8996460061304658501483536370547552107653796408964122401908135206811298639114618429412462572834106148254319079697639081615546751035691609086377055207530819</span></span><br><span class="line">q = <span class="number">11577771027337574615881755252249566401199602697310825312674761422549781992489861876313558348484109945826438743090783573542794191930931862927421766237119653</span></span><br></pre></td></tr></table></figure><p>在这里，我们将未知的位置为下划线。</p><h3 id="from_vector"><code>from_vector</code></h3><p>以前面的数据为例，也可以通过如下代码对<span class="math inline">\(n\)</span>进行分解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">104158954646372695568095796310479805403678314919693272509836778997179683485437763692891984254171869987446475357518587344178264028334102088429629785065036660148146855007349113784322098795994839040721664806905084554147298456659074384855277678993200563966327086005547016327991986225930798076081014377904788085807</span></span><br><span class="line">p_known = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">q_known = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">p, q = factor.from_str(n, p_known, q_known)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;q = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行可以得到相同的结果。</p><p>在这种用法中，我们将未知的位设置为-1</p><blockquote><p>注意：虽然适用条件中说已知<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>各50%以上的位就能使用，但是在某次测试中发现<span class="math inline">\(p\)</span>与<span class="math inline">\(q\)</span>均已知50.05%的位的时候其实是用不了的，这种时候就要通过爆破来知道尽可能多的位。</p></blockquote><h2 id="使用例bcactf-5.0-superstitious-2">使用例：[BCACTF 5.0 Superstitious 2]</h2><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myGetPrime</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = getRandomNBitInteger(<span class="number">1024</span>) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">1024</span>) - <span class="number">1</span>)//<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(x):</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">p = myGetPrime()</span><br><span class="line">q = myGetPrime()</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">m = bytes_to_long(message.read())</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;superstitious-2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>).write(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>\ne = <span class="subst">&#123;e&#125;</span>\nc = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以知道<code>((1 &lt;&lt; 1024) - 1)//3</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101</span><br></pre></td></tr></table></figure><p>所以我们可以知道<span class="math inline">\(p\)</span>以及<span class="math inline">\(q\)</span>约半数的位为0，以及最低位为1（因为<span class="math inline">\(p\)</span>,<span class="math inline">\(q\)</span>必为奇数），所以我们将除了最低位的所有1都替换为下划线后通过Cyberchef统计之后可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325392.png" alt="image-20241127232058419" /><figcaption>image-20241127232058419</figcaption></figure><p>有50.05%的位已知，显然可以利用本文说的方法来进行分解，但是实际操作发现只知道这么多位并不能直接分解<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>，所以我们需要对<span class="math inline">\(p\)</span>进行小范围爆破，所以我们可以通过如下脚本来进行求解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">n = <span class="number">550201148354755741271315125069984668413716061796183554308291706476140978529375848655819753667593579308959498512392008673328929157581219035186964125404507736120739215348759388064536447663960474781494820693212364523703341226714116205457869455356277737202439784607342540447463472816215050993875701429638490180199815506308698408730404219351173549572700738532419937183041379726568197333982735249868511771330859806268212026233242635600099895587053175025078998220267857284923478523586874031245098448804533507730432495577952519158565255345194711612376226297640371430160273971165373431548882970946865209008499974693758670929</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">12785320910832143088122342957660384847883123024416376075086619647021969680401296902000223390419402987207599720081750892719692986089224687862496368722454869160470101334513312534671470957897816352186267364039566768347665078311312979099890672319750445450996125821736515659224070277556345919426352317110605563901547710417861311613471239486750428623317970117574821881877688142593093266784366282508041153548993479036139219677970329934829870592931817113498603787339747542136956697591131562660228145606363369396262955676629503331736406313979079546532031753085902491581634604928829965989997727970438591537519511620204387132</span></span><br><span class="line"></span><br><span class="line">binlist = []</span><br><span class="line">s = <span class="string">&quot;_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_01&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    b = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    ns = <span class="built_in">list</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        ns[<span class="number">2</span>*i] = b[i]</span><br><span class="line">    binlist.append(<span class="string">&quot;&quot;</span>.join(ns))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pknown <span class="keyword">in</span> tqdm.tqdm(binlist):</span><br><span class="line">    ps = factor.from_str(n, pknown, s)</span><br><span class="line">    <span class="keyword">if</span> ps != <span class="literal">None</span>:</span><br><span class="line">        p, q = ps</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = inverse(e, phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在这里，我们通过爆破<span class="math inline">\(p\)</span>的高16位中的8个未知位将<span class="math inline">\(p\)</span>的已知位提升了8位，将补充的位全部置0再进行统计可以看到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202411272325083.png" alt="image-20241127232521024" /><figcaption>image-20241127232521024</figcaption></figure><p>这时候<span class="math inline">\(p\)</span>的已知部分变成了50.83%，应该可以进行有效分解了。运行脚本之后我们就可以得到flag：</p><blockquote><p>bcactf{l4zy_cHall3nG3_WRITinG_f8b335319e464}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>若尔当标准型与矩阵离散对数问题</title>
      <link href="/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><del>想写这篇好久了，一直没空，考完期末水一下</del></p><h2 id="第一部分若尔当标准型概述">第一部分：若尔当标准型概述</h2><blockquote><p>参考资料：《高等代数（第五版）》（北京大学数学系前代数小组 编）:P213-P219,P236-P239</p></blockquote><p><strong>定义：</strong>形为 <span class="math display">\[\pmb{J}(\lambda_0,k)=\left(\begin{matrix}\lambda_0&amp;0&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\1&amp;\lambda_0&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\0&amp;1&amp;\lambda_0&amp;\cdots&amp;0&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp; &amp;\vdots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;1&amp;\lambda_0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1&amp;\lambda_0\end{matrix}\right)_{k×k}\]</span> 的矩阵称为<strong>若尔当块</strong>，其中<span class="math inline">\(\lambda_0\)</span>为复数.由若干个若尔当块组成的准对角矩阵 <span class="math display">\[\pmb{A}=\left(\begin{matrix}\pmb{J}(\lambda_1,k_1)&amp;&amp;&amp;\\&amp;\pmb{J}(\lambda_2,k_2)&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;\pmb{J}(\lambda_s,k_s)\end{matrix}\right)\]</span> 称为<strong>若尔当形矩阵</strong>，其中<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_s\)</span>为复数，有一些可以相同.</p><p>例如矩阵 <span class="math display">\[\pmb{A}=\left(\begin{matrix}1&amp;0&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\end{matrix}\right)=\pmb{J}(1,3)\]</span> 为若尔当形矩阵（同时它也是一个若尔当块）.</p><p>下面给出的是跟若尔当形矩阵相关的一个重要结论，也是后面通过若尔当形矩阵解决矩阵离散对数问题的重要理论支撑.</p><p><strong>定理：</strong>每个<span class="math inline">\(n\)</span>阶复矩阵<span class="math inline">\(\pmb{A}\)</span>一定与一个若尔当形矩阵相似.这个若尔当形矩阵除去其中若尔当块的排列顺序外由<span class="math inline">\(\pmb{A}\)</span>唯一确定，我们称该若尔当形矩阵为<span class="math inline">\(\pmb{A}\)</span>的<strong>若尔当标准型</strong>.而若尔当标准型中主对角线上元素为<span class="math inline">\(\pmb{A}\)</span>的所有特征值.</p><p>由上述定理我们可以知道：对于复矩阵<span class="math inline">\(\pmb{A}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>，必存在一可逆矩阵<span class="math inline">\(\pmb{P}\)</span>，使得<span class="math inline">\(\pmb{J}=\pmb{P}^{-1}\pmb{A}\pmb{P}\)</span>.</p><p>实际上，对于上面的若尔当形矩阵： <span class="math display">\[\pmb{A}=\left(\begin{matrix}\pmb{J}(\lambda_1,k_1)&amp;&amp;&amp;\\&amp;\pmb{J}(\lambda_2,k_2)&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;\\&amp;&amp;&amp;\pmb{J}(\lambda_s,k_s)\end{matrix}\right)\]</span> 其转置<span class="math inline">\(\pmb{A}^T\)</span>也可被称为若尔当形矩阵，例如对于矩阵 <span class="math display">\[\pmb{A}=\left(\begin{matrix}1&amp;0&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{matrix}\right)\]</span> 矩阵<span class="math inline">\(\pmb{A}^T=\left(\begin{matrix}1&amp;1&amp;0\\0&amp;1&amp;1\\0&amp;0&amp;1\end{matrix}\right)\)</span>也是若尔当形矩阵.</p><p>下面介绍一种求矩阵的若尔当标准型的方法——通过矩阵的特征值求出其若尔当标准型：</p><p>第一步：对于一矩阵<span class="math inline">\(\pmb{A}_{n×n}\)</span>，求出其特征值<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_s\)</span>；</p><p>第二步：求出每个特征值的几何重数（相等特征值只需求一次，表示该特征值对应的若尔当块的个数），其中对于特征值<span class="math inline">\(\lambda_i\)</span>，几何重数为<span class="math inline">\(n-r(\lambda_i\pmb{I}-\pmb{A})\)</span></p><p>第三步：求每个特征值对应的若尔当块的最大阶数，即找到特征值<span class="math inline">\(\lambda_i\)</span>对应的一个值<span class="math inline">\(k_i\)</span>，使得<span class="math inline">\(k_i\)</span>为满足<span class="math inline">\(r[(\lambda_i\pmb{I}-\pmb{A})^{k_i}]=r[(\lambda_i\pmb{I}-\pmb{A})^{k_i+1}]\)</span>的最小正整数</p><p>举个例子，对矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>，求其对应的若尔当标准型：</p><p>第一步，求矩阵<span class="math inline">\(\pmb{A}\)</span>对应的特征值，即解方程<span class="math inline">\(det(\lambda \pmb{I}-A)=0\)</span>，解得唯一解<span class="math inline">\(\lambda=3\)</span>；</p><p>第二步，对唯一特征值<span class="math inline">\(\lambda=3\)</span>，有<span class="math inline">\(3\pmb{I}-\pmb{A}=\left(\begin{matrix}-6&amp;0&amp;36\\ -6&amp;3&amp;27\\0&amp;-1&amp;3\end{matrix}\right)\sim\left(\begin{matrix}1&amp;0&amp;-6\\0&amp;1&amp;-3\\0&amp;0&amp;0\end{matrix}\right)\)</span>，所以其几何重数为<span class="math inline">\(3-r(3\pmb{I}-\pmb{A})=1\)</span>，所以特征值<span class="math inline">\(\lambda=3\)</span>对应的若尔当块的个数为<span class="math inline">\(1\)</span>；</p><p>第三步：对<span class="math inline">\(3\pmb{I}-\pmb{A}\)</span>有<span class="math inline">\(r[(3\pmb{I}-\pmb{A})^1]=2,r[(3\pmb{I}-\pmb{A})^2]=1,r[(3\pmb{I}-\pmb{A})^3]=0,r[(3\pmb{I}-\pmb{A})^4]=0\)</span>，所以该特征值对应的若尔当块的最大阶数为<span class="math inline">\(3\)</span>，所以<span class="math inline">\(\lambda=3\)</span>对应的一个三阶的若尔当块<span class="math inline">\(\pmb{J}(3,3)=\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)\)</span>或者<span class="math inline">\(\pmb{J}(3,3)=\left(\begin{matrix}3&amp;0&amp;0\\1&amp;3&amp;0\\0&amp;1&amp;3\end{matrix}\right)\)</span>，所以矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>对应的若尔当标准型为<span class="math inline">\(\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)\)</span>或者<span class="math inline">\(\left(\begin{matrix}3&amp;0&amp;0\\1&amp;3&amp;0\\0&amp;1&amp;3\end{matrix}\right)\)</span>.</p><p>由于本文主要讨论的是通过若尔当标准型求解矩阵的离散对数问题，所以就不再深入介绍若尔当标准型了。</p><p>在这一部分的最后，我们介绍sage中求方阵的若尔当标准型的方法，这个在后面也会用到：</p><p>在sage中有函数<code>jordan_form()</code>，其作用是返回<code>self</code>的若尔当标准型，其函数原型为<code>jordan_form(subdivide=True,transformation=False)</code>，其接收三个参数，分别为一个方阵<code>self</code>，一个布尔型变量<code>subdivide</code>（默认为<code>True</code>），一个布尔型变量<code>transformation</code>（默认为<code>False</code>）。</p><p>若<code>subdivide=True</code>，则返回的矩阵中会根据若尔当块进行分块标出.</p><p>若<code>transformation=True</code>，则会返回一个矩阵组<code>(J,P)</code>，其中<code>J</code>为<code>self</code>的若尔当标准型，而<code>P</code>为使得<span class="math inline">\(self=\pmb{P}\pmb{J}\pmb{P}^{-1}\)</span>成立的方阵；若<code>transformation=False</code>，则只会返回<code>self</code>的若尔当标准型<code>J</code>.</p><p>例：求矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>并求矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{A}\pmb{P}=\pmb{J}\)</span></p><p>sage代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sage: A = [[9,0,-36],[6,0,-27],[0,1,0]]</span><br><span class="line">sage: J,P = matrix(A).jordan_form(subdivide = False,transformation = True)</span><br><span class="line">sage: J</span><br><span class="line">[3 1 0]</span><br><span class="line">[0 3 1]</span><br><span class="line">[0 0 3]</span><br><span class="line">sage: P</span><br><span class="line">[36  6  1]</span><br><span class="line">[18  6  0]</span><br><span class="line">[ 6  0  0]</span><br><span class="line">sage: P^-1 * matrix(A) * P</span><br><span class="line">[3 1 0]</span><br><span class="line">[0 3 1]</span><br><span class="line">[0 0 3]</span><br></pre></td></tr></table></figure><p>可以得出矩阵<span class="math inline">\(\pmb{A}=\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\)</span>的若尔当标准型为<span class="math inline">\(\pmb{J}=\left(\begin{matrix}3&amp;1&amp;0\\0&amp;3&amp;1\\0&amp;0&amp;3\end{matrix}\right)\)</span>，且有矩阵<span class="math inline">\(\pmb{P}=\left(\begin{matrix}36&amp;6&amp;1\\18&amp;6&amp;0\\6&amp;0&amp;0\end{matrix}\right)\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{A}\pmb{P}=\pmb{J}\)</span>.</p><h2 id="第二部分利用若尔当标准型解决矩阵离散对数问题">第二部分：利用若尔当标准型解决矩阵离散对数问题</h2><p>在解决矩阵离散对数问题之前，我们先要了解何谓矩阵离散对数：在有限域<span class="math inline">\(GF(p)\)</span>（<span class="math inline">\(p\)</span>为质数）中，已知<span class="math inline">\(n\)</span>阶矩阵<span class="math inline">\(\pmb{G}\)</span>和<span class="math inline">\(\pmb{H}\)</span>，满足<span class="math inline">\(\pmb{G}^x=\pmb{H}\)</span>，求其中<span class="math inline">\(x\)</span>的问题即为矩阵的离散对数问题.</p><p>由上面的部分我们可以知道，对于矩阵<span class="math inline">\(\pmb{G}\)</span>，存在一个可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{G}=\pmb{P}\pmb{J}\pmb{P}^{-1}\)</span>，其中矩阵<span class="math inline">\(\pmb{J}\)</span>为<span class="math inline">\(\pmb{G}\)</span>对应的若尔当标准型，那么我们可以知道： <span class="math display">\[\pmb{G}^x=(\pmb{P}\pmb{J}\pmb{P}^{-1})(\pmb{P}\pmb{J}\pmb{P}^{-1})\cdots(\pmb{P}\pmb{J}\pmb{P}^{-1})=\pmb{P}\pmb{J}\pmb{P}^{-1}\pmb{P}\pmb{J}\pmb{P}^{-1}\cdots\pmb{P}\pmb{J}\pmb{P}^{-1}=\pmb{P}\pmb{J}^x\pmb{P}^{-1}\]</span> 其中： <span class="math display">\[\pmb{J}=\left(\begin{matrix}\pmb{J}_1&amp;&amp;&amp;\\&amp;\pmb{J}_2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\pmb{J}_s\end{matrix}\right)\]</span> （<span class="math inline">\(\pmb{J}_1,\pmb{J}_2,\cdots,\pmb{J}_s\)</span>均为若尔当块）</p><p>由于<span class="math inline">\(\pmb{J}\)</span>为准对角矩阵，我们有： <span class="math display">\[\pmb{J}^n=\left(\begin{matrix}\pmb{J}_1&amp;&amp;&amp;\\&amp;\pmb{J}_2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\pmb{J}_s\end{matrix}\right)^n=\left(\begin{matrix}\pmb{J}_1^n&amp;&amp;&amp;\\&amp;\pmb{J}_2^n&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\pmb{J}_s^n\end{matrix}\right)\]</span> 对于任意若尔当块 <span class="math display">\[\pmb{J}(\lambda,k)=\left(\begin{matrix}\lambda&amp;1&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\0&amp;\lambda&amp;1&amp;\cdots&amp;0&amp;0&amp;0\\0&amp;0&amp;\lambda&amp;\cdots&amp;0&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp; &amp;\vdots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;\lambda&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0&amp;\lambda\end{matrix}\right)_{k×k}\]</span> 而若尔当块可以分为两部分： <span class="math display">\[\pmb{J}(\lambda,k)=\pmb{\Lambda}+\pmb{E}=\left(\begin{matrix}\lambda&amp;&amp;&amp;\\&amp;\lambda&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;\lambda\end{matrix}\right)+\left(\begin{matrix}0&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;1&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right)\]</span> 所以 <span class="math display">\[\pmb{J}(\lambda,k)^n=(\pmb{\Lambda}+\pmb{E})^n=\sum_{m=0}^{n}\left(\begin{matrix}n\\m\end{matrix}\right)\pmb{\Lambda}^{n-m}\pmb{E}^m\]</span> 而我们很容易可以知道： <span class="math display">\[\pmb{E}=\left(\begin{matrix}0&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;1&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right),\pmb{E}^2=\left(\begin{matrix}0&amp;0&amp;1&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right),\cdots,\pmb{E}^{k-1}=\left(\begin{matrix}0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;0\end{matrix}\right),\pmb{E}^k=\pmb{O}\]</span> 所以<span class="math inline">\(\pmb{J}(\lambda,k)^n=\left(\begin{matrix}n\\0\end{matrix}\right)\pmb{\Lambda}^n+\left(\begin{matrix}n\\1\end{matrix}\right)\pmb{\Lambda}^{n-1}\pmb{E}+\cdots+\left(\begin{matrix}n\\k-1\end{matrix}\right)\pmb{\Lambda}^{n-k+1}\pmb{E}^{k-1}\)</span></p><p>可得： <span class="math display">\[\pmb{J}(\lambda,k)^n=\left[\begin{matrix}\lambda^n&amp;n\lambda^{n-1}&amp;\frac{n(n-1)}{2}\lambda^{n-2}&amp;\cdots&amp;\left(\begin{matrix}n\\k-2\end{matrix}\right)\lambda^{n-k+2}&amp;\left(\begin{matrix}n\\k-1\end{matrix}\right)\lambda^{n-k+1}\\0&amp;\lambda^n&amp;n\lambda^{n-1}&amp;\cdots&amp;\left(\begin{matrix}n\\k-3\end{matrix}\right)\lambda^{n-k+3}&amp;\left(\begin{matrix}n\\k-2\end{matrix}\right)\lambda^{n-k+2}\\0&amp;0&amp;\lambda^{n}&amp;\cdots&amp;\left(\begin{matrix}n\\k-4\end{matrix}\right)\lambda^{n-k+4}&amp;\left(\begin{matrix}n\\k-3\end{matrix}\right)\lambda^{n-k+3}\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;\lambda^{n}&amp;n\lambda^{n-1}\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;\lambda^{n}\end{matrix}\right]\]</span> 对于一般的矩阵离散对数问题，即给出有限域<span class="math inline">\(GF(p)\)</span>下两个矩阵<span class="math inline">\(\pmb{G}\)</span>和<span class="math inline">\(\pmb{H}\)</span>，求满足<span class="math inline">\(\pmb{G}^x=\pmb{H}\)</span>的整数<span class="math inline">\(x\)</span>，我们可以直接对比两个矩阵进行求解即可，大致步骤如下：</p><p>先求<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>并求可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}\)</span>，由于<span class="math inline">\(\pmb{H}=\pmb{G}^x=(\pmb{P}\pmb{J}\pmb{P}^{-1})^x=\pmb{P}\pmb{J}^{x}\pmb{P}^{-1}\)</span>，所以有<span class="math inline">\(\pmb{P}^{-1}\pmb{H}\pmb{P}=\pmb{J}^x\)</span>，取矩阵<span class="math inline">\(\pmb{J}\)</span>其中一个阶数大于等于<span class="math inline">\(2\)</span>的若尔当块<span class="math inline">\(\pmb{J}(\lambda,k)\)</span>，在矩阵<span class="math inline">\(\pmb{P}^{-1}\pmb{H}\pmb{P}\)</span>取该若尔当块对应区域中最后两行的最后一个元素，实际上就是<span class="math inline">\(\pmb{J}(\lambda,k)^x\)</span>最后两行中的<span class="math inline">\(\lambda^x\)</span>与<span class="math inline">\(x\lambda^{x-1}\)</span>（由上面的矩阵可以得知），从而有： <span class="math display">\[\frac{x\lambda^{x-1}}{\lambda^{x}}\equiv \frac{x}{\lambda}\equiv x\lambda^{-1}\pmod{p}\]</span> 由于我们知道该若尔当块对应的特征值<span class="math inline">\(\lambda\)</span>，所以我们就可以通过乘上一个<span class="math inline">\(\lambda\)</span>求出我们需要的<span class="math inline">\(x\)</span>.</p><p>举个例子，当<span class="math inline">\(p=31\)</span>时，在<span class="math inline">\(GF(p)\)</span>下有矩阵<span class="math inline">\(\pmb{G}=\left(\begin{matrix}17&amp;0&amp;6\\0&amp;3&amp;0\\9&amp;0&amp;18\end{matrix}\right)\)</span>，且有<span class="math inline">\(\pmb{H}=\pmb{G}^x=\left(\begin{matrix}25&amp;0&amp;3\\0&amp;28&amp;0\\20&amp;0&amp;10\end{matrix}\right)\)</span>，求<span class="math inline">\(x\)</span>.</p><p>先求出<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>及使得<span class="math inline">\(\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}\)</span>成立的矩阵<span class="math inline">\(\pmb{P}\)</span>如下（此处为了减少篇幅使用sage求两个矩阵）： <span class="math display">\[\pmb{J}=\left(\begin{matrix}3&amp;0&amp;0\\0&amp;2&amp;1\\0&amp;0&amp;2\end{matrix}\right),\pmb{P}= \left(\begin{matrix}0&amp;15&amp;1\\1&amp;0&amp;0\\0&amp;9&amp;0\end{matrix}\right)\]</span> 通过<span class="math inline">\(\pmb{P}\)</span>求出<span class="math inline">\(\pmb{J}^x=\pmb{P}^{-1}\pmb{H}\pmb{P}=\left(\begin{matrix}28&amp;0&amp;0\\0&amp;2&amp;16\\0&amp;0&amp;2\end{matrix}\right)\)</span>，由于<span class="math inline">\(\pmb{J}\)</span>中有一个2阶的若尔当块<span class="math inline">\(\left(\begin{matrix}2&amp;1\\0&amp;2\end{matrix}\right)\)</span>，其对应的<span class="math inline">\(\pmb{G}\)</span>的特征值为<span class="math inline">\(\lambda=2\)</span>，所以取<span class="math inline">\(\pmb{J}^x\)</span>中对应的块<span class="math inline">\(\left(\begin{matrix}2&amp;16\\0&amp;2\end{matrix}\right)\)</span>，有: <span class="math display">\[8\equiv x\lambda^{-1}\pmod{p}\]</span> 两边同乘一个<span class="math inline">\(\lambda=2\)</span>可得<span class="math inline">\(x\equiv16\pmod{31}\)</span>.</p><p>此类矩阵离散对数问题的求解代码模板如下（假设若尔当形矩阵<span class="math inline">\(\pmb{J}\)</span>最右下角一个若尔当块阶数大于<span class="math inline">\(2\)</span>）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = []</span><br><span class="line">H = []</span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">n = <span class="comment">#矩阵的阶数</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">M_H = matrix(GF(p),H)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">M_H_trans = P**-<span class="number">1</span> * M_H * P</span><br><span class="line"></span><br><span class="line">x = lambda0 * M_H_trans[n-<span class="number">2</span>][n-<span class="number">1</span>] * inverse(<span class="built_in">int</span>(M_H_trans[n-<span class="number">1</span>][n-<span class="number">1</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一种类型的矩阵离散对数问题，即为给出<span class="math inline">\(GF(p)\)</span>下的矩阵<span class="math inline">\(\pmb{G}\)</span>及一个初始向量<span class="math inline">\(\pmb{v}\)</span>，且给出<span class="math inline">\(\pmb{y}=\pmb{G}^x\pmb{v}\)</span>，求<span class="math inline">\(x\)</span>.对于这种类型的矩阵离散对数的求解大致步骤如下：</p><p>设<span class="math inline">\(\pmb{v}=\left(v_1,v_2,\cdots,v_n\right)^T,\pmb{y}=\left(y_1,y_2,\cdots,y_n\right)^T\)</span>，求出矩阵<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>并求可逆矩阵<span class="math inline">\(\pmb{P}\)</span>使得<span class="math inline">\(\pmb{P}^{-1}\pmb{G}\pmb{P}=\pmb{J}\)</span>.为方便解释，在这里我们假定<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{P}\)</span>的最右下角的若尔当块阶数大于等于<span class="math inline">\(2\)</span>（实际上，一个矩阵的若尔当标准型可以通过若尔当块的顺序来变成该矩阵的另外一个若尔当标准型）.</p><p>所以有： <span class="math display">\[\pmb{G}^x\pmb{v}=\pmb{P}\pmb{J}^x\pmb{P}^{-1}\pmb{v}=\pmb{y}\]</span> 设<span class="math inline">\(\pmb{t}=\pmb{P}^{-1}\pmb{v}，\pmb{z}=\pmb{P}^{-1}\pmb{y}\)</span>，就可以得到：<span class="math inline">\(\pmb{P}\pmb{J}^x\pmb{t}=\pmb{P}\pmb{z}\)</span>，而由于矩阵<span class="math inline">\(\pmb{P}\)</span>可逆，则有<span class="math inline">\(\pmb{J}^x\pmb{t}=\pmb{z}\)</span>.</p><p>由于我们已知<span class="math inline">\(\pmb{v}\)</span>及<span class="math inline">\(\pmb{y}\)</span>，所以我们可以通过<span class="math inline">\(\pmb{P}\)</span>求出<span class="math inline">\(\pmb{t}\)</span>及<span class="math inline">\(\pmb{z}\)</span>，在这里我们设<span class="math inline">\(\pmb{t}=\left(t_1,t_2,\cdots,t_n\right)^T,\pmb{z}=\left(z_1,z_2,\cdots,z_n\right)^T\)</span>，由于上面我们假设了<span class="math inline">\(\pmb{J}\)</span>最右下角的若尔当块的阶数大于等于<span class="math inline">\(2\)</span>，在这里我们假设它对应的特征值为<span class="math inline">\(\lambda\)</span>，就可以得出若尔当标准型<span class="math inline">\(\pmb{J}\)</span>最后两行对应的线性关系为： <span class="math display">\[\begin{cases}\lambda^{x}t_{n-1}&amp;+&amp;x\lambda^{x-1}t_n&amp;\equiv&amp;z_{n-1}&amp;\pmod{p}\\&amp;&amp;\lambda^xt_n&amp;\equiv&amp;z_n&amp;\pmod{p}\end{cases}\]</span> 我们可以知道<span class="math inline">\(\lambda^{x}\equiv\frac{z_n}{t_n}\pmod{p}\)</span>，代入第一行的式子可以得到： <span class="math display">\[\frac{z_nt_{n-1}}{t_n}+\frac{xz_n}{\lambda}\equiv z_{n-1}\pmod{p}\]</span> 整理可得： <span class="math display">\[x\equiv\frac{\lambda(z_{n-1}t_n-z_nt_{n-1})}{t_nz_n}\pmod{p}\]</span> 这样我们就可以求出我们要求的<span class="math inline">\(x\)</span>了.</p><p>例如，当<span class="math inline">\(p=31\)</span>时，在<span class="math inline">\(GF(p)\)</span>下有矩阵<span class="math inline">\(\pmb{G}=\left(\begin{matrix}17&amp;0&amp;6\\0&amp;3&amp;0\\9&amp;0&amp;18\end{matrix}\right)\)</span>，且有<span class="math inline">\(\pmb{v}=(1,2,3)^T\)</span>，有<span class="math inline">\(\pmb{G}^x\pmb{v}=\pmb{y}=(13,30,25)^T\)</span>，求<span class="math inline">\(x\)</span>.</p><p>这个矩阵<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型<span class="math inline">\(\pmb{J}\)</span>和对应的矩阵<span class="math inline">\(\pmb{P}\)</span>在上面已经求出，所以这里我们直接搬下来用： <span class="math display">\[\pmb{J}=\left(\begin{matrix}3&amp;0&amp;0\\0&amp;2&amp;1\\0&amp;0&amp;2\end{matrix}\right),\pmb{P}= \left(\begin{matrix}0&amp;15&amp;1\\1&amp;0&amp;0\\0&amp;9&amp;0\end{matrix}\right)\]</span> 所以有<span class="math inline">\(\pmb{t}=\pmb{P}^{-1}\pmb{v}=(2,21,27)^T，\pmb{z}=\pmb{P}^{-1}\pmb{y}=(30,20,23)^T\)</span>，而矩阵<span class="math inline">\(\pmb{J}\)</span>的最右下角的若尔当块对应的特征值<span class="math inline">\(\lambda=2\)</span>，所以有： <span class="math display">\[x\equiv\frac{\lambda(z_{2}t_3-z_3t_{2})}{t_3z_3}\equiv\frac{2\cdot(20\cdot27-23\cdot21)}{27\cdot23}\equiv21\pmod{31}\]</span> 所以可以得出要求的<span class="math inline">\(x = 21\)</span>.</p><p>此类矩阵离散对数问题的求解代码模板如下（假设若尔当形矩阵<span class="math inline">\(\pmb{J}\)</span>最右下角一个若尔当块阶数大于<span class="math inline">\(2\)</span>）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = []</span><br><span class="line">V = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line">p = <span class="number">31</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">v = matrix(GF(p),V)</span><br><span class="line">y = matrix(GF(p),Y)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line">t = P**-<span class="number">1</span> * v</span><br><span class="line">z = P**-<span class="number">1</span> * y</span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x = lambda0 * (t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">2</span>][<span class="number">0</span>] - t[n-<span class="number">2</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]) * inverse(<span class="built_in">int</span>(t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>还有一种特殊情况就是<span class="math inline">\(\pmb{G}^x=\pmb{H}\)</span>中<span class="math inline">\(\pmb{G}\)</span>的若尔当标准型为对角矩阵.这种情况实际上只需要求出<span class="math inline">\(\pmb{G}\)</span>的标准型<span class="math inline">\(\pmb{J}\)</span>与其对应的<span class="math inline">\(\pmb{P}\)</span>之后，通过<span class="math inline">\(\pmb{P}^{-1}\pmb{H}\pmb{P}\)</span>求出<span class="math inline">\(\pmb{J}^x\)</span>，再通过求解整数的离散对数问题的方法求解就行（实际上应该只有这一种方法）.</p><p>下面通过一道题展示一下矩阵离散对数在密码学上的应用：</p><h3 id="xyctf2024fakersa">[XYCTF2024]fakeRSA</h3><p>加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;XYCTF&#123;******&#125;&#x27;</span></span><br><span class="line">n = ZZ(bytes_to_long(flag))</span><br><span class="line">p = getPrime(<span class="built_in">int</span>(<span class="number">320</span>))</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line">G = Zmod(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">X, Y, Z</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">part</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> vector([<span class="number">9</span> * a - <span class="number">36</span> * c, <span class="number">6</span> * a - <span class="number">27</span> * c, b])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parts</span>(<span class="params">n</span>):</span><br><span class="line">        Gx.&lt;a, b, c&gt; = G[]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> vector([a, b, c])</span><br><span class="line">        mid = parts(n // <span class="number">2</span>)</span><br><span class="line">        result = mid(*mid)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> part(*result)</span><br><span class="line">    <span class="keyword">return</span> parts(n)(X, Y, Z)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(function(<span class="number">69</span>, <span class="number">48</span>, <span class="number">52</span>))</span><br><span class="line"><span class="comment">#输出数据略</span></span><br></pre></td></tr></table></figure><p>由代码可以看出function的作用是在<span class="math inline">\(GF(p)\)</span>中对向量<span class="math inline">\((X,Y,Z)^T\)</span>进行<span class="math inline">\(n\)</span>次变换<span class="math inline">\((X&#39;,Y&#39;,Z&#39;)^T=(9X-36Z,6X-27Z,Y)^T\)</span>后得到输出的向量，写出变换的矩阵形式如下： <span class="math display">\[\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)\left(\begin{matrix}X\\Y\\Z\end{matrix}\right)=\left(\begin{matrix}X&#39;\\Y&#39;\\Z&#39;\end{matrix}\right)\]</span> 设原向量为<span class="math inline">\((x_1,x_2,x_3)^T\)</span>，最终向量为<span class="math inline">\((y_1,y_2,y_3)^T\)</span>，则有： <span class="math display">\[\left(\begin{matrix}9&amp;0&amp;-36\\6&amp;0&amp;-27\\0&amp;1&amp;0\end{matrix}\right)^n\left(\begin{matrix}x_1\\x_2\\x_3\end{matrix}\right)=\left(\begin{matrix}y_1\\y_2\\y_3\end{matrix}\right)\]</span> 通过上面介绍的方法求解即可得出<span class="math inline">\(n\)</span>，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">G = [[<span class="number">9</span>,<span class="number">0</span>,-<span class="number">36</span>],[<span class="number">6</span>,<span class="number">0</span>,-<span class="number">27</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">V = [[<span class="number">69</span>],[<span class="number">48</span>],[<span class="number">52</span>]]</span><br><span class="line">Y = ...<span class="comment">#题目中输出的向量</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">1849790472911267366045392456893126092698743308291512220657006129900961168811898822553602045875909</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">M_G = matrix(GF(p),G)</span><br><span class="line">v = matrix(GF(p),V)</span><br><span class="line">y = matrix(GF(p),Y)</span><br><span class="line"></span><br><span class="line">J, P = M_G.jordan_form(subdivide = <span class="literal">False</span>,transformation = <span class="literal">True</span>)</span><br><span class="line">t = P**-<span class="number">1</span> * v</span><br><span class="line">z = P**-<span class="number">1</span> * y</span><br><span class="line">lambda0 = J[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x = lambda0 * (t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">2</span>][<span class="number">0</span>] - t[n-<span class="number">2</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]) * inverse(<span class="built_in">int</span>(t[n-<span class="number">1</span>][<span class="number">0</span>]*z[n-<span class="number">1</span>][<span class="number">0</span>]),p) % p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(x)))</span><br></pre></td></tr></table></figure><p>运行可得结果：<code>XYCTF&#123;y0u_finally_f0und_t3h_s3cr3ts!!&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 高等代数笔记 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XYCTF2024-疯狂大杂烩！九转功成复现WP</title>
      <link href="/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/"/>
      <url>/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p>你能突破九大关卡修成神仙吗？</p><p>hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！</p><p>hint2：flag格式：XYCTF{md5(flag)}</p><p>hint3：第三层非夏多，看看交点</p><p>hint4：第六层键盘画图，狼蛛键盘最新版你值得拥有！</p><h1 id="开头">开头</h1><p>由提示猜测压缩包密码XYCTF20240401</p><h1 id="炼气">炼气</h1><p>第一层是天书加密，用随波逐流就可以解出压缩包密码。</p><p>第二层是一张图片，修改高就可以看到flag的第一部分：</p><blockquote><p>XYCTF{T3e_c0mb1nation_</p></blockquote><h1 id="筑基">筑基</h1><p>第一层是<strong>BubbleBabble</strong>编码，<a href="http://www.hiencode.com/bubble.html">在线解码</a>就能解出压缩包密码。</p><p>第二层是一张图片，010看不出什么东西，用StegSolve通过LSB可以找到一串Base64编码，解码可得flag第二部分：</p><blockquote><p>0f_crypt0_and_</p></blockquote><h1 id="结丹全复现">结丹（全复现）</h1><p>给出一张图片</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281730505.jpg" alt="hint3" /><figcaption>hint3</figcaption></figure><p>hint说看交点，可能跟Begin CTF 2023的下一站上岸差不多，四个交点为”-”，三个交点为空格，一个交点为”.”，可以转化为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- .... . ..--.- - .... .. .-. -..</span><br></pre></td></tr></table></figure><p>摩斯密码解码就可以得到压缩包的密码</p><p>打开压缩包发现还有一层压缩包和一个txt，文本文件里面没有有用信息，但是压缩包带密码，用010打开看看，看到末尾有一段附加信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828487.png" alt="image-20240428173027310" /><figcaption>image-20240428173027310</figcaption></figure><p>分析特征，显然是Base64，解码之后可以得到压缩包密码，解压发现里面有一个文本文件，由特征可知是Base32，解码就可以得到flag的第三部分。</p><blockquote><p>misc_1s_re6lly_fun!!</p></blockquote><h1 id="元婴">元婴</h1><p>hint4.txt打开一看发现是base64，解密一看salted，用这个网站解密：<a href="https://www.sojson.com/encrypt_triple_des.html">在线Triple DES加密 | Triple DES解密- 在线工具 (sojson.com)</a>（一个个试出来的），密码是2024.</p><p>拿密码打开压缩包，有个hint.txt和一个db文件，hint内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wqk：1m813onn17o040358p772q37rm137qpnqppqpn38nr704m56n2m9q22po7r05r77</span><br></pre></td></tr></table></figure><p>进行一个凯撒解密就可以得到一个key，</p><p>下面是在52上面找到的一个解密微信聊天数据库的脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> hashlib, hmac, ctypes</span><br><span class="line"></span><br><span class="line">SQLITE_FILE_HEADER = <span class="built_in">bytes</span>(<span class="string">&quot;SQLite format 3&quot;</span>,encoding=<span class="string">&#x27;ASCII&#x27;</span>) + <span class="built_in">bytes</span>(<span class="number">1</span>)<span class="comment">#文件头</span></span><br><span class="line">IV_SIZE = <span class="number">16</span></span><br><span class="line">HMAC_SHA1_SIZE = <span class="number">20</span></span><br><span class="line">KEY_SIZE = <span class="number">32</span></span><br><span class="line">DEFAULT_PAGESIZE = <span class="number">4096</span> <span class="comment">#4048数据 + 16IV + 20 HMAC + 12</span></span><br><span class="line">DEFAULT_ITER = <span class="number">64000</span></span><br><span class="line"><span class="comment">#yourkey</span></span><br><span class="line">password = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;...&quot;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="comment">#这里填入上面求出的key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\MSG0.db&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#这里填入MSG0.db的文件路径</span></span><br><span class="line">    blist = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(blist))</span><br><span class="line"></span><br><span class="line">salt = blist[:<span class="number">16</span>]<span class="comment">#微信将文件头换成了盐</span></span><br><span class="line">key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, password, salt, DEFAULT_ITER, KEY_SIZE)<span class="comment">#获得Key</span></span><br><span class="line"></span><br><span class="line">first = blist[<span class="number">16</span>:DEFAULT_PAGESIZE]<span class="comment">#丢掉salt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import struct</span></span><br><span class="line">mac_salt = <span class="built_in">bytes</span>([x^<span class="number">0x3a</span> <span class="keyword">for</span> x <span class="keyword">in</span> salt])</span><br><span class="line">mac_key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, key, mac_salt, <span class="number">2</span>, KEY_SIZE)</span><br><span class="line"></span><br><span class="line">hash_mac = hmac.new(mac_key ,digestmod = <span class="string">&#x27;sha1&#x27;</span>)<span class="comment">#用第一页的Hash测试一下</span></span><br><span class="line">hash_mac.update(first[:-<span class="number">32</span>])</span><br><span class="line">hash_mac.update(<span class="built_in">bytes</span>(ctypes.c_int(<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># hash_mac.update(struct.pack(&#x27;=I&#x27;,1))</span></span><br><span class="line"><span class="keyword">if</span> (hash_mac.digest() == first[-<span class="number">32</span>:-<span class="number">12</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Correct Password&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Wrong Password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">blist = [blist[i:i+DEFAULT_PAGESIZE] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_PAGESIZE,<span class="built_in">len</span>(blist),DEFAULT_PAGESIZE)]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\ChatMsg.db&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#解密后的路径</span></span><br><span class="line">    f.write(SQLITE_FILE_HEADER)<span class="comment">#写入文件头</span></span><br><span class="line">    t = AES.new(key ,AES.MODE_CBC ,first[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">    f.write(t.decrypt(first[:-<span class="number">48</span>]))</span><br><span class="line">    f.write(first[-<span class="number">48</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blist:</span><br><span class="line">            t = AES.new(key ,AES.MODE_CBC ,i[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">            f.write(t.decrypt(i[:-<span class="number">48</span>]))</span><br><span class="line">            f.write(i[-<span class="number">48</span>:])</span><br></pre></td></tr></table></figure><p>用打开数据库的软件打开解密之后的数据库（我用的Dbeaver），在MSG表里面就可以看到flag的第四部分：</p><blockquote><p>L1u_and_K1cky_Mu</p></blockquote><h1 id="化神第二部分复现">化神（第二部分复现）：</h1><p>hint5给出了一串字符和md5后的结果，进行爆破，爆破出压缩包密码，解压<code>第五层.zip</code> 看到flag.txt里面没有有用的东西.</p><p>serpent.txt文件里有东西，考虑serpent加密，用这个网站<a href="http://serpent.online-domain-tools.com/">Serpent Encryption – Easily encrypt or decrypt strings or files (online-domain-tools.com)</a></p><p>通过文件输入，从头到尾没有密钥，猜测密钥是前面爆破得到的key，解密之后下载下来塞进Cyberchef可以看到</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828521.png" alt="image-20240428172659005" /><figcaption>image-20240428172659005</figcaption></figure><p>导出为txt并转换编码为UTF-8后可以得到：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726731.png" alt="image-20240428172642676" /><figcaption>image-20240428172642676</figcaption></figure><p>字数比可以看到的多很多，考虑零宽字符隐写：</p><p>将文本转化为unicode编码后：</p><figure><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726082.png" alt="image-20240428172606982" /><figcaption>image-20240428172606982</figcaption></figure>筛选发现，里面包含零宽unicode字符]]></content>
      
      
      <categories>
          
          <category> Write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicoCTF2024 Crypto部分WP</title>
      <link href="/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/"/>
      <url>/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/</url>
      
        <content type="html"><![CDATA[<h2 id="感想">感想</h2><p>这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.</p><h2 id="interencdec">interencdec</h2><p>签到题</p><p>密文如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YidkM0JxZGtwQlRYdHFhR3g2YUhsZmF6TnFlVGwzWVROclgyZzBOMm8yYXpZNWZRPT0nCg==</span><br></pre></td></tr></table></figure><p>显然是Base64编码，解码得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;d3BqdkpBTXtqaGx6aHlfazNqeTl3YTNrX2g0N2o2azY5fQ==&#x27;</span><br></pre></td></tr></table></figure><p>去除<strong>b''</strong>之后进行Base64解码结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wpjvJAM&#123;jhlzhy_k3jy9wa3k_h47j6k69&#125;</span><br></pre></td></tr></table></figure><p>进行一次偏移量为7的凯撒解密可以得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;caesar_d3cr9pt3d_a47c6d69&#125;</span><br></pre></td></tr></table></figure><h2 id="custom-encryption">Custom encryption</h2><p>题目给出加密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">g, x, p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(g, x) % p<span class="comment">#实际上就是pow(g,x,p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    cipher = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> plaintext:</span><br><span class="line">        cipher.append(((<span class="built_in">ord</span>(char) * key*<span class="number">311</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">p</span>):</span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, p + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p % i == <span class="number">0</span>:</span><br><span class="line">            v = v + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_xor_encrypt</span>(<span class="params">plaintext, text_key</span>):</span><br><span class="line">    cipher_text = <span class="string">&quot;&quot;</span></span><br><span class="line">    key_length = <span class="built_in">len</span>(text_key)</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(plaintext[::-<span class="number">1</span>]):<span class="comment">#将字符串反转后异或加密</span></span><br><span class="line">        key_char = text_key[i % key_length]</span><br><span class="line">        encrypted_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="built_in">ord</span>(key_char))</span><br><span class="line">        cipher_text += encrypted_char</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">plain_text, text_key</span>):</span><br><span class="line">    p = <span class="number">97</span></span><br><span class="line">    g = <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_prime(p) <span class="keyword">and</span> <span class="keyword">not</span> is_prime(g):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enter prime numbers&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a = randint(p-<span class="number">10</span>, p)</span><br><span class="line">    b = randint(g-<span class="number">10</span>, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line">    u = generator(g, a, p)</span><br><span class="line">    v = generator(g, b, p)</span><br><span class="line">    key = generator(v, a, p)</span><br><span class="line">    b_key = generator(u, b, p)</span><br><span class="line">    shared_key = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> key == b_key:</span><br><span class="line">        shared_key = key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)</span><br><span class="line">    cipher = encrypt(semi_cipher, shared_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;cipher is: <span class="subst">&#123;cipher&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    test(message, <span class="string">&quot;trudeau&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目给出的另一个附件如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 89</span><br><span class="line">b = 27</span><br><span class="line">cipher is: [33588, 276168, 261240, 302292, 343344, 328416, 242580, 85836, 82104, 156744, 0, 309756, 78372, 18660, 253776, 0, 82104, 320952, 3732, 231384, 89568, 100764, 22392, 22392, 63444, 22392, 97032, 190332, 119424, 182868, 97032, 26124, 44784, 63444]</span><br></pre></td></tr></table></figure><h3 id="分析">分析</h3><p>分析代码可以知道有一个<code>share_key</code>，把它求出来（很简单，不知道他为什么要把<code>pow(a,b,p)</code>包装成一个新的函数）然后通过<code>cipher</code>里面每一个元素除以<code>share_key</code>和311得到一个串，跟<code>text_key</code>进行一个异或（<code>dynamic_xor_encrypt</code>）再对得到的<code>plaintext</code>进行反转。</p><h3 id="解题">解题</h3><p>先求<code>share_key</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br></pre></td></tr></table></figure><p>求出<code>share_key</code>之后就可以将<code>cipher</code>除以<code>share_key</code>和311得到一个串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = [x//shared_key//<span class="number">311</span> <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br></pre></td></tr></table></figure><p>将<code>temp</code>与<code>text_key</code>进行一个异或，其中<code>text_key=&quot;trudeau&quot;</code>得到一字符串后反转就可以得到flag：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>总体代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">97</span></span><br><span class="line">g = <span class="number">31</span></span><br><span class="line">a = <span class="number">89</span></span><br><span class="line">b = <span class="number">27</span></span><br><span class="line">cipher = [<span class="number">33588</span>, <span class="number">276168</span>, <span class="number">261240</span>, <span class="number">302292</span>, <span class="number">343344</span>, <span class="number">328416</span>, <span class="number">242580</span>, <span class="number">85836</span>, <span class="number">82104</span>, <span class="number">156744</span>, <span class="number">0</span>, <span class="number">309756</span>, <span class="number">78372</span>, <span class="number">18660</span>, <span class="number">253776</span>, <span class="number">0</span>, <span class="number">82104</span>, <span class="number">320952</span>, <span class="number">3732</span>, <span class="number">231384</span>, <span class="number">89568</span>, <span class="number">100764</span>, <span class="number">22392</span>, <span class="number">22392</span>, <span class="number">63444</span>, <span class="number">22392</span>, <span class="number">97032</span>, <span class="number">190332</span>, <span class="number">119424</span>, <span class="number">182868</span>, <span class="number">97032</span>, <span class="number">26124</span>, <span class="number">44784</span>, <span class="number">63444</span>]</span><br><span class="line"></span><br><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br><span class="line"></span><br><span class="line">temp = [<span class="built_in">chr</span>(x//shared_key//<span class="number">311</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;custom_d2cr0pt6d_dc499538&#125;</span><br></pre></td></tr></table></figure><h2 id="c3">C3</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">  chars += line</span><br><span class="line"></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">  cur = lookup1.index(char)</span><br><span class="line">  out += lookup2[(cur - prev) % <span class="number">40</span>]</span><br><span class="line">  prev = cur</span><br><span class="line"></span><br><span class="line">sys.stdout.write(out)</span><br></pre></td></tr></table></figure><p>题目给出的另外一个附件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl</span><br></pre></td></tr></table></figure><p>可以知道附件是<code>chars</code>加密得到的，分析代码后写出解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br></pre></td></tr></table></figure><p>运行代码可得：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#asciiorder</span></span><br><span class="line"><span class="comment">#fortychars</span></span><br><span class="line"><span class="comment">#selfinput</span></span><br><span class="line"><span class="comment">#pythontwo</span></span><br><span class="line"></span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">    chars += line</span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span> chars[i] <span class="comment">#prints</span></span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>会发现解出来是一串缺少参数<code>chars</code>内容的代码，猜测这里的<code>chars</code>就是上面求解出来的<code>chars</code>，拼接上一条代码再进行修改后得到如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span>(chars[i],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行得到的字符串包裹上<code>picoCTF&#123;&#125;</code>即可得到flag：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picoCTF&#123;adlibs&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa_oracle">rsa_oracle</h2><p>这道题考点较多，但是算是模板题，所以难度不算高.</p><h3 id="分析-1">分析</h3><p>首先题目给了个预言机（Oracle），通过交互我们可以发现可以通过这个Oracle对一些东西进行加密或者解密，而文件中给出了一个password.enc文件，从题目描述中的“<strong>After some intensive reconassainance they found out that the bank has an oracle that was used to encrypt the password</strong>”可以知道password.enc里面的数据是通过Oracle中内置的RSA的参数进行加密的，但是我们并不能将password.enc的数据直接丢进Oracle里面得到password，故我们考虑使用选择密文攻击得到password。得到password之后，我们通过<strong>hint2：OpenSSL can be used to decrypt the message. e.g <code>openssl enc -aes-256-cbc -d ...</code></strong> （或者通过message.enc里面的格式）可以知道需要通过OpenSSL解密message.enc得到flag，而密码就是password.enc解密得到的。</p><h3 id="解题-1">解题</h3><h4 id="第一步先通过选择明文攻击得到oracle中的rsa加密的参数">第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数</h4><p>由RSA的原理，我们可以得到以下式子： <span class="math display">\[2^e\equiv c_2\pmod{n}\\4^e\equiv c_4\pmod{n}\\8^e\equiv c_8\pmod{n}\]</span> 可得： <span class="math display">\[c_2^2\equiv c_4\pmod{n}\\c_2^3\equiv c_8\pmod{n}\]</span> 即： <span class="math display">\[c_2^2-c_4=k_1n\\c_2^3-c_8=k_2n\]</span> 在一般情况下，有<span class="math inline">\((c_2^2-c_4,c_2^3-c_8)=n\)</span></p><p>自此，我们得到了<span class="math inline">\(n\)</span>，现在要得到<span class="math inline">\(e\)</span>，猜测<span class="math inline">\(e\)</span>小于<span class="math inline">\(100000\)</span>，使用上面求出的<span class="math inline">\(c_2\)</span>（或者<span class="math inline">\(c_4,c_8\)</span>）进行爆破，就得到了<span class="math inline">\(e\)</span>。</p><p>该步代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;地址&quot;</span>,端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(2,e,n)</span></span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">2</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c2 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(4,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">4</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c4 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(8,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">8</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c8 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line">n = gmpy2.gcd(c2**<span class="number">2</span>-c4,c2**<span class="number">3</span>-c8)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">2</span>,e,n)==c2:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h4 id="第二步通过选择密文攻击得到passwordopenssl中用于解密的key">第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）</h4><p>由于不能直接解密password（后面将里面的数记为<span class="math inline">\(c\)</span>），而从一般通过Oracle选择密文攻击的题目，我们可以知道他应该也不能解密<span class="math inline">\(c+kn,k\in Z\)</span>，我们考虑通过解密<span class="math inline">\(c*s^e\ mod\ n\)</span>来得到我们需要的东西。</p><p>解密之后可以得到<span class="math inline">\(s\)</span>倍的<span class="math inline">\(m\)</span>（这里<span class="math inline">\(m\)</span>就是解密后的<code>password</code>），乘上<span class="math inline">\(inv(s,n)\)</span>再模<span class="math inline">\(n\)</span>（这里<span class="math inline">\(inv(a,b)\)</span>表示<span class="math inline">\(a\)</span>模<span class="math inline">\(b\)</span>的乘法逆元）就可以还原出<code>password</code>了（需要<code>long_to_bytes</code>）</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(<span class="built_in">str</span>(c*<span class="built_in">pow</span>(<span class="number">2</span>,e,n)%n).encode())</span><br></pre></td></tr></table></figure><h4 id="第三步">第三步</h4><p>通过OpenSSL对message.enc通过<code>aes_256_cbc</code>算法进行解密，命令大致如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl enc <span class="literal">-aes-256-cbc</span> <span class="literal">-d</span> <span class="operator">-in</span> (这里是message.enc的路径) <span class="literal">-out</span> flag.txt <span class="literal">-k</span> (这里是password)</span><br></pre></td></tr></table></figure><p>就可以得到flag了.</p><h2 id="flag_printer">flag_printer</h2><p>算法优化题，卡了好久，感觉这题不应该出现在Cryptography里面.</p><p>题目给出了一个30.8MB的文本文件，里面有1769611组数，还给出了一个python源码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> galois</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">MOD = <span class="number">7514777789</span></span><br><span class="line"></span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;encoded.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read().strip().split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    x, y = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    points.append((<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)))</span><br><span class="line"></span><br><span class="line">GF = galois.GF(MOD)</span><br><span class="line"></span><br><span class="line">matrix = []</span><br><span class="line">solution = []</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    x, y = point</span><br><span class="line">    solution.append(GF(y % MOD))</span><br><span class="line"></span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        row.append(GF(x**i%MOD))</span><br><span class="line"></span><br><span class="line">    matrix.append(GF(row))</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.bmp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="built_in">bytearray</span>(np.linalg.solve(GF(matrix), GF(solution)).tolist()[:-<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由代码可以知道我们需要求解如下方程： <span class="math display">\[\left[\begin{matrix}x_0^0&amp;x_0^1&amp;x_0^2&amp;\cdots&amp;x_0^{n-1}\\x_1^0&amp;x_1^1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1}\\x_2^0&amp;x_2^1&amp;x_2^2&amp;\cdots&amp;x_2^{n-1}\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_{n-1}^0&amp;x_{n-1}^1&amp;x_{n-1}^2&amp;\cdots&amp;x_{n-1}^{n-1}\\\end{matrix}\right]\left[\begin{matrix}\alpha_0\\\alpha_1\\\alpha_2\\\vdots\\\alpha_{n-1}\end{matrix}\right]=\left[\begin{matrix}y_0\\y_1\\y_2\\\vdots\\y_{n-1}\end{matrix}\right]\]</span> 可以看到，左式的<span class="math inline">\(n\times n\)</span>矩阵是一个范德蒙德矩阵，所以优先考虑范德蒙德方程组求解，找到<strong>Björck-Pereyra算法</strong>，后面发现在Python中需要分配11.4TB的内存，并不能解决问题。</p><p>再观察矩阵可以发现对于任意<span class="math inline">\(x_i(i=0,1,2,\cdots,n-1)\)</span>，有：<span class="math inline">\(\alpha_0x_i^0+\alpha_1x_i^1+\alpha_2x_i^2+\cdots+\alpha_{n-1}x_i^{n-1}=y_i\)</span></p><p>可以知道，这显然可以利用拉格朗日插值法，得到的函数应为：<span class="math inline">\(f(x)=\alpha_0x^0+\alpha_1x^1+\alpha_2x^2+\cdots+\alpha_{n-1}x^{n-1}\)</span></p><p>但是一般的拉格朗日插值法时间复杂度太高，不能达到我想要的效果（实际上如果是硬跑的话还是可以跑出flag的），故考虑FFT（快速傅里叶变换），但是可惜的是我对算法的学习不深，并不知道怎么写FFT.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连分数（Continued Fractions）笔记</title>
      <link href="/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）</em></p></blockquote><h2 id="连分数的定义">连分数的定义</h2><p>形如： <span class="math display">\[a_1+\frac{1}{a_2+\frac{1}{\begin{matrix}a_3+\\&amp;&amp;\ddots\\&amp;&amp;&amp;&amp;+\frac{1}{a_n}\end{matrix}}}\tag{1}\]</span> 的分数被称作连分数。</p><p>在平常的使用中，为了节省篇幅，我们一般使用以下符号来表示上述连分数： <span class="math display">\[a_1+\frac{1}{a_2+}\frac{1}{a_3+}\frac{1}{a_4+}\cdots\frac{1}{a_n}或[a_1,a_2,\cdots ,a_n]\]</span> 其中第二种表示方式最常用。</p><h2 id="有关连分数的一些定理定义">有关连分数的一些定理&amp;定义</h2><h3 id="定义1连分数的渐进分数">定义1（连分数的渐进分数）：</h3><p><span class="math inline">\([a_1,a_2,\cdots ,a_k]=\frac{p_k}{q_k}\ (1\le k\le n)\)</span>叫做连分数<span class="math inline">\((1)\)</span>的第<span class="math inline">\(k\)</span>个<strong>渐进分数</strong></p><h3 id="定义2简单连分数">定义2（简单连分数）：</h3><p>若<span class="math inline">\(a_1\)</span>是整数，<span class="math inline">\(a_2,a_3,\cdots,a_k,\cdots\)</span>是正整数，则连分数 <span class="math display">\[[a_1,a_2,\cdots,a_k,\cdots]\]</span> 称为<strong>简单连分数</strong>，若<span class="math inline">\(a\)</span>的个数有限，则称为<strong>有限简单连分数</strong>，若<span class="math inline">\(a\)</span>的个数无限，则称为<strong>无限简单连分数</strong>.</p><p>对于无限连分数，若当<span class="math inline">\(k→∞\)</span>时<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>的渐进分数<span class="math inline">\(\frac{p_k}{q_k}\)</span>存在极限，则称这个极限为<strong>连分数<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>的值.</strong></p><h3 id="定义3循环连分数">定义3（循环连分数）：</h3><p>对于一个无限连分数<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>，如果能找到两个整数<span class="math inline">\(s\ge0,t&gt;0\)</span>使得 <span class="math display">\[a_{s+i}=a_{s+kt+i},\ \ \ i=1,2,\cdots,t;\ \ \ \ k=0,1,2,\cdots\]</span> 这个无限简单连分数就叫<strong>循环连分数</strong>，并简单地把它记作 <span class="math display">\[[a_1,a_2, \cdots ,a_s,a_{s+1},\cdots ,a_{s+t}]\]</span></p><h3 id="定理1">定理1：</h3><p>若连分数<span class="math inline">\([a_1,a_2,\cdots ,a_n]\)</span>的渐进分数是<span class="math inline">\(\frac{p_1}{q_1},\frac{p_2}{q_2},\cdots ,\frac{p_n}{q_n}\)</span>，则在这些渐进分数之间，下列关系成立： <span class="math display">\[\begin{matrix}p_1=a_1,p_2=a_2a_1+1&amp;p_k=a_kp_{k-1}+p_{k-2},\\ q_1=1,q_2=a_2\ \ \ \ \ \ \ \ \ \ \ \ \ &amp;q_k=a_kq_{k-1}+q_{k-2},\end{matrix}\cdots,\ \ \ 3\le k\le n\]</span></p><h3 id="定理2">定理2：</h3><p>若连分数<span class="math inline">\([a_1,a_2,\cdots ,a_n]\)</span>的<span class="math inline">\(n\)</span>个渐进连分数是<span class="math inline">\(\frac{p_k}{q_k},k=1,2,\cdots,n\)</span>，则下列两关系成立： <span class="math display">\[\begin{flalign}&amp;(1)\ \ p_kq_{k-1}-p_{k-1}q_k=(-1)^k,\ \ \ \ \ \ \ \ \ \ k\ge 2\\ &amp;(2)\ \ p_kq_{k-2}-p_{k-2}q_k=(-1)^{k-1}a_k,\ \ k\ge3\end{flalign}\]</span></p><h3 id="定理3">定理3：</h3><p>设<span class="math inline">\([a_1,a_2,\cdots,a_n,\cdots]\)</span>是简单连分数，<span class="math inline">\(\frac{p_k}{q_k}(k=1,2,\cdots)\)</span>是它的渐进分数，则： <span class="math display">\[\begin{flalign}&amp;(1)\ \ 当k\ge 3时，q_k\ge q_{k-1}+1，因而对任何k来说,q_k\ge k-1\\ &amp;(2)\ \ \frac{p_{2(k-1)}}{q_{2(k-1)}}&gt;\frac{p_{2k}}{q_{2k}},\frac{p_{2k-1}}{q_{2k-1}}&gt;\frac{p_{2k-3}}{q_{2k-3}},\frac{p_{2k}}{q_{2k}}&gt;\frac{p_{2k-1}}{q_{2k-1}}\\ &amp;(3)\frac{p_k}{q_k}(k=1,2,\cdots)都是既约分数\end{flalign}\]</span></p><h3 id="定理4">定理4：</h3><p>每一简单连分数表示一个实数.</p><h3 id="定理5">定理5：</h3><p>任一实无理数可以表成无限简单连分数.</p><h4 id="定理5的推论">定理5的推论：</h4><p>对于实无理数<span class="math inline">\(\alpha\)</span>，有 <span class="math display">\[\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta_k}{q_kq_{k+1}}或\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta&#39;_k}{q_k^2},其中0&lt;\delta_k&lt;1,0&lt;\delta&#39;_k&lt;1\]</span></p><h3 id="定理6">定理6：</h3><p>每一实无理数只有一种唯一的方法表成无限简单连分数.</p><h3 id="定理7">定理7：</h3><p><span class="math display">\[\begin{flalign}&amp;(1)若\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[b_1,b_2,\cdots,b_n],且a_n&gt;1,b_m&gt;1，则m=n,a_i=b_i\ \ (i=1,2,\cdots,n)\\ &amp;(2)任一有理数\frac{a}{b}有且仅有两种方法表成简单连分数，即\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[a_1,a_2,\cdots,a_n-1,1]\end{flalign}\]</span></p><h3 id="定理8">定理8：</h3><p>若<span class="math inline">\(\alpha\)</span>是任一实数，<span class="math inline">\(\frac{p_k}{q_k}\)</span>是<span class="math inline">\(\alpha\)</span>的第<span class="math inline">\(k\)</span>个渐进分数，则在分母小于等于<span class="math inline">\(q_k\)</span>的一切有理数中，<span class="math inline">\(\frac{p_k}{q_k}\)</span>是<span class="math inline">\(\alpha\)</span>最好的有理近似值，即若<span class="math inline">\(0&lt;q\le q_k\)</span>，则 <span class="math display">\[|{\alpha-\frac{p_k}{q_k}}|\le|{\alpha-\frac{p}{q}}|\]</span></p><h3 id="定理9">定理9：</h3><p>每一循环连分数一定是某一整系数二次不可约方程的实根.</p><h3 id="定理10">定理10：</h3><p>若<span class="math inline">\(f(x)=ax^2+bx+c\)</span>是一个整系数二次不可约多项式，<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(f(x)=0\)</span>的一个实根，则表示<span class="math inline">\(\alpha\)</span>的简单连分数是一循环连分数.</p><h3 id="定理11legendre定理">定理11（Legendre定理）：</h3><p>对于有理数<span class="math inline">\(\alpha\)</span>，若整数<span class="math inline">\(c,d\)</span>满足 <span class="math display">\[|{\alpha-\frac{c}{d}}|&lt;\frac{1}{2d^2}\]</span> 那么<span class="math inline">\(\frac{c}{d}\)</span>就是<span class="math inline">\(\alpha\)</span>的一个有理近似.</p><h2 id="连分数的应用实例">连分数的应用实例</h2><h3 id="佩尔方程pell-equation">佩尔方程(Pell equation)</h3><h4 id="定义">定义：</h4><p>形如<span class="math inline">\(x^2-dy^2=1\)</span>的不定方程被称为<strong>佩尔方程</strong></p><p>现求佩尔方程有正整数解的条件：</p><p>在实数域对方程<span class="math inline">\(x^2-dy^2=1\)</span>进行分解有<span class="math inline">\((x+\sqrt{d}y)(x-\sqrt{d}y)=1\)</span></p><p>(1)当<span class="math inline">\(d\)</span>为完全平方数</p><p>则有<span class="math inline">\(x+\sqrt{d}y,x-\sqrt{d}y\)</span>均为整数，那么若<span class="math inline">\((x+\sqrt{d}y)(x-\sqrt{d}y)=1\)</span>，则必有<span class="math inline">\(x+\sqrt{d}y=x-\sqrt{d}y=1\)</span></p><p>而满足这种情况的非负整数对<span class="math inline">\((x,y)=(1,0)\)</span>所以方程<span class="math inline">\(x^2-dy^2=1\)</span>并不存在正整数解.</p><p>(2)当<span class="math inline">\(d\)</span>为非完全平方数</p><h3 id="定理12">定理12：</h3><p>对任何正整数<span class="math inline">\(n\)</span>，都存在两个整数<span class="math inline">\(P_n,Q_n\)</span>，使得 <span class="math display">\[\alpha_n=\frac{\sqrt{d}+P_n}{Q_n},且P_n^2\equiv d\ (mod\ Q_n)\]</span> 成立.</p><h3 id="定理13">定理13：</h3><p>若<span class="math inline">\(d\)</span>是一个非平方的正整数，<span class="math inline">\(Q_n\)</span>为<strong>定理12</strong>中所定义，则二次不定方程<span class="math inline">\(x^2-dy^2=(-1)^nQ_n\)</span>有正整数解<span class="math inline">\(x,y\)</span>且<span class="math inline">\((x,y)=1\)</span>.</p><h3 id="定理14">定理14：</h3><p>若有<span class="math inline">\(\sqrt{d}=[a_1,a_2, \cdots ,a_s,a_{s+1}, \cdots ,a_{s+t}],n&gt;s\)</span>而<span class="math inline">\(Q_n\)</span>为<strong>定理12</strong>所定义，则方程<span class="math inline">\(x^2-dy^2=(-1)^nQ_n\)</span>有无穷多个正整数解 <span class="math inline">\(|{p_{m+lt}}|,q_n+lt,2\ |\ l,l\ge0\)</span> .（其中 <span class="math inline">\(\frac {p_{m+lt}}{q_{m+lt}}\)</span> 为 <span class="math inline">\(\sqrt {d}\)</span> 的第 <span class="math inline">\(m+lt\)</span> 个渐进分数）.</p><p>由<strong>定理14</strong>可知存在一正整数<span class="math inline">\(Q\)</span>（取<span class="math inline">\(Q=(-1)^nQ_n,n&gt;s\)</span>）使得不定方程<span class="math inline">\(x^2-dy^2=Q\)</span>有无穷多组正整数解，则在这些解中必存在两组不同的正整数<span class="math inline">\(x_1y_1;x_2y_2\)</span>使得 <span class="math display">\[x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)\]</span> 成立.由于<span class="math inline">\(x^2_1-dy^2_1=x^2_2-dy^2_2=Q\)</span>，故有 <span class="math display">\[Q^2=(x_1^2-dy_1^2)(x_2^2-dy_2^2)=(x_1x_2-dy_1y_2)^2-d(x_1y_2-x_2y_1)^2\]</span> 由<span class="math inline">\(x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)\)</span>可得： <span class="math display">\[x_1x_2-dy_1y_2\equiv x_1^2-dy_1^2\equiv 0\ (mod\ |{Q}|),\\ x_1y_2-x_2y_1\equiv x_1y_1-x_1y_1\equiv 0\ (mod\ |{Q}|)\]</span> 故若令<span class="math inline">\(|{\frac{x_1x_2-dy_1y_2}{Q}}|=x,|{\frac{x_1y_2-x_2y_1}{Q}}|=y\)</span>，可知<span class="math inline">\(x,y\)</span>均为非负整数且为方程<span class="math inline">\(x^2-dy^2=1\)</span>的一解.</p><p>显然有<span class="math inline">\(x\neq0\)</span>，否则有<span class="math inline">\(-dy^{2}=1\)</span>，与<span class="math inline">\(d&gt;0\)</span>矛盾；且有<span class="math inline">\(y\neq0\)</span>否则有<span class="math inline">\(x_1y_2-x_2y_1=0\)</span>，由引理2知<span class="math inline">\((x_1,y_1)=(x_2,y_2)=1\)</span>，所以有<span class="math inline">\(x_1\ |\ x_2,x_2\ |\ x_1\)</span>，由于<span class="math inline">\(x_1,x_2\)</span>均为正整数，所以有<span class="math inline">\(x_1=x_2,y_1=y_2\)</span>，与<span class="math inline">\(x_1,y_1;x_2;y_n\)</span>不同的定义相悖.故可知<span class="math inline">\(x,y\)</span>为方程<span class="math inline">\(x^2-dy^2=1\)</span>的一组正整数解.</p><p>综上所述，当<span class="math inline">\(d\)</span>为完全平方数时，不定方程<span class="math inline">\(x^2-dy^2=1\)</span>有正整数解.</p><h4 id="现在求不定方程x2-dy21的正整数解">现在求不定方程<span class="math inline">\(x^2-dy^2=1\)</span>的正整数解：</h4><h3 id="定理15">定理15：</h3><p>若<span class="math inline">\(x_0,y_0\)</span>是方程<span class="math inline">\(x^2-dy^2=1\)</span>的一组正整数解，且<span class="math inline">\(x_0+\sqrt{d}y_0\)</span>是形如<span class="math inline">\(x+\sqrt{d}y\)</span>（<span class="math inline">\(x,y\)</span>是方程<span class="math inline">\(x^2-dy^2=1\)</span>的正整数解）的最小数，则方程<span class="math inline">\(x^2-dy^2=1\)</span>的一切正整数解<span class="math inline">\(x,y\)</span>可以由 <span class="math display">\[x\pm\sqrt{d}y=\big(x_0+\sqrt{d}y_0\big)^n,n=1,2,\cdots\]</span> 确定.</p><p>有了<strong>定理15</strong>，我们可以通过一个佩尔方程的最小正整数解求出这个佩尔方程的所有解.现在我们的目标就成为找到如何求佩尔方程的最小正整数解.</p><p>实际上，对于不为完全平方数的<span class="math inline">\(\sqrt{d}=[a_1,a_2,\cdots,a_n,\cdots]\)</span>我们总能找到<span class="math inline">\(a_{n+1}\)</span>满足<span class="math inline">\(a_i=2a_1(i=2,3,\cdots,n)\)</span>，则<span class="math inline">\(\frac{x}{y}=[a_1,a_2,\cdots,a_{n}]\)</span>可能为<span class="math inline">\(d\)</span>定义的佩尔方程的一组解.</p><p>求佩尔方程最小整数解的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line">d = ...</span><br><span class="line">cf = continued_fraction(sqrt(d))</span><br><span class="line">a0 = cf[<span class="number">0</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> cf[i] == <span class="number">2</span>*a0:</span><br><span class="line">        c = cf.convergent(i-<span class="number">1</span>)</span><br><span class="line">        x, y = c.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> - d*y**<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>((x,y))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这里扩展地提一下广义佩尔方程：</p><h4 id="定义-1">定义</h4><p>形如<span class="math inline">\(x^2-dy^2=c\)</span>的方程称为广义佩尔方程.</p><h4 id="求解">求解</h4><p>通过连分数求出广义佩尔方程的最小正整数解<span class="math inline">\((x_0,y_0)\)</span>后，可以知道<span class="math inline">\((x_0r+Dy_0s,x_0s+y_0r)\)</span>也是该方程的整数解（其中<span class="math inline">\(r,s\)</span>为方程<span class="math inline">\(r^2-ds^2=1\)</span>的整数解）</p><h4 id="求解代码">求解代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell_roots</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    intervals = <span class="number">2</span>**<span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_a_root</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span></span>):</span><br><span class="line">        cf = continued_fraction(sqrt(D))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            c = cf.convergent(i - <span class="number">1</span>)</span><br><span class="line">            x, y = c.as_integer_ratio()</span><br><span class="line">            <span class="keyword">if</span> x**<span class="number">2</span> - D * y**<span class="number">2</span> == C:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            x2 = C + D * y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x2 &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x = isqrt(x2)</span><br><span class="line">            <span class="keyword">if</span> x ** <span class="number">2</span> == x2:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    r, s = get_a_root(D, <span class="number">1</span>)</span><br><span class="line">    x, y = get_a_root(D, C)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x, y</span><br><span class="line">        x, y = x * r + D * y * s, r * y + s * x</span><br><span class="line">D = ...</span><br><span class="line">C = ...</span><br><span class="line">x, y = <span class="built_in">next</span>(pell_roots(D, C))</span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span> - D * y**<span class="number">2</span> == C)</span><br><span class="line"><span class="built_in">print</span>((x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rsa的维纳攻击">RSA的维纳攻击</h3><h4 id="原理">原理</h4><p>考虑一般的RSA，<span class="math inline">\(c\equiv m^e\ (mod\ n),n=pq\)</span>，<span class="math inline">\(p,q\)</span>均为质数，在这里<span class="math inline">\(e\)</span>非常大，这也是适用维纳攻击的RSA的明显特征，有<span class="math inline">\(\varphi(n)=(p-1)(q-1)\)</span>，则有 <span class="math display">\[\varphi(n)=(p-1)(q-1)=pq-p-q+1=N-p-\frac{n}{p}+1\]</span> 故有<span class="math inline">\(p^2+p\big[\varphi(n)-n-1\big]+n=0\)</span></p><p>故若我们已知<span class="math inline">\(n\)</span>和<span class="math inline">\(\varphi(n)\)</span>，我们就可以对<span class="math inline">\(n\)</span>进行分解.</p><p>又由于在RSA中，有<span class="math inline">\(ed\equiv1\ (mod\ \varphi(n))\)</span>，所以存在整数<span class="math inline">\(k\)</span>使得<span class="math inline">\(ed=k\varphi(n)+1\)</span></p><p>即有 <span class="math display">\[|{\frac{e}{\varphi(n)}-\frac{k}{d}}|=\frac{1}{d\varphi(n)}\]</span> 由<strong>定理11（Legendre定理）</strong>可知：<span class="math inline">\(\frac{k}{d}\)</span>是<span class="math inline">\(\frac{e}{\varphi(n)}\)</span>的一个有理近似，故我们可以通过<span class="math inline">\(\frac{e}{\varphi(n)}\)</span>的有理近似获得<span class="math inline">\(\frac{k}{d}\)</span>，当<span class="math inline">\(n=pq\)</span>且<span class="math inline">\(q&lt;p&lt;2q\)</span>时，若满足<span class="math inline">\(d&lt;\frac{1}{3}n^\frac{1}{4}\)</span>，则<span class="math inline">\(\frac{k}{d}\)</span>为<span class="math inline">\(\frac{e}{n}\)</span>的一个有理近似.</p><h4 id="求解步骤">求解步骤</h4><p>(1)估测是否满足<span class="math inline">\(d&lt;\frac{1}{3}n^\frac{1}{4}\)</span></p><p>(2)求<span class="math inline">\(\frac{e}{n}\)</span>的连分数展开</p><p>(3)迭代连分数<span class="math inline">\(\frac{k_i}{d_i}\)</span>：先使用<span class="math inline">\(k_i,d_i\)</span>求出<span class="math inline">\(\varphi_i(n)\)</span>，再通过<span class="math inline">\(\varphi_i(n)\)</span>计算出<span class="math inline">\(n\)</span>，验证<span class="math inline">\(\varphi_i(n)\)</span>是否正确</p><h4 id="解密脚本">解密脚本：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">n, e</span>):</span><br><span class="line">    cf = continued_fraction(e / n)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pkd <span class="keyword">in</span> convers:</span><br><span class="line">        pk, pd = pkd.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> pk == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * pd - <span class="number">1</span>) % pk != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pphi = (e * pd - <span class="number">1</span>) // pk</span><br><span class="line">        p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">        roots = solve(p ** <span class="number">2</span> + (pphi - n - <span class="number">1</span>) * p + n, p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">            pp, pq = roots</span><br><span class="line">            <span class="keyword">if</span> pp * pq == n:</span><br><span class="line">                <span class="keyword">return</span> pp, pq, pd</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">n = ...</span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line">p, q, d = wienerAttack(n, e)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCG笔记</title>
      <link href="/2023/12/17/LCG%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/17/LCG%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义： <span class="math display">\[X_{n+1}\equiv aX_n+b\ (mod\ p)\]</span> 在CTF中，一般有以下题型：</p><h2 id="一.求逆">一.求逆</h2><p>所谓求逆，其实即为已知a,b,p,c后求解方程： <span class="math display">\[c\equiv(ax+b)\ (mod\ p)\]</span> 由数论知识我们很容易可以知道： <span class="math display">\[x\equiv(c-b)a^{-1}\ (mod\ p)\]</span> 对于这类题目，我们只需利用以上公式即可快速解出。</p><h2 id="二.求参数ab后求逆">二.求参数a,b后求逆</h2><p>这类题型一般都会给出一列连续经过几次线性同余的数据后得出的数据和p，我们需要通过这些有限的数据来求解原来的数据，在此之前我们需要先求解a和b，大致过程如下：</p><p>假设已知<span class="math display">\[x_{n},x_{n+1},x_{n+2}\]</span>，我们有：</p><p><span class="math display">\[x_{n+1}\equiv ax_n+b\ (mod\ p)\\ x_{n+2}\equiv ax_{n+1}+b\ (mod\ p)\]</span> 所以我们有： <span class="math display">\[x_{n+2}-x_{n+1}\equiv a(x_{n+1}-x_n)\ (mod\ p)\]</span> 所以： <span class="math display">\[a\equiv (x_{n+2}-x_{n+1})(x_{n+1}-x_n)^{-1}\ (mod\ p)(假定(x_{n+1}-x_n)与p互质)\]</span> 那么我们有： <span class="math display">\[b\equiv x_{n+1}-ax_n\ (mod\ p)\]</span> 这样我们就可以得到a,b，再通过求逆得出原来的数据即可。</p><h3 id="例newstar-ctf2023week3-babyrandom">例：[Newstar CTF2023]Week3 babyrandom</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line"></span><br><span class="line">a = randrange(<span class="number">2</span>, p)</span><br><span class="line">b = randrange(<span class="number">2</span>, p)</span><br><span class="line">x = bytes_to_long(flag)</span><br><span class="line">menu = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Random as a Service with LCG backend</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter your option</span></span><br><span class="line"><span class="string">1. Reset</span></span><br><span class="line"><span class="string">2. Get</span></span><br><span class="line"><span class="string">3. Exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetRandom</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    nx = (a*x + b) % p</span><br><span class="line">    <span class="built_in">print</span>(nx)</span><br><span class="line">    x = nx</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(menu)</span><br><span class="line">    opt = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opt = <span class="built_in">int</span>(opt)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="number">1</span>:</span><br><span class="line">            x = bytes_to_long(flag)</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">2</span>:</span><br><span class="line">            GetRandom()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;invalid option&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oh no, something wrong!&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这道题提供了靶机，可以通过靶机得出三个连续加密后数据，解密代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = []</span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line">io = pwn.remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25624</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    data = io.recvline()</span><br><span class="line">    io.recv()</span><br><span class="line">    x.append(<span class="built_in">int</span>(data))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">x = (x[<span class="number">0</span>]-b)*gmpy2.invert(a,p)%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><blockquote><p>flag{lcg_1s_n0t_s3cur3#fb528ba5}</p></blockquote><h2 id="三.求参数abp后求逆">三.求参数a,b,p后求逆</h2><p>与上一种形式相似，但是多了个p要求，我们假设一个数列： <span class="math display">\[\{x_0,x_1,x_2,\cdots,x_{n-1},x_{n},\cdots\}\]</span> 其满足： <span class="math display">\[x_{n+1}\equiv ax_n+b\ (mod\ p)\]</span> 假设有一个数列 <span class="math display">\[\{t_n\}\]</span> 有：</p><p><span class="math display">\[t_n\equiv x_{n+1}-x_n\equiv a(x_n-x_{n-1})\equiv at_{n-1}\ (mod\ p)\]</span></p><p>所以：</p><p><span class="math display">\[t_{n+1}t_{n-1}\equiv a^{2}t_{n-1}^2\equiv t_n^2\ (mod\ p)\]</span></p><p>也就是说：</p><p><span class="math display">\[t_{n+1}t_{n-1}-t_n^{2}=kp\ (k\in Z)\]</span></p><p>同理，有：</p><p><span class="math display">\[t_{n+2}t_{n}-t_{n+1}^{2}=k&#39;p\ (k&#39;\in Z)\]</span></p><p>所以：</p><p><span class="math display">\[p=gcd(t_{n+2}t_{n}-t_{n+1}^{2},t_{n+1}t_{n-1}-t_n^{2})\]</span> 求出p后我们就可以由上种类型继续求解。</p><p>但是要注意，上面求出的p不一定就是实际要求的p，所以需要综合多组数据求解。</p><h3 id="例pctf2023cgl">例：[PCTF2023]cgl</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag,hint,key_number</span><br><span class="line"></span><br><span class="line">hint=bytes_to_long(hint)</span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">256</span>)</span><br><span class="line">b = getPrime(<span class="number">256</span>)</span><br><span class="line">n = getPrime(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">state = hint</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    state = (state * a + b) % n</span><br><span class="line">    result.append(state)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc=<span class="built_in">list</span>(base64.b64encode(flag))</span><br><span class="line">seed(key_number)</span><br><span class="line">shuffle(enc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(enc))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[64808739969023370119048821688797617211776674130654821075486774236651303382814, </span></span><br><span class="line"><span class="string">79259085906502785899793009961165414442137337544515472474317826031734962148580, </span></span><br><span class="line"><span class="string">47572752582229256276978761367590954300620113464013293239765792280017260371290, </span></span><br><span class="line"><span class="string">38491979589561565391093783861378040494484383004914878495301417593240442882761, </span></span><br><span class="line"><span class="string">58955289126482266943455593731576872529828229203595014577711629479455475819111]</span></span><br><span class="line"><span class="string">b&#x27;QkiTMMx3St9IYTLMN2DmR0t53zd1MhmJT1hZ2YiwMZETVhwhOGYVZYcD&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题很明显要通过上述方法来求解hint，在这里我们只求解hint，求解代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = [<span class="number">64808739969023370119048821688797617211776674130654821075486774236651303382814</span>, </span><br><span class="line"><span class="number">79259085906502785899793009961165414442137337544515472474317826031734962148580</span>, </span><br><span class="line"><span class="number">47572752582229256276978761367590954300620113464013293239765792280017260371290</span>, </span><br><span class="line"><span class="number">38491979589561565391093783861378040494484383004914878495301417593240442882761</span>, </span><br><span class="line"><span class="number">58955289126482266943455593731576872529828229203595014577711629479455475819111</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.append(x[i+<span class="number">1</span>]-x[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    p = gmpy2.gcd(t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>],t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i])</span><br><span class="line">    a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">    b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">    x = (x[<span class="number">0</span>] - b) * gmpy2.invert(a, p) % p</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可以得出hint：</p><blockquote><p>key_number=randrange(999999)</p></blockquote><p>要注意的是：在这种情况下，<span class="math display">\[\{x_n\}\]</span>的元素数量应该至少要有5个才能求解出p。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anshel–Anshel–Goldfeld 密钥交换体系(Anshel–Anshel–Goldfeld key exchange)</title>
      <link href="/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/"/>
      <url>/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/</url>
      
        <content type="html"><![CDATA[<h3 id="原理代数密钥建立协议the-algebraic-key-establishment-protocol">原理（代数密钥建立协议，The algebraic key establishment protocol）</h3><p>​ We now present an algebraic key establishment protocol which, in its most general form consists of a five–tuple <span class="math display">\[(U, V,\beta,\gamma_1, \gamma_2)\]</span> where <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are feasibly computable monoids, and <span class="math display">\[\beta:U× U\rightarrow V,\ \ \ \gamma_i:U× V\rightarrow V\ \ (i=1,2)\]</span> are feasibly computable functions satisfying the following properties.</p><p>​ (i) For all elements <span class="math inline">\(x, y_1, y_2 \in U\)</span> , <span class="math display">\[\beta(x,y_1\cdot y_2)=\beta(x,y_1)\cdot \beta(x,y_2)\]</span> ​ (ii) For all elements <span class="math inline">\(x, y \in U\)</span> , <span class="math display">\[\gamma_1(x,\beta(y,x))=\gamma_2(x,\beta(x,y))\]</span> ​ (iii) Suppose <span class="math inline">\(y_1, y_2, \cdots ,y_k \in U\)</span> and <span class="math inline">\(\beta(x, y_1), \beta(x, y_2), \cdots ,\beta(x, y_k)\)</span> are publicly known for some secret element <span class="math inline">\(x \in U\)</span>. Then, in general, it is infeasible to determine the secret element <span class="math inline">\(x\)</span> .</p><p>​ The users <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are publicly assigned submonoids, <span class="math inline">\(S_A, T_B \subseteq U\)</span>, respectively. Suppose that <span class="math inline">\(S_A\)</span> is generated by the elements <span class="math display">\[\{s_1,\cdots ,s_m\}\]</span> and <span class="math inline">\(S_B\)</span> is generated by <span class="math inline">\(\{t_1,\cdots,t_n\}\)</span>.The protocol begins with user A choosing a secret element a in <span class="math inline">\(S_A\)</span> and transmitting the elements <span class="math display">\[\beta(a,t_i)\ \ \ \ \ \ i=1,\cdots,n.\]</span> Likewise, user <span class="math inline">\(B\)</span> chooses a secret element <span class="math inline">\(b\)</span> in <span class="math inline">\(T\)</span>, transmits <span class="math display">\[\beta(b,s_i)\ \ \ \ \ \ i=1,\cdots,m.\]</span> It follows from property (iii) that even though the transmission is over a public channel, the secret elements <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are secure. Property (i) above insures that user <span class="math inline">\(A\)</span> can compute the element <span class="math display">\[\beta(b,a),\]</span> and <span class="math display">\[\gamma_1(a,\beta(b,a)).\]</span> Likewise user <span class="math inline">\(B\)</span> can compute <span class="math inline">\(\beta(a, b)\)</span> and <span class="math inline">\(\gamma_2(b, \beta(a, b))\)</span>. Recalling property (ii) above we see that <span class="math display">\[\kappa=\gamma_1(a,\beta(b,a))=\gamma_2(b,\beta(a,b))\]</span> can serve as an established key.</p><h3 id="具体例子群论协议a-group-theoretic-protocol">具体例子（群论协议，A group theoretic protocol）</h3><p>In this illustration the monoid <span class="math inline">\(U = V\)</span> is a group, denoted <span class="math inline">\(G\)</span>, and the users <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are publicly assigned subgroups <span class="math display">\[S_A=\langle s_1,s_2,\cdots ,s_m\rangle,\ \ \ \ S_B=\langle t_1,t_2,\cdots ,t_n\rangle.\]</span> Here the function <span class="math inline">\(\beta:G× G\rightarrow G\)</span> is chosen to be conjugation, <span class="math display">\[\gamma_1(u,v)=u^{-1}v,\ \ \ \ \ \ \gamma_2(u,v)=v^{-1}u.\]</span> Users A and B choose secret elements <span class="math inline">\(a \in S_A\)</span> and <span class="math inline">\(b \in S_B\)</span> respectively, and user <span class="math inline">\(A\)</span> begins the protocol by computing, rewriting, and transmitting the collection of elements <span class="math display">\[a^{-1}t_1a,a^{-1}t_2a,\cdots ,a^{-1}t_na.\]</span> Similarly, user <span class="math inline">\(B\)</span> computes, rewrites, and transmits <span class="math display">\[b^{-1}s_1b,b^{-1}s_2b,\cdots,b^{-1}s_mb.\]</span> An adversary observing these transmissions is unable to determine <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> unless <span class="math inline">\((s)\)</span> he can solve a set of simultaneous conjugacy equations over the base group.</p><p>​ Multiplying two elements in the group can be accomplished by simply concatenating the two expressions representing the elements. The process of rewriting, while not unique, must be chosen so that no adversary can determine the conjugating element from viewing the publicly transmitted conjugates.</p><p>​ Recalling that the conjugate of the product of two elements is the product of the conjugates of those elements (i.e., property (i) of <span class="math inline">\(\beta\)</span>), users <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are now in a position to compute, respectively, the elements <span class="math display">\[\beta(b,a)=b^{-1}ab,\ \ \ \ \ \ \ \ \beta(a,b)=a^{-1}ba.\]</span> In order to attain a common key, user <span class="math inline">\(A\)</span> computes <span class="math display">\[\kappa=\gamma_1(a,\beta(b,a))=a^{-1}b^{-1}ab=[a,b],\]</span> and user <span class="math inline">\(B\)</span> computes <span class="math display">\[\kappa=\gamma_2(a,\beta(b,a))=[a,b].\]</span> （上文摘自<em>Mathematical Research Letters 6, 287–291 (1999),AN ALGEBRAIC METHOD FOR PUBLIC-KEY CRYPTOGRAPHY</em>,Iris Anshel, Michael Anshel, and Dorian Goldfeld著）</p><h4 id="应用例">应用例</h4><h5 id="utctf2020cube-crypto">[UTCTF2020]Cube Crypto</h5><p>Mr. Anshel and Mr. Goldfeld were trying to exchange some asymmetric keys to get a shared key. They aren't very good at math, so they decided to use a Rubik's Cube instead to do the crypto. I don't think it's very secure though, I think you might be able to guess some of their keys :hmm:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mr. A public key: [B&#x27; U&#x27;, F B F, R&#x27; D, B D&#x27;]</span><br><span class="line">Mr. G public key: [R D L&#x27;, D U&#x27; B, U F&#x27;, L&#x27; F]</span><br><span class="line"></span><br><span class="line">Mr. A sends: [B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;, B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;]</span><br><span class="line">Mr. G sends: [U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;]</span><br></pre></td></tr></table></figure><p><strong>NOTE: The flag is the shared key that they generate, so it is NOT in <code>utflag&#123;&#125;</code> format</strong></p><p>显然的，这道题需要应用Anshel–Anshel–Goldfeld 密钥交换体系，在这里，密钥是由魔方转动记号呈现的，而我们知道，魔方的转动操作群是非阿贝尔群，在这里，我们可以从Mr.A和Mr.G提供的公钥中提取出： <span class="math display">\[S_A=\langle s_1,s_2,s_3,s_4\rangle\ \ \ \ \ \ \ S_G=\langle t_1,t_2,t_3,t_4\rangle\]</span> 其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1=B&#x27; U&#x27;</span><br><span class="line">s_2=F B F</span><br><span class="line">s_3=R&#x27; D</span><br><span class="line">s_4=B D&#x27;</span><br><span class="line">t_1=R D L&#x27;</span><br><span class="line">t_2=D U&#x27; B</span><br><span class="line">t_3=U F&#x27;</span><br><span class="line">t_4=L&#x27; F</span><br></pre></td></tr></table></figure><p>又设在交换后得出的密文的集合分别为： <span class="math display">\[C_G=\langle s_1&#39;,s_2&#39;,s_3&#39;,s_4&#39;\rangle\ \ \ \ \ \ \ C_A=\langle t_1&#39;,t_2&#39;,t_3&#39;,t_4&#39;\rangle\]</span> 其中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_1&#x27;=U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_2&#x27;=U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_3&#x27;=U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_4&#x27;=U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">t_1&#x27;=B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_2&#x27;=B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;</span><br><span class="line">t_3&#x27;=B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_4&#x27;=B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;</span><br></pre></td></tr></table></figure><p>我们假设共享密钥为<span class="math inline">\(a^{-1}g^{-1}ag\)</span>，所以我们有： <span class="math display">\[a^{-1}t_ia=t_i&#39;\ \ \ \ \ g^{-1}s_ig=s_i&#39;\ \ \ \ \ (i=1,2,3,4)\]</span> 通过观察我们很容易可以得到： <span class="math display">\[a=D&#39; R D B&#39;\\g=L D&#39; R&#39; F U&#39;\]</span> 所以我们可以得出共享密钥： <span class="math display">\[a^{-1}g^{-1}ag=B D&#39; R&#39; DU F&#39; R D L&#39;D&#39; R D B&#39;L D&#39; R&#39; F U&#39;\]</span> 这样我们就得到了flag：</p><blockquote><p>utflag{B D' R' D U F' R D L' D' R D B' L D' R' F U'}</p></blockquote><p>至此，对于Anshel–Anshel–Goldfeld 密钥交换体系的介绍就到此结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
