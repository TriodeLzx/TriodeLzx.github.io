<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Aurora入队赛个人WP | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Crypto 简单丢番图方程（解题成本最高的一道）（其实就是一道二元二次不定方程问题） 这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决. 刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的： 1Aurora&amp;#123;None&amp;#125;  我以为这是对的，交上去发现是错的 后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤">
<meta property="og:type" content="article">
<meta property="og:title" content="Aurora入队赛个人WP">
<meta property="og:url" content="http://example.com/2023/11/07/Aurora%E5%85%A5%E9%98%9F%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Crypto 简单丢番图方程（解题成本最高的一道）（其实就是一道二元二次不定方程问题） 这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决. 刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的： 1Aurora&amp;#123;None&amp;#125;  我以为这是对的，交上去发现是错的 后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture1.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture2.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture3.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture4.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture5.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture6.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\final.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\%E4%BD%A0%E7%88%B1%E6%B7%B1%E5%A4%A7%E5%90%97\picture1.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\%E4%BD%A0%E7%88%B1%E6%B7%B1%E5%A4%A7%E5%90%97\%E5%AF%86%E7%A0%81%E8%A1%A8.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\AAAEEESSS\%E4%B9%B1%E7%A0%81.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\pwn_nc\picture1.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\pwn_nc\picture2.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\pwn_nc\picture3.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Pwn_%E5%AF%B0%E5%AE%87%E8%9D%97%E7%81%BE\picture1.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Pwn_%E5%AF%B0%E5%AE%87%E8%9D%97%E7%81%BE\picture2.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Pwn_%E5%AF%B0%E5%AE%87%E8%9D%97%E7%81%BE\picture3.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\%E6%B6%88%E5%A4%B1%E7%9A%84%E5%8E%9F%E7%A5%9E\picture1.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\148464\picture1.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\%E7%88%B1%E9%97%A8\main.png">
<meta property="og:image" content="d:\Markdown%E5%9B%BE%E7%89%87\%E7%88%B1%E9%97%A8\function_list.png">
<meta property="article:published_time" content="2023-11-07T04:20:23.000Z">
<meta property="article:modified_time" content="2023-11-07T04:26:10.864Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\Markdown%E5%9B%BE%E7%89%87\Crypto%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B\picture1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Aurora入队赛个人WP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/07/Aurora%E5%85%A5%E9%98%9F%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/" class="article-date">
  <time class="dt-published" datetime="2023-11-07T04:20:23.000Z" itemprop="datePublished">2023-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Aurora入队赛个人WP
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><hr>
<h2 id="简单丢番图方程（解题成本最高的一道）"><a href="#简单丢番图方程（解题成本最高的一道）" class="headerlink" title="简单丢番图方程（解题成本最高的一道）"></a>简单丢番图方程（解题成本最高的一道）</h2><p>（其实就是一道二元二次不定方程问题）</p>
<p>这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决.</p>
<p>刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;None&#125;</span><br></pre></td></tr></table></figure>

<p>我以为这是对的，交上去发现是错的</p>
<p>后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤大致如下：</p>
<h3 id="打开虚拟机（这是要讲的吗）"><a href="#打开虚拟机（这是要讲的吗）" class="headerlink" title="打开虚拟机（这是要讲的吗）"></a>打开虚拟机<del>（这是要讲的吗）</del></h3><h3 id="在虚拟机中打开靶机"><a href="#在虚拟机中打开靶机" class="headerlink" title="在虚拟机中打开靶机"></a>在虚拟机中打开靶机</h3><p><img src="D:\Markdown图片\Crypto丢番图方程\picture1.png"></p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>在这里我们可以看到一个比较大的数和一条很像勾股定理的方程，所以我们可以断定这题要用到勾股定理，而我们知道的勾股数就那么几对，所以我们可以通过质因数分解找出我们熟悉的勾股数，现在我们打开factordb，将这个已知的数进行质因数分解，结果如下：</p>
<p><img src="D:\Markdown图片\Crypto丢番图方程\picture2.png" alt="picture2"></p>
<p>啊？怎么是个质数？运气太差了吧QwQ（我发誓不是节目效果）</p>
<p>遇到这种情况，我们直接重开一把（这个数是随机生成的）</p>
<p><img src="D:\Markdown图片\Crypto丢番图方程\picture3.png"></p>
<p>这回就出来了</p>
<p><img src="D:\Markdown图片\Crypto丢番图方程\picture4.png"></p>
<p>不幸的是，对于这个数的较小质因数4289，我们好像很难找出一组适合的勾股数（不一定是不存在，就是难找）</p>
<p>那么再重开一把：</p>
<p><img src="D:\Markdown图片\Crypto丢番图方程\picture5.png"></p>
<p>很好，这次质因数分解后得到了我们想要的小质数</p>
<p><img src="D:\Markdown图片\Crypto丢番图方程\picture6.png"></p>
<p>而我们知道<br>$$<br>(5,12,13)<br>$$<br>是一组常见的勾股数，所以我们丢进计算器中可以算出：<br>$$<br>x&#x3D;304168011786560&#x2F;5*12&#x3D;730003228287744<br>$$</p>
<p>$$<br>y&#x3D;304168011786560&#x2F;5*13&#x3D;790836830645056<br>$$</p>
<p>这个时候我们把结果提交到靶机就可以得到我们想要的flag啦！</p>
<p><img src="D:\Markdown图片\Crypto丢番图方程\final.png" alt="final"></p>
<h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;ebd8bc51-2d57-406e-bcab-f601cfcb6924&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>这道题我觉得要改进的话应该数字搞大一点，锻炼Python编程能力</p>
<hr>
<h2 id="baby-RSA"><a href="#baby-RSA" class="headerlink" title="baby_RSA"></a>baby_RSA</h2><p>这题还是比较简单的，只涉及到大数分解问题</p>
<p>先贴一下加密的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;**************************&#125;&#x27;</span></span><br><span class="line">secret = bytes_to_long(flag)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    p = getPrime(<span class="number">64</span>)</span><br><span class="line">    n *= p</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = &#x27;</span>, n)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(secret, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = &#x27;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = &#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n =  2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c =  1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在《初等数论（第四版）》（闵嗣鹤，严士健编）对于RSA公钥体系的描述中（应该很多讲密码的书都是这样）<br>$$<br>n&#x3D;pq(p,q是两个大质数)<br>$$</p>
<p>但是将上面的n丢进factordb（谢谢学姐提供的数据）之后，它出现了16个不同的质因数（其实从代码中也可以看出）！那要怎么办呢？</p>
<p>![picture1](D:\Markdown图片\Crypto baby_RSA\picture1.png)</p>
<p>实际上，在RSA公钥体系中，将密码转化为明码需要求解下列同余方程<br>$$<br>b^d\equiv a^{ed}\equiv a^{1+k\varphi(n)}(modn)(e为密钥，n为解钥，b为密码，a为明码)<br>$$<br>而对于欧拉函数，有如下定理：<br>$$<br>\varphi(n)&#x3D;\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}&#x3D;n)<br>$$<br>而对于质数p，其欧拉函数值为：<br>$$<br>\varphi(p)&#x3D;p-1<br>$$<br>所以对于对于题中解钥n，有：<br>$$<br>\varphi(n)&#x3D;(p_1-1)(p_2-1)(p_3-1)\cdots(p_{16}-1)(p_1,p_2,p_3,\cdots,p_{16}为n的16个不同的质因数<br>$$<br>所以我们可以写出获得flag的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p1=<span class="number">11032741923171941087</span></span><br><span class="line">p2=<span class="number">11545653624202476473</span></span><br><span class="line">p3=<span class="number">11636293469353905931</span></span><br><span class="line">p4=<span class="number">11791412171539768003</span></span><br><span class="line">p5=<span class="number">12072682976194265431</span></span><br><span class="line">p6=<span class="number">12286985218370609161</span></span><br><span class="line">p7=<span class="number">13979567880622268887</span></span><br><span class="line">p8=<span class="number">14381447749489789777</span></span><br><span class="line">p9=<span class="number">14487171289353351409</span></span><br><span class="line">p10=<span class="number">14573688259437788669</span></span><br><span class="line">p11=<span class="number">15652738194884126429</span></span><br><span class="line">p12=<span class="number">16034270403328241087</span></span><br><span class="line">p13=<span class="number">16631285257180468447</span></span><br><span class="line">p14=<span class="number">17327252249988599903</span></span><br><span class="line">p15=<span class="number">17905457523849945107</span></span><br><span class="line">p16=<span class="number">18027152598391207147</span></span><br><span class="line">n=<span class="number">2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line">phi=(p1-<span class="number">1</span>)*(p2-<span class="number">1</span>)*(p3-<span class="number">1</span>)*(p4-<span class="number">1</span>)*(p5-<span class="number">1</span>)*(p6-<span class="number">1</span>)*(p7-<span class="number">1</span>)*(p8-<span class="number">1</span>)*(p9-<span class="number">1</span>)*(p10-<span class="number">1</span>)*(p11-<span class="number">1</span>)*(p12-<span class="number">1</span>)*(p13-<span class="number">1</span>)*(p14-<span class="number">1</span>)*(p15-<span class="number">1</span>)*(p16-<span class="number">1</span>)<span class="comment">#很蠢的方法，一个一个填</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<p>运行程序，我们就可以得到flag啦！</p>
<h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;RS4_1s_r3a1y_fun_4nd_ea5y!&#125;</span><br></pre></td></tr></table></figure>

<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>善用百度，Python真好用，还有，数论真好玩。</p>
<hr>
<h2 id="你爱深大吗"><a href="#你爱深大吗" class="headerlink" title="你爱深大吗"></a>你爱深大吗</h2><p>（最抽象的一道）</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="D:\Markdown图片\你爱深大吗\picture1.png" alt="picture1"></p>
<h3 id="解题过程及思路"><a href="#解题过程及思路" class="headerlink" title="解题过程及思路"></a>解题过程及思路</h3><p>这本质上是一道阅读题</p>
<p>刚开始，我看到下面的藏宝图这么抽象，我就知道：这题必有Base100！</p>
<p>后来再看一眼上面的小作文，我在里面找到了偏移值为6的凯撒密码，18层栅栏密码和一个密钥为”iloveszu”的维吉尼亚密码</p>
<p>故我试着解密</p>
<p>解密过程：Base100-&gt;偏移值为6的凯撒密码-&gt;18层的栅栏密码-&gt;密钥为”iloveszu”的维吉尼亚密码</p>
<p>解密出来长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;JTpnwk$VLB%p:?CR&amp;QIH:]An&gt;Zz;#CAg&lt;f37;$IZXvZ2INm;MS\0@Cg`c@It4892#G?&lt;mftRsQ,t;&gt;Fsxd&lt;2o_&#x27;:f@TSj&gt;!&#x27;BM+%`5&gt;$&quot;.qrET&lt;K9vaE?@W`&quot;1;89%@JbhgeACT9$;3KE\&lt;O9n(;aNA!@5tl1;WiC@5=BJX:];z-&gt;5/(V;7&lt;Gk_V%.!&lt;i:#?=tJOu*g/@s97T(E=n&#x27;%GJMF):M8</span><br></pre></td></tr></table></figure>

<p>这一看就不是flag</p>
<p>后来（一天后）经过指点及思考我发现了“冲破了基地的重重阻碍”中的“重重”二字，所以就尝试一下多重Base解码吧</p>
<p>经过尝试，对“Base”步骤解码过程如下：</p>
<p>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32</p>
<h5 id="解码结果："><a href="#解码结果：" class="headerlink" title="解码结果："></a>解码结果：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bky__cuuiwlz_zpwo&#123;taIkppbxywe__w&#125;st_hupzodnzht__t_ymhcicpfm</span><br></pre></td></tr></table></figure>

<p>解码出来发现出现了花括号和下划线，证明步骤应该是对了。</p>
<p>继续解密</p>
<p>根据上面的步骤，我们继续这条从偏移值为6的凯撒密码到18层的栅栏密码再到密钥为”iloveszu”的维吉尼亚密码的解密过程</p>
<p>解密出来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N_r_uHfa_&#125;_kdt_hioaerz&#123;wkc_rxbitfvoeowgpfyddmvpol__qil_kbra</span><br></pre></td></tr></table></figure>

<p>完全不对，连格式（Aurora{___}）都不对，而上面的加密方式中而可以改变符号位置的只有栅栏密码，而我在搜索引擎里面发现了一种不同的栅栏密码——W型。</p>
<p>在尝试之后，我发现再次经过上述解码方式后得出了如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nhihpr&#123;Dpk_bacj_eaik_wvs_mdfti_fa_j_knuomyddm_bu_movvgjjjh&#125;</span><br></pre></td></tr></table></figure>

<p>格式总算是正确了，但是为什么连关键的Aurora都没有出现呢？</p>
<p>我发现可能是凯撒密码的问题</p>
<p>后来我尝试偏移值为666的凯撒密码（实际上偏移值是16）</p>
<p>然后再进行上述步骤得到了如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dxyxfh&#123;Tfa_rqsz_uqya_mli_ctvjy_vq_z_adkecottc_rk_cellwzzzx&#125;</span><br></pre></td></tr></table></figure>

<p>发现还是不对</p>
<p>退回维吉尼亚密码前一步，我发现在解维吉尼亚密码之前的密文是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Limsjz&#123;Szi_cend_mpsi_xzd_gludg_ge_u_evjykzhog_jj_wmwzrdryr&#125;</span><br></pre></td></tr></table></figure>

<p>第一个是L，对照维吉尼亚密码表，我们可以发现，如果要从A得到L（因为我们猜测明文的第一个字母为A），那么密钥应为L</p>
<p>也就是说，维吉尼亚密码的密钥开头应该为L而不是I</p>
<p><img src="D:\Markdown图片\你爱深大吗\密码表.png" alt="密码表"></p>
<p>再次解密，得到如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;You_have_seen_the_magic_of_a_thousands_of_encodings&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是flag了。</p>
<p>所以这道题的步骤为：</p>
<h3 id="Base100-Base85-Base64-Base58-Base32-偏移值为666（即16）的凯撒密码-18层的W型栅栏密码-密钥为”loveszu”的维吉尼亚密码"><a href="#Base100-Base85-Base64-Base58-Base32-偏移值为666（即16）的凯撒密码-18层的W型栅栏密码-密钥为”loveszu”的维吉尼亚密码" class="headerlink" title="Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码"></a>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码</h3><hr>
<h2 id="AAAEEESSS"><a href="#AAAEEESSS" class="headerlink" title="AAAEEESSS"></a>AAAEEESSS</h2><p>先读代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag   </span><br><span class="line"><span class="comment">#flag从一个神秘的地方获得</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;welcometoAurora!&#x27;</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv=key)</span><br><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enc_flag = &quot;</span>, aes.encrypt(pad(flag, <span class="built_in">len</span>(key))).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">enc_flag =  de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们会发现这是CBC模式的AES加密，flag可能是下面的16进制字串解密而来的，通过搜索，我们发现有一个工具可以解密AES：</p>
<p><a target="_blank" rel="noopener" href="https://www.mklab.cn/utils/aes">AES在线加密解密工具 - MKLab在线工具</a></p>
<p>而阅读上面的代码，我们可以知道偏移向量和密钥均为<u>welcometoAurora!</u>将这两个东西放进去对应的地方，解码发现他出现了如下乱码:</p>
<p><img src="D:\Markdown图片\AAAEEESSS\乱码.png" alt="picture1"></p>
<p>是否是我的方法出了问题呢？</p>
<p>继续读代码，我们可以看到一个刚才被忽略的东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br></pre></td></tr></table></figure>

<p>这串代码我们可以猜测是在Could u slove this challenge?加密后16进制字串后面拼接一条什么东西（AES加密的填充机制和密码长度规律）。</p>
<p>所以我们可以试着先将Could u slove this challenge?进行AES加密，得到如下密文串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546</span><br></pre></td></tr></table></figure>

<p>在后面拼接代码中enc_flag部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span><br></pre></td></tr></table></figure>

<p>再放入密码输入框中解密可得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could u solve this challenge?Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure>

<p>这样就得到了flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="qsdz的密码学衔接课（赛后复现）"><a href="#qsdz的密码学衔接课（赛后复现）" class="headerlink" title="qsdz的密码学衔接课（赛后复现）"></a>qsdz的密码学衔接课（赛后复现）</h2><p>这题由三小题组成，分别是：求解同余方程，求解同余方程组，求解离散对数问题。</p>
<p>而这三个问题，我们都要利用到一个重要工具：sagemath</p>
<p>下面我们分别求解三个问题：</p>
<h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">x: <span class="built_in">int</span>, order: <span class="built_in">int</span></span>):</span><br><span class="line">    p = getPrime(x.bit_length() * order)</span><br><span class="line">    A = [getPrime(x.bit_length()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(order)]</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(order):</span><br><span class="line">        y = (y + A[i] * x ** i) % p</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 1&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;p = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;A = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">==========Challenge 1==========</span></span><br><span class="line"><span class="string">p = 140540932516518794145151934666843219294863335242957071370416678765850106203805810862867703792863302163318519910426474343219910841109958974959958710112904675289540046802486139135135963299678067328274525866708889478446402107588914151782335913</span></span><br><span class="line"><span class="string">A = [586077106161933115521158870621277482378849813647,</span></span><br><span class="line"><span class="string">594177621805167358745968527276343722485294425499, </span></span><br><span class="line"><span class="string">438154568295734958683230212377930413557186542591,</span></span><br><span class="line"><span class="string">613916554223827544243334495150247792479839893207,</span></span><br><span class="line"><span class="string">696514075788803577127407605798057483933441939039]</span></span><br><span class="line"><span class="string">y = 13584348643332560556129513295162939264971165296317907991475444036286814596235852842416707036226141464730561542976865467336771619592932663214739700885173786520323855676418761763774305698027356758972580332479097742926600081856865297421280491</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，这里的同余方程为：<br>$$<br>A_0+A_1x+A_2x^2+A_3x^3+A_4x^4\equiv y(mod\ p)<br>$$<br>所以我们在sagemath中对该方程做出如下定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;x&gt;=Zmod(p)[]</span><br><span class="line">f=A[<span class="number">0</span>]+A[<span class="number">1</span>]*x+A[<span class="number">2</span>]*x^<span class="number">2</span>+A[<span class="number">3</span>]*x^<span class="number">3</span>+A[<span class="number">4</span>]*x^<span class="number">4</span>-y</span><br></pre></td></tr></table></figure>

<p>再通过下面一段代码进行求解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.roots()</span><br></pre></td></tr></table></figure>

<p>可以得出下面两个解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_1=98641516410644248590730760547711915061873706589456407188998882763190683930094458978790759787796637145415287953931944776332655673057814076619504993207500838191433321143407475719143239135946766090781645970151825507798503659865125167544876679</span><br><span class="line">x_2=373703556015754746532223260569877349038577184359</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于是哪个解，我们到后面再讨论。</p>
<h3 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">x: <span class="built_in">int</span>, number: <span class="built_in">int</span></span>):</span><br><span class="line">    ps = [getPrime(x.bit_length() // (number - <span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line">    ys = [x % p <span class="keyword">for</span> p <span class="keyword">in</span> ps]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 2&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ps = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ys = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ps = [288186237701, 283710289297, 488405307827, 284002449103, 433963503397]</span></span><br><span class="line"><span class="string">ys = [229627846199, 206465857548, 461943583630, 18924375666, 173733924485]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们很容易可以写出上述代码的等价方程组：<br>$$<br>\begin{cases}<br>        x\equiv229627846199(mod\ 288186237701)\<br>        x\equiv206465857548(mod\ 283710289297)\<br>        x\equiv461943583630(mod\ 488405307827)\<br>        x\equiv18924375666(mod\ 284002449103)\<br>        x\equiv173733924485(mod\ 433963503397)<br>    \end{cases}<br>$$<br>求解这种传统不定方程组需要利用一个定理——孙子定理（中国剩余定理&#x2F;CRT），在sagemath中输入下列指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crt(ys,ps)</span><br></pre></td></tr></table></figure>

<p>可以得到下列解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">653438615351908597859575533851627354929851494003</span><br></pre></td></tr></table></figure>

<p>设上面的数字为y，则上述方程组等价于：<br>$$<br>x\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)<br>$$<br>我们可以验证：<br>$$<br>gcd(y,ps_0ps_1ps_2ps_3ps_4)&#x3D;1<br>$$<br>根据同余方程的性质，我们可以知道还有其他的解：<br>$$<br>y+k\cdot ps_0ps_1ps_2ps_3ps_4\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)<br>$$<br>先假定需要的解就是上面的y。</p>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><p><del>又是同余方程</del></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">x: <span class="built_in">int</span></span>):</span><br><span class="line">    base = getPrime(x.bit_length())</span><br><span class="line">    exp = getRandomInteger(<span class="number">40</span>)</span><br><span class="line">    module = getPrime(x.bit_length())</span><br><span class="line">    y = <span class="built_in">pow</span>(base, exp, module)</span><br><span class="line">    cipher = exp * x % module</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 3&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;base = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;module = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;cipher = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">base = 410736349593916097049313683889292166618005625707</span></span><br><span class="line"><span class="string">module = 644953605408967844199642272144415528955561551061</span></span><br><span class="line"><span class="string">y = 242650313731015062596916881403616976177380555988</span></span><br><span class="line"><span class="string">cipher = 398635925008029999138603615357303867027885126384</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>求解上述离散对数，其实就是求解下列同余方程：<br>$$<br>base^{exp}\equiv y(mod\ module)<br>$$<br>而上述方程中，又有：<br>$$<br>exp\cdot x\equiv cipher(mod\ module)<br>$$<br>现在我们要求解未知数x，所以我们需要先求出exp</p>
<p>在sagemath中使用以下指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp = discrete_log_lambda(mod(y, module), mod(base, module), bounds=(<span class="number">2</span>**<span class="number">39</span>, <span class="number">2</span>**<span class="number">40</span>))</span><br></pre></td></tr></table></figure>

<p>可得</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp=<span class="number">940420210186</span></span><br></pre></td></tr></table></figure>

<p>再通过下面的指令求出x：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cipher * inverse_mod(exp, module) % module</span><br></pre></td></tr></table></figure>

<p>可得解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">545012220020390134376571283157248116812656615805</span><br></pre></td></tr></table></figure>

<h3 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h3><p>阅读题中代码的最上面部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">b&#x27;Aurora&#123;qsdzyyds&#125;&#x27;</span></span><br><span class="line">part_number = <span class="built_in">len</span>(flag) // <span class="number">3</span></span><br><span class="line">flag_part1 = bytes_to_long(flag[:part_number])</span><br><span class="line">flag_part2 = bytes_to_long(flag[part_number:<span class="number">2</span>*part_number])</span><br><span class="line">flag_part3 = bytes_to_long(flag[<span class="number">2</span>*part_number:])</span><br></pre></td></tr></table></figure>

<p>我们可以知道，flag的三部分应该长度一致，所以对于同余方程与同余方程组部分的解应该与离散对数相同，所以有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag1=<span class="number">373703556015754746532223260569877349038577184359</span></span><br><span class="line">flag2=<span class="number">653438615351908597859575533851627354929851494003</span></span><br><span class="line">flag3=<span class="number">545012220020390134376571283157248116812656615805</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的代码求出flag：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(long_to_bytes(flag1))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag2))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag3))</span><br></pre></td></tr></table></figure>

<p>可以得出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;Aurora&#123;Sagem4th&amp;c0ng&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ru3nce_and_e9uations&#x27;</span></span><br><span class="line"><span class="string">b&#x27;_w1th_di5crete_lOg!&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Sagem4th&amp;c0ngru3nce_and_e9uations_w1th_di5crete_lOg!&#125;</span><br></pre></td></tr></table></figure>

<p>至此，衔接题就解决了。</p>
<hr>
<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><hr>
<h2 id="Basic-nc"><a href="#Basic-nc" class="headerlink" title="[Basic]nc"></a>[Basic]nc</h2><p>直接打开靶机</p>
<p><img src="D:\Markdown图片\pwn_nc\picture1.png" alt="picture1"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p><img src="D:\Markdown图片\pwn_nc\picture2.png" alt="picture2"></p>
<p>看到有个flag，输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag</span><br></pre></td></tr></table></figure>

<p><img src="D:\Markdown图片\pwn_nc\picture3.png" alt="picture3"></p>
<p>flag就出来了。</p>
<h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;ce8bf21a-3c2e-49f3-b27b-86440b8e8dd9&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Advanced-寰宇蝗灾"><a href="#Advanced-寰宇蝗灾" class="headerlink" title="[Advanced]寰宇蝗灾"></a>[Advanced]寰宇蝗灾</h2><p><del>（我就想玩个游戏，为什么会拿到这题的一血）</del></p>
<p>直接打开靶机！</p>
<p><img src="D:\Markdown图片\Pwn_寰宇蝗灾\picture1.png" alt="picture1"></p>
<p>直接攻击</p>
<p><img src="D:\Markdown图片\Pwn_寰宇蝗灾\picture2.png" alt="picture2"></p>
<p>玩着玩着虫子的数量出现了负数，这个时候我们就可以知道，这题利用的是数据溢出的漏洞，那我们逮着这个漏洞打就行了，多打几遍就会出现下面的情况：</p>
<p><img src="D:\Markdown图片\Pwn_寰宇蝗灾\picture3.png" alt="picture3"></p>
<p>还真是溢出<del>（至于怎么溢出的我也不清楚）</del></p>
<p>现在flag就出来了。</p>
<h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;8fae9274-d452-4f64-966e-024584b8a8d1&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><hr>
<h2 id="Basic-消失的原神"><a href="#Basic-消失的原神" class="headerlink" title="[Basic]消失的原神"></a>[Basic]消失的原神</h2><p><del>（我刚开始真的以为下载个原神就可以拿到flag）</del></p>
<p>首先将消失的原神.exe文件拖到ida64中</p>
<p>按下Shift+F12进入string页面</p>
<p><img src="D:\Markdown图片\消失的原神\picture1.png" alt="picture1"></p>
<p>上面就是我们要的flag了</p>
<h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;D0_u_P1a_G3nsh1n_iMpact&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Basic-148464"><a href="#Basic-148464" class="headerlink" title="[Basic]148464"></a>[Basic]148464</h2><p>先拖进ida64，直接飞去main按F5进行一个编译</p>
<p><img src="D:\Markdown图片\148464\picture1.png" alt="picture1"></p>
<p>观察下列代码我们可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&quot;</span>) )</span><br></pre></td></tr></table></figure>

<p>发现flag在一系列未知的操作后变成了字符串”zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”。</p>
<p>现在我们要找到flag怎么变才能变成上述字符串。</p>
<p>我们阅读如下代码，可知flag是一个长度为24的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%24s&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>再次阅读代码，我们发现s被丢进下面的函数里面进行过操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v5 - <span class="number">2</span> &gt; dword_4124 )</span><br><span class="line"> &#123;</span><br><span class="line">    sub_12F0((<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">1</span>], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">2</span>]);</span><br><span class="line">    dword_4124 += <span class="number">3</span>;</span><br><span class="line">    dword_4128 += <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>双击进入函数sub_12F0，我们看到这个函数进行的是如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_12F0</span><span class="params">(<span class="type">char</span> a1, <span class="type">char</span> a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  </span><br><span class="line">  s1[dword_4128] = aAbcdefghijklmn[a1 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">1</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">16</span> * a1) | (<span class="type">unsigned</span> __int8)(a2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">2</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">4</span> * a2) | (<span class="type">unsigned</span> __int8)(a3 &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  result = dword_4128 + <span class="number">3</span>;</span><br><span class="line">  s1[result] = aAbcdefghijklmn[a3 &amp; <span class="number">0x3F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以知道，其实这就是Base64的加密，但是当我将“zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”丢进Base64之后会见到一坨不明所以的无意义字符串，所以要思考是不是遗漏了什么。</p>
<p>再次阅读代码，可以发现在加密前有一个不明函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_1234();</span><br></pre></td></tr></table></figure>

<p>点进去我们可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1234</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[j], &amp;aAbcdefghijklmn[j + <span class="number">26</span>]);</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[k + <span class="number">52</span>], &amp;aAbcdefghijklmn[k + <span class="number">58</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，参与加密操作的字符串aAbcdefghijklmn是被修改过的！！</p>
<p>里面还有一个修改的函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">sub_1169</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+1Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v3 = *a1;</span><br><span class="line">  *a1 = *a2;</span><br><span class="line">  result = a2;</span><br><span class="line">  *a2 = v3;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个sub_1169函数的作用是交换a1和a2。</p>
<p>而直接查看内存，我们可以看到字符串aAbcdefghijklmn的值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们重写上面的C语言修改字符串代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">65</span>] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[j];</span><br><span class="line">            a[j] = a[j + <span class="number">26</span>];</span><br><span class="line">            a[j + <span class="number">26</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[k + <span class="number">52</span>];</span><br><span class="line">            a[k + <span class="number">52</span>] = a[k + <span class="number">58</span>];</span><br><span class="line">            a[k + <span class="number">58</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到aAbcdefghijklmn的新值为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们上搜索引擎找到Base64解码算法（Python比较方便，所以用了Python）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">STANDARD_ALPHABET = <span class="string">b&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#标准加密表</span></span><br><span class="line">CUSTOM_ALPHABET = <span class="string">b&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&#x27;</span><span class="comment">#修改后的加密表</span></span><br><span class="line">ENCODE_TRANS = <span class="built_in">bytes</span>.maketrans(STANDARD_ALPHABET, CUSTOM_ALPHABET)</span><br><span class="line">DECODE_TRANS = <span class="built_in">bytes</span>.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="built_in">input</span>).translate(ENCODE_TRANS)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(<span class="built_in">input</span>.translate(DECODE_TRANS))</span><br><span class="line"></span><br><span class="line">a=<span class="string">b&#x27;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&#x27;</span><span class="comment">#密文</span></span><br><span class="line">destr = decode(a)</span><br><span class="line"><span class="built_in">print</span>(destr.decode())</span><br></pre></td></tr></table></figure>

<p>运行可得flag如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;tH1s_iS_3z_base_64&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Advanced-爱门"><a href="#Advanced-爱门" class="headerlink" title="[Advanced]爱门"></a>[Advanced]爱门</h2><p><del>（爱门✝）</del></p>
<p>先将它放进ida64反编译，进入main点击F5进行编译。</p>
<p><img src="D:\Markdown图片\爱门\main.png" alt="main"></p>
<p>我们可以看到，获取flag的前置步骤是解出byte_4060，点进sub_134A函数，我们可以见到byte_4060被一定的规矩转换成了byte_40A0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sub_134A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = byte_4060[i];</span><br><span class="line">    byte_40A0[i] = v0 + aTheresa[i % <span class="built_in">strlen</span>(aTheresa)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而参与了转换的函数为aTheresa<del>（一只德莉莎？）</del>，双击这个字符数组我们可以看到aTheresa的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aTheresa        db <span class="string">&#x27;Theresa&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>转换为C++我们可以知道：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string aTheresa=<span class="string">&quot;Theresa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>我们只知道这样一个类似维吉尼亚密码的密钥没有任何实质性作用，我们需要找出被加密后的字符串。点进main中的sub_1281函数，可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1281</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = byte_4020[i];</span><br><span class="line">    <span class="keyword">if</span> ( byte_40A0[i] != (_BYTE)result )</span><br><span class="line">      dword_403C = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以见到，这边要得到byte_40A0，则需要先知道byte_4020是如何定义的，点开byte_4020我们可以看到它所在的那行是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte_4020       db <span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span></span><br></pre></td></tr></table></figure>

<p>它只有七个数据，但是byte_40A0需要26个数据，怎么办呢？</p>
<p>结合指针知识，数组的数据是存储在连续的地址里面的，如果一个指针指向一个数组，当指针指向的数组下标超过了数组范围时，它就会指向数组最后一个元素所在地址后面紧接着的地址，所以我们放大视野，就可以看到下面的数据：</p>
<p>![data2](D:\Markdown图片\爱门\data (2).png)</p>
<p>刚刚好有26个数据，且跟其他的数据的地址没有冲突，所以用C++写下列代码进行解密的尝试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;</span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a1[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，我们可以得出下面一个看似合理的“flag”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Elysia_is_dead????&#125;</span><br></pre></td></tr></table></figure>

<p><del>爱莉希雅死了？？？？</del></p>
<p>提交发现是错的，肯定是我们忽略了什么。</p>
<p>我们唯一没看过的就是左边的函数列了</p>
<p><img src="D:\Markdown图片\爱门\function_list.png" alt="function_list"></p>
<p>这里有很多不知道是什么的函数，我们一个一个看，可以发现函数sub_12CE里面有修改上面的数组中数据的代码（变量命名对应）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sub_12CE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(byte_4060, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">  result = <span class="built_in">memset</span>(byte_40A0, <span class="number">0</span>, <span class="keyword">sizeof</span>(byte_40A0));</span><br><span class="line">  byte_4030 = <span class="number">-45</span>;</span><br><span class="line">  byte_4031 = <span class="number">-103</span>;</span><br><span class="line">  byte_4032 = <span class="number">-39</span>;</span><br><span class="line">  byte_4033 = <span class="number">-46</span>;</span><br><span class="line">  byte_4034 = <span class="number">-59</span>;</span><br><span class="line">  byte_4035 = <span class="number">-71</span>;</span><br><span class="line">  byte_4036 = <span class="number">-55</span>;</span><br><span class="line">  byte_4037 = <span class="number">-55</span>;</span><br><span class="line">  byte_4038 = <span class="number">-109</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用此处代码对上述解密代码进行修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a2[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后又给出了一个看似合理的“flag”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Elysia_isn&#x27;t_dead!&#125;</span><br></pre></td></tr></table></figure>

<p><del>爱莉希雅没有死！</del></p>
<p>提交发现，他还是错的。似乎我们还是有所遗漏。</p>
<p>继续把我们的目光放到函数列上，我们会发现，在main函数后，还有一个名为sub_144F的函数，它跟sub_12CE发挥的效果是相似的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_144F</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  byte_4027 = <span class="number">-121</span>;</span><br><span class="line">  byte_402B = <span class="number">-106</span>;</span><br><span class="line">  byte_402E += <span class="number">10</span>;</span><br><span class="line">  byte_402F -= <span class="number">31</span>;</span><br><span class="line">  byte_4030 = <span class="number">-106</span>;</span><br><span class="line">  byte_4031 = <span class="number">-34</span>;</span><br><span class="line">  byte_4032 -= <span class="number">8</span>;</span><br><span class="line">  byte_4034 -= <span class="number">3</span>;</span><br><span class="line">  byte_4035 = <span class="number">-64</span>;</span><br><span class="line">  byte_4036 = <span class="number">-47</span>;</span><br><span class="line">  byte_4037 = <span class="number">-69</span>;</span><br><span class="line">  byte_4038 = <span class="number">-41</span>;</span><br><span class="line">  dword_403C = <span class="number">1</span>;</span><br><span class="line">  sub_1281();</span><br><span class="line">  <span class="keyword">if</span> ( dword_403C == <span class="number">1</span> )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Nice, job! U find it!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;What wrong with U? U didn&#x27;t find it! where is it?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且我们可以发现它还判断了变量dword_403C的大小，通过前面的阅读，我们可以发现，dword_403C只有在输入的字符串是正确的flag的时候才是1，参考上面的代码对解密代码进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//一次修改后</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">-121</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">-106</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">199</span>, <span class="number">188</span>, <span class="number">-106</span>, <span class="number">-34</span>, <span class="number">-47</span>, <span class="number">-46</span>, <span class="number">-62</span>, <span class="number">-64</span>, <span class="number">-47</span>, <span class="number">-69</span>, <span class="number">-41</span>, <span class="number">226</span>&#125;;<span class="comment">//二次修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a3[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，我们可以得到如下flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;3lys1a_sT1ll_aliVe&#125;</span><br></pre></td></tr></table></figure>

<p><del>爱莉希雅还活着</del></p>
<p>提交发现这个是真正的flag，至此，我们就解决了这道题。</p>
<hr>
<h2 id="Block-Chain"><a href="#Block-Chain" class="headerlink" title="Block Chain"></a>Block Chain</h2><hr>
<h2 id="easy-契约"><a href="#easy-契约" class="headerlink" title="[easy]契约"></a>[easy]契约</h2><p>这题利用的是合约创建字节码泄露。</p>
<p><del>需要挂梯子</del></p>
<p>进入网站：<a target="_blank" rel="noopener" href="https://sepolia.etherscan.io/">TESTNET Sepolia (ETH) Blockchain Explorer (etherscan.io)</a></p>
<p>![Exploer](D:\Markdown图片\Block Chain\Exploer.png)</p>
<p>在搜索框中输入题中给出合约并搜索：</p>
<p>![heyue](D:\Markdown图片\Block Chain\heyue.png)</p>
<p>点进合约对应的交易之后找到“Input data”一栏，在“View input as”处选择“UTF-8”就可以看到这样一坨：</p>
<p>![flag](D:\Markdown图片\Block Chain\flag.png)</p>
<p>里面蕴含了我们要的flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;W3lc0me_2_Blockch4in!!!&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在提交的时候，flag的最后可能有一个不可见字符，需要删掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/07/Aurora%E5%85%A5%E9%98%9F%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/" data-id="clontwps30000y0y614gq6u9d" data-title="Aurora入队赛个人WP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/11/06/Triode%E5%9F%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Triode域</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/07/Aurora%E5%85%A5%E9%98%9F%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/">Aurora入队赛个人WP</a>
          </li>
        
          <li>
            <a href="/2023/11/06/Triode%E5%9F%9F/">Triode域</a>
          </li>
        
          <li>
            <a href="/2023/11/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>