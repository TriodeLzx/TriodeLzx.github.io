<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深大Aurora第一批入队赛WP | Triode Field</title><meta name="author" content="Triode_Lzx"><meta name="copyright" content="Triode_Lzx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Crypto 简单丢番图方程（解题成本最高的一道）（其实就是一道二元二次不定方程问题） 这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决. 刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的： 1Aurora&amp;#123;None&amp;#125; 我以为这是对的，交上去发现是错的 后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤大">
<meta property="og:type" content="article">
<meta property="og:title" content="深大Aurora第一批入队赛WP">
<meta property="og:url" content="https://triodelzx.github.io/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/index.html">
<meta property="og:site_name" content="Triode Field">
<meta property="og:description" content="Crypto 简单丢番图方程（解题成本最高的一道）（其实就是一道二元二次不定方程问题） 这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决. 刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的： 1Aurora&amp;#123;None&amp;#125; 我以为这是对的，交上去发现是错的 后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤大">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-11-11T11:37:13.000Z">
<meta property="article:modified_time" content="2023-11-12T05:28:49.123Z">
<meta property="article:author" content="Triode_Lzx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://triodelzx.github.io/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深大Aurora第一批入队赛WP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-12 13:28:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Triode Field" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Triode Field"><span class="site-name">Triode Field</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深大Aurora第一批入队赛WP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-11T11:37:13.000Z" title="Created 2023-11-11 19:37:13">2023-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-11-12T05:28:49.123Z" title="Updated 2023-11-12 13:28:49">2023-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BF%A1%E5%AE%89WP/">信安WP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深大Aurora第一批入队赛WP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><hr>
<h2 id="简单丢番图方程（解题成本最高的一道）"><a href="#简单丢番图方程（解题成本最高的一道）" class="headerlink" title="简单丢番图方程（解题成本最高的一道）"></a>简单丢番图方程（解题成本最高的一道）</h2><p>（其实就是一道二元二次不定方程问题）</p>
<p>这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决.</p>
<p>刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;None&#125;</span><br></pre></td></tr></table></figure>
<p>我以为这是对的，交上去发现是错的</p>
<p>后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤大致如下：</p>
<h3 id="打开虚拟机（这是要讲的吗）"><a href="#打开虚拟机（这是要讲的吗）" class="headerlink" title="打开虚拟机（这是要讲的吗）"></a>打开虚拟机<del>（这是要讲的吗）</del></h3><h3 id="在虚拟机中打开靶机"><a href="#在虚拟机中打开靶机" class="headerlink" title="在虚拟机中打开靶机"></a>在虚拟机中打开靶机</h3><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938767.png" alt="picture1"></p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>在这里我们可以看到一个比较大的数和一条很像勾股定理的方程，所以我们可以断定这题要用到勾股定理，而我们知道的勾股数就那么几对，所以我们可以通过质因数分解找出我们熟悉的勾股数，现在我们打开factordb，将这个已知的数进行质因数分解，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938627.png" alt="picture2"></p>
<p>啊？怎么是个质数？运气太差了吧QwQ（我发誓不是节目效果）</p>
<p>遇到这种情况，我们直接重开一把（这个数是随机生成的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938955.png" alt="picture3"></p>
<p>这回就出来了</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938258.png" alt="picture4"></p>
<p>不幸的是，对于这个数的较小质因数4289，我们好像很难找出一组适合的勾股数（不一定是不存在，就是难找）</p>
<p>那么再重开一把：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111924525.png" alt="picture5"></p>
<p>很好，这次质因数分解后得到了我们想要的小质数</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111924541.png" alt="picture6"></p>
<p>而我们知道</p>
<script type="math/tex; mode=display">
(5,12,13)</script><p>是一组常见的勾股数，所以我们丢进计算器中可以算出：</p>
<script type="math/tex; mode=display">
x=304168011786560/5*12=730003228287744</script><script type="math/tex; mode=display">
y=304168011786560/5*13=790836830645056</script><p>这个时候我们把结果提交到靶机就可以得到我们想要的flag啦！</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938758.png" alt="final"></p>
<h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;ebd8bc51-2d57-406e-bcab-f601cfcb6924&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>这道题我觉得要改进的话应该数字搞大一点，锻炼Python编程能力</p>
<hr>
<h2 id="baby-RSA"><a href="#baby-RSA" class="headerlink" title="baby_RSA"></a>baby_RSA</h2><p>这题还是比较简单的，只涉及到大数分解问题</p>
<p>先贴一下加密的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;**************************&#125;&#x27;</span></span><br><span class="line">secret = bytes_to_long(flag)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    p = getPrime(<span class="number">64</span>)</span><br><span class="line">    n *= p</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = &#x27;</span>, n)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(secret, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = &#x27;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = &#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n =  2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c =  1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在《初等数论（第四版）》（闵嗣鹤，严士健编）对于RSA公钥体系的描述中（应该很多讲密码的书都是这样）</p>
<script type="math/tex; mode=display">
n=pq(p,q是两个大质数)</script><p>但是将上面的n丢进factordb（谢谢学姐提供的数据）之后，它出现了16个不同的质因数（其实从代码中也可以看出）！那要怎么办呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938273.png" alt="picture1"></p>
<p>实际上，在RSA公钥体系中，将密码转化为明码需要求解下列同余方程</p>
<script type="math/tex; mode=display">
b^d\equiv a^{ed}\equiv a^{1+k\varphi(n)}(modn)(e为密钥，n为解钥，b为密码，a为明码)</script><p>而对于欧拉函数，有如下定理：</p>
<script type="math/tex; mode=display">\varphi(n)=\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}=n)</script><p>而对于质数p，其欧拉函数值为：</p>
<script type="math/tex; mode=display">
\varphi(p)=p-1</script><p>所以对于对于题中解钥n，有：</p>
<script type="math/tex; mode=display">
\varphi(n)=(p_1-1)(p_2-1)(p_3-1)\cdots(p_{16}-1)(p_1,p_2,p_3,\cdots,p_{16}为n的16个不同的质因数</script><p>所以我们可以写出获得flag的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p1=<span class="number">11032741923171941087</span></span><br><span class="line">p2=<span class="number">11545653624202476473</span></span><br><span class="line">p3=<span class="number">11636293469353905931</span></span><br><span class="line">p4=<span class="number">11791412171539768003</span></span><br><span class="line">p5=<span class="number">12072682976194265431</span></span><br><span class="line">p6=<span class="number">12286985218370609161</span></span><br><span class="line">p7=<span class="number">13979567880622268887</span></span><br><span class="line">p8=<span class="number">14381447749489789777</span></span><br><span class="line">p9=<span class="number">14487171289353351409</span></span><br><span class="line">p10=<span class="number">14573688259437788669</span></span><br><span class="line">p11=<span class="number">15652738194884126429</span></span><br><span class="line">p12=<span class="number">16034270403328241087</span></span><br><span class="line">p13=<span class="number">16631285257180468447</span></span><br><span class="line">p14=<span class="number">17327252249988599903</span></span><br><span class="line">p15=<span class="number">17905457523849945107</span></span><br><span class="line">p16=<span class="number">18027152598391207147</span></span><br><span class="line">n=<span class="number">2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line">phi=(p1-<span class="number">1</span>)*(p2-<span class="number">1</span>)*(p3-<span class="number">1</span>)*(p4-<span class="number">1</span>)*(p5-<span class="number">1</span>)*(p6-<span class="number">1</span>)*(p7-<span class="number">1</span>)*(p8-<span class="number">1</span>)*(p9-<span class="number">1</span>)*(p10-<span class="number">1</span>)*(p11-<span class="number">1</span>)*(p12-<span class="number">1</span>)*(p13-<span class="number">1</span>)*(p14-<span class="number">1</span>)*(p15-<span class="number">1</span>)*(p16-<span class="number">1</span>)<span class="comment">#很蠢的方法，一个一个填</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>运行程序，我们就可以得到flag啦！</p>
<h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;RS4_1s_r3a1y_fun_4nd_ea5y!&#125;</span><br></pre></td></tr></table></figure>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>善用百度，Python真好用，还有，数论真好玩。</p>
<hr>
<h2 id="你爱深大吗"><a href="#你爱深大吗" class="headerlink" title="你爱深大吗"></a>你爱深大吗</h2><p>（最抽象的一道）</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938612.png" alt="picture1"></p>
<h3 id="解题过程及思路"><a href="#解题过程及思路" class="headerlink" title="解题过程及思路"></a>解题过程及思路</h3><p>这本质上是一道阅读题</p>
<p>刚开始，我看到下面的藏宝图这么抽象，我就知道：这题必有Base100！</p>
<p>后来再看一眼上面的小作文，我在里面找到了偏移值为6的凯撒密码，18层栅栏密码和一个密钥为”iloveszu”的维吉尼亚密码</p>
<p>故我试着解密</p>
<p>解密过程：Base100-&gt;偏移值为6的凯撒密码-&gt;18层的栅栏密码-&gt;密钥为”iloveszu”的维吉尼亚密码</p>
<p>解密出来长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;JTpnwk$VLB%p:?CR&amp;QIH:]An&gt;Zz;#CAg&lt;f37;$IZXvZ2INm;MS\0@Cg`c@It4892#G?&lt;mftRsQ,t;&gt;Fsxd&lt;2o_&#x27;:f@TSj&gt;!&#x27;BM+%`5&gt;$&quot;.qrET&lt;K9vaE?@W`&quot;1;89%@JbhgeACT9$;3KE\&lt;O9n(;aNA!@5tl1;WiC@5=BJX:];z-&gt;5/(V;7&lt;Gk_V%.!&lt;i:#?=tJOu*g/@s97T(E=n&#x27;%GJMF):M8</span><br></pre></td></tr></table></figure>
<p>这一看就不是flag</p>
<p>后来（一天后）经过指点及思考我发现了“冲破了基地的重重阻碍”中的“重重”二字，所以就尝试一下多重Base解码吧</p>
<p>经过尝试，对“Base”步骤解码过程如下：</p>
<p>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32</p>
<h5 id="解码结果："><a href="#解码结果：" class="headerlink" title="解码结果："></a>解码结果：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bky__cuuiwlz_zpwo&#123;taIkppbxywe__w&#125;st_hupzodnzht__t_ymhcicpfm</span><br></pre></td></tr></table></figure>
<p>解码出来发现出现了花括号和下划线，证明步骤应该是对了。</p>
<p>继续解密</p>
<p>根据上面的步骤，我们继续这条从偏移值为6的凯撒密码到18层的栅栏密码再到密钥为”iloveszu”的维吉尼亚密码的解密过程</p>
<p>解密出来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N_r_uHfa_&#125;_kdt_hioaerz&#123;wkc_rxbitfvoeowgpfyddmvpol__qil_kbra</span><br></pre></td></tr></table></figure>
<p>完全不对，连格式（Aurora{___}）都不对，而上面的加密方式中而可以改变符号位置的只有栅栏密码，而我在搜索引擎里面发现了一种不同的栅栏密码——W型。</p>
<p>在尝试之后，我发现再次经过上述解码方式后得出了如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nhihpr&#123;Dpk_bacj_eaik_wvs_mdfti_fa_j_knuomyddm_bu_movvgjjjh&#125;</span><br></pre></td></tr></table></figure>
<p>格式总算是正确了，但是为什么连关键的Aurora都没有出现呢？</p>
<p>我发现可能是凯撒密码的问题</p>
<p>后来我尝试偏移值为666的凯撒密码（实际上偏移值是16）</p>
<p>然后再进行上述步骤得到了如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dxyxfh&#123;Tfa_rqsz_uqya_mli_ctvjy_vq_z_adkecottc_rk_cellwzzzx&#125;</span><br></pre></td></tr></table></figure>
<p>发现还是不对</p>
<p>退回维吉尼亚密码前一步，我发现在解维吉尼亚密码之前的密文是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Limsjz&#123;Szi_cend_mpsi_xzd_gludg_ge_u_evjykzhog_jj_wmwzrdryr&#125;</span><br></pre></td></tr></table></figure>
<p>第一个是L，对照维吉尼亚密码表，我们可以发现，如果要从A得到L（因为我们猜测明文的第一个字母为A），那么密钥应为L</p>
<p>也就是说，维吉尼亚密码的密钥开头应该为L而不是I</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111928296.png" alt="密码表"></p>
<p>再次解密，得到如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;You_have_seen_the_magic_of_a_thousands_of_encodings&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是flag了。</p>
<p>所以这道题的步骤为：</p>
<h3 id="Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-偏移值为666（即16）的凯撒密码-gt-18层的W型栅栏密码-gt-密钥为”loveszu”的维吉尼亚密码"><a href="#Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-偏移值为666（即16）的凯撒密码-gt-18层的W型栅栏密码-gt-密钥为”loveszu”的维吉尼亚密码" class="headerlink" title="Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码"></a>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码</h3><hr>
<h2 id="AAAEEESSS"><a href="#AAAEEESSS" class="headerlink" title="AAAEEESSS"></a>AAAEEESSS</h2><p>先读代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag   </span><br><span class="line"><span class="comment">#flag从一个神秘的地方获得</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;welcometoAurora!&#x27;</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv=key)</span><br><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enc_flag = &quot;</span>, aes.encrypt(pad(flag, <span class="built_in">len</span>(key))).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">enc_flag =  de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们会发现这是CBC模式的AES加密，flag可能是下面的16进制字串解密而来的，通过搜索，我们发现有一个工具可以解密AES：</p>
<p><a target="_blank" rel="noopener" href="https://www.mklab.cn/utils/aes">AES在线加密解密工具 - MKLab在线工具</a></p>
<p>而阅读上面的代码，我们可以知道偏移向量和密钥均为<u>welcometoAurora!</u>将这两个东西放进去对应的地方，解码发现他出现了如下乱码:</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111928937.png" alt="解密1"></p>
<p>是否是我的方法出了问题呢？</p>
<p>继续读代码，我们可以看到一个刚才被忽略的东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br></pre></td></tr></table></figure>
<p>这串代码我们可以猜测是在Could u slove this challenge?加密后16进制字串后面拼接一条什么东西（AES加密的填充机制和密码长度规律）。</p>
<p>所以我们可以试着先将Could u slove this challenge?进行AES加密，得到如下密文串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546</span><br></pre></td></tr></table></figure>
<p>在后面拼接代码中enc_flag部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span><br></pre></td></tr></table></figure>
<p>再放入密码输入框中解密可得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could u solve this challenge?Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure>
<p>这样就得到了flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="qsdz的密码学衔接课（赛后复现）"><a href="#qsdz的密码学衔接课（赛后复现）" class="headerlink" title="qsdz的密码学衔接课（赛后复现）"></a>qsdz的密码学衔接课（赛后复现）</h2><p>这题由三小题组成，分别是：求解同余方程，求解同余方程组，求解离散对数问题。</p>
<p>而这三个问题，我们都要利用到一个重要工具：sagemath</p>
<p>下面我们分别求解三个问题：</p>
<h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">x: <span class="built_in">int</span>, order: <span class="built_in">int</span></span>):</span><br><span class="line">    p = getPrime(x.bit_length() * order)</span><br><span class="line">    A = [getPrime(x.bit_length()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(order)]</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(order):</span><br><span class="line">        y = (y + A[i] * x ** i) % p</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 1&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;p = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;A = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">==========Challenge 1==========</span></span><br><span class="line"><span class="string">p = 140540932516518794145151934666843219294863335242957071370416678765850106203805810862867703792863302163318519910426474343219910841109958974959958710112904675289540046802486139135135963299678067328274525866708889478446402107588914151782335913</span></span><br><span class="line"><span class="string">A = [586077106161933115521158870621277482378849813647,</span></span><br><span class="line"><span class="string">594177621805167358745968527276343722485294425499, </span></span><br><span class="line"><span class="string">438154568295734958683230212377930413557186542591,</span></span><br><span class="line"><span class="string">613916554223827544243334495150247792479839893207,</span></span><br><span class="line"><span class="string">696514075788803577127407605798057483933441939039]</span></span><br><span class="line"><span class="string">y = 13584348643332560556129513295162939264971165296317907991475444036286814596235852842416707036226141464730561542976865467336771619592932663214739700885173786520323855676418761763774305698027356758972580332479097742926600081856865297421280491</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看出，这里的同余方程为：</p>
<script type="math/tex; mode=display">
A_0+A_1x+A_2x^2+A_3x^3+A_4x^4\equiv y(mod\ p)</script><p>所以我们在sagemath中对该方程做出如下定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;x&gt;=Zmod(p)[]</span><br><span class="line">f=A[<span class="number">0</span>]+A[<span class="number">1</span>]*x+A[<span class="number">2</span>]*x^<span class="number">2</span>+A[<span class="number">3</span>]*x^<span class="number">3</span>+A[<span class="number">4</span>]*x^<span class="number">4</span>-y</span><br></pre></td></tr></table></figure>
<p>再通过下面一段代码进行求解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.roots()</span><br></pre></td></tr></table></figure>
<p>可以得出下面两个解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_1=98641516410644248590730760547711915061873706589456407188998882763190683930094458978790759787796637145415287953931944776332655673057814076619504993207500838191433321143407475719143239135946766090781645970151825507798503659865125167544876679</span><br><span class="line">x_2=373703556015754746532223260569877349038577184359</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至于是哪个解，我们到后面再讨论。</p>
<h3 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">x: <span class="built_in">int</span>, number: <span class="built_in">int</span></span>):</span><br><span class="line">    ps = [getPrime(x.bit_length() // (number - <span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line">    ys = [x % p <span class="keyword">for</span> p <span class="keyword">in</span> ps]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 2&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ps = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ys = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ps = [288186237701, 283710289297, 488405307827, 284002449103, 433963503397]</span></span><br><span class="line"><span class="string">ys = [229627846199, 206465857548, 461943583630, 18924375666, 173733924485]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们很容易可以写出上述代码的等价方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
        x\equiv229627846199(mod\ 288186237701)\\
        x\equiv206465857548(mod\ 283710289297)\\
        x\equiv461943583630(mod\ 488405307827)\\
        x\equiv18924375666(mod\ 284002449103)\\
        x\equiv173733924485(mod\ 433963503397)
\end{cases}</script><p>求解这种传统不定方程组需要利用一个定理——孙子定理（中国剩余定理/CRT），在sagemath中输入下列指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crt(ys,ps)</span><br></pre></td></tr></table></figure>
<p>可以得到下列解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">653438615351908597859575533851627354929851494003</span><br></pre></td></tr></table></figure>
<p>设上面的数字为y，则上述方程组等价于：</p>
<script type="math/tex; mode=display">
x\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)</script><p>我们可以验证：</p>
<script type="math/tex; mode=display">
gcd(y,ps_0ps_1ps_2ps_3ps_4)=1</script><p>根据同余方程的性质，我们可以知道还有其他的解：</p>
<script type="math/tex; mode=display">
y+k\cdot ps_0ps_1ps_2ps_3ps_4\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)</script><p>先假定需要的解就是上面的y。</p>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><p><del>又是同余方程</del></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">x: <span class="built_in">int</span></span>):</span><br><span class="line">    base = getPrime(x.bit_length())</span><br><span class="line">    exp = getRandomInteger(<span class="number">40</span>)</span><br><span class="line">    module = getPrime(x.bit_length())</span><br><span class="line">    y = <span class="built_in">pow</span>(base, exp, module)</span><br><span class="line">    cipher = exp * x % module</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 3&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;base = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;module = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;cipher = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">base = 410736349593916097049313683889292166618005625707</span></span><br><span class="line"><span class="string">module = 644953605408967844199642272144415528955561551061</span></span><br><span class="line"><span class="string">y = 242650313731015062596916881403616976177380555988</span></span><br><span class="line"><span class="string">cipher = 398635925008029999138603615357303867027885126384</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>求解上述离散对数，其实就是求解下列同余方程：</p>
<script type="math/tex; mode=display">
base^{exp}\equiv y(mod\ module)</script><p>而上述方程中，又有：</p>
<script type="math/tex; mode=display">
exp\cdot x\equiv cipher(mod\ module)</script><p>现在我们要求解未知数x，所以我们需要先求出exp</p>
<p>在sagemath中使用以下指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp = discrete_log_lambda(mod(y, module), mod(base, module), bounds=(<span class="number">2</span>**<span class="number">39</span>, <span class="number">2</span>**<span class="number">40</span>))</span><br></pre></td></tr></table></figure>
<p>可得</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp=<span class="number">940420210186</span></span><br></pre></td></tr></table></figure>
<p>再通过下面的指令求出x：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cipher * inverse_mod(exp, module) % module</span><br></pre></td></tr></table></figure>
<p>可得解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">545012220020390134376571283157248116812656615805</span><br></pre></td></tr></table></figure>
<h3 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h3><p>阅读题中代码的最上面部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">b&#x27;Aurora&#123;qsdzyyds&#125;&#x27;</span></span><br><span class="line">part_number = <span class="built_in">len</span>(flag) // <span class="number">3</span></span><br><span class="line">flag_part1 = bytes_to_long(flag[:part_number])</span><br><span class="line">flag_part2 = bytes_to_long(flag[part_number:<span class="number">2</span>*part_number])</span><br><span class="line">flag_part3 = bytes_to_long(flag[<span class="number">2</span>*part_number:])</span><br></pre></td></tr></table></figure>
<p>我们可以知道，flag的三部分应该长度一致，所以对于同余方程与同余方程组部分的解应该与离散对数相同，所以有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag1=<span class="number">373703556015754746532223260569877349038577184359</span></span><br><span class="line">flag2=<span class="number">653438615351908597859575533851627354929851494003</span></span><br><span class="line">flag3=<span class="number">545012220020390134376571283157248116812656615805</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过下面的代码求出flag：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(long_to_bytes(flag1))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag2))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag3))</span><br></pre></td></tr></table></figure>
<p>可以得出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;Aurora&#123;Sagem4th&amp;c0ng&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ru3nce_and_e9uations&#x27;</span></span><br><span class="line"><span class="string">b&#x27;_w1th_di5crete_lOg!&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Sagem4th&amp;c0ngru3nce_and_e9uations_w1th_di5crete_lOg!&#125;</span><br></pre></td></tr></table></figure>
<p>至此，衔接题就解决了。</p>
<hr>
<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><hr>
<h2 id="Basic-nc"><a href="#Basic-nc" class="headerlink" title="[Basic]nc"></a>[Basic]nc</h2><p>直接打开靶机</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938881.png" alt="picture1"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111931005.png" alt="picture2"></p>
<p>看到有个flag，输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938471.png" alt="picture3"></p>
<p>flag就出来了。</p>
<h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;ce8bf21a-3c2e-49f3-b27b-86440b8e8dd9&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Advanced-寰宇蝗灾"><a href="#Advanced-寰宇蝗灾" class="headerlink" title="[Advanced]寰宇蝗灾"></a>[Advanced]寰宇蝗灾</h2><p><del>（我就想玩个游戏，为什么会拿到这题的一血）</del></p>
<p>直接打开靶机！</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938268.png" alt="picture1"></p>
<p>直接攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938360.png" alt="picture2"></p>
<p>玩着玩着虫子的数量出现了负数，这个时候我们就可以知道，这题利用的是数据溢出的漏洞，那我们逮着这个漏洞打就行了，多打几遍就会出现下面的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938852.png" alt="picture3"></p>
<p>还真是溢出<del>（至于怎么溢出的我也不清楚）</del></p>
<p>现在flag就出来了。</p>
<h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;8fae9274-d452-4f64-966e-024584b8a8d1&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><hr>
<h2 id="Basic-消失的原神"><a href="#Basic-消失的原神" class="headerlink" title="[Basic]消失的原神"></a>[Basic]消失的原神</h2><p><del>（我刚开始真的以为下载个原神就可以拿到flag）</del></p>
<p>首先将消失的原神.exe文件拖到ida64中</p>
<p>按下Shift+F12进入string页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111932558.png" alt="picture1"></p>
<p>上面就是我们要的flag了</p>
<h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;D0_u_P1a_G3nsh1n_iMpact&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Basic-148464"><a href="#Basic-148464" class="headerlink" title="[Basic]148464"></a>[Basic]148464</h2><p>先拖进ida64，直接飞去main按F5进行一个编译</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938413.png" alt="picture1"></p>
<p>观察下列代码我们可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&quot;</span>) )</span><br></pre></td></tr></table></figure>
<p>发现flag在一系列未知的操作后变成了字符串”zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”。</p>
<p>现在我们要找到flag怎么变才能变成上述字符串。</p>
<p>我们阅读如下代码，可知flag是一个长度为24的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%24s&quot;</span>, s);</span><br></pre></td></tr></table></figure>
<p>再次阅读代码，我们发现s被丢进下面的函数里面进行过操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v5 - <span class="number">2</span> &gt; dword_4124 )</span><br><span class="line"> &#123;</span><br><span class="line">    sub_12F0((<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">1</span>], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">2</span>]);</span><br><span class="line">    dword_4124 += <span class="number">3</span>;</span><br><span class="line">    dword_4128 += <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>双击进入函数sub_12F0，我们看到这个函数进行的是如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_12F0</span><span class="params">(<span class="type">char</span> a1, <span class="type">char</span> a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  </span><br><span class="line">  s1[dword_4128] = aAbcdefghijklmn[a1 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">1</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">16</span> * a1) | (<span class="type">unsigned</span> __int8)(a2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">2</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">4</span> * a2) | (<span class="type">unsigned</span> __int8)(a3 &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  result = dword_4128 + <span class="number">3</span>;</span><br><span class="line">  s1[result] = aAbcdefghijklmn[a3 &amp; <span class="number">0x3F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以知道，其实这就是Base64的加密，但是当我将“zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”丢进Base64之后会见到一坨不明所以的无意义字符串，所以要思考是不是遗漏了什么。</p>
<p>再次阅读代码，可以发现在加密前有一个不明函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_1234();</span><br></pre></td></tr></table></figure>
<p>点进去我们可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1234</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[j], &amp;aAbcdefghijklmn[j + <span class="number">26</span>]);</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[k + <span class="number">52</span>], &amp;aAbcdefghijklmn[k + <span class="number">58</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，参与加密操作的字符串aAbcdefghijklmn是被修改过的！！</p>
<p>里面还有一个修改的函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">sub_1169</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+1Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v3 = *a1;</span><br><span class="line">  *a1 = *a2;</span><br><span class="line">  result = a2;</span><br><span class="line">  *a2 = v3;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个sub_1169函数的作用是交换a1和a2。</p>
<p>而直接查看内存，我们可以看到字符串aAbcdefghijklmn的值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们重写上面的C语言修改字符串代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">65</span>] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[j];</span><br><span class="line">            a[j] = a[j + <span class="number">26</span>];</span><br><span class="line">            a[j + <span class="number">26</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[k + <span class="number">52</span>];</span><br><span class="line">            a[k + <span class="number">52</span>] = a[k + <span class="number">58</span>];</span><br><span class="line">            a[k + <span class="number">58</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到aAbcdefghijklmn的新值为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们上搜索引擎找到Base64解码算法（Python比较方便，所以用了Python）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">STANDARD_ALPHABET = <span class="string">b&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#标准加密表</span></span><br><span class="line">CUSTOM_ALPHABET = <span class="string">b&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&#x27;</span><span class="comment">#修改后的加密表</span></span><br><span class="line">ENCODE_TRANS = <span class="built_in">bytes</span>.maketrans(STANDARD_ALPHABET, CUSTOM_ALPHABET)</span><br><span class="line">DECODE_TRANS = <span class="built_in">bytes</span>.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="built_in">input</span>).translate(ENCODE_TRANS)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(<span class="built_in">input</span>.translate(DECODE_TRANS))</span><br><span class="line"></span><br><span class="line">a=<span class="string">b&#x27;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&#x27;</span><span class="comment">#密文</span></span><br><span class="line">destr = decode(a)</span><br><span class="line"><span class="built_in">print</span>(destr.decode())</span><br></pre></td></tr></table></figure>
<p>运行可得flag如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;tH1s_iS_3z_base_64&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Advanced-爱门"><a href="#Advanced-爱门" class="headerlink" title="[Advanced]爱门"></a>[Advanced]爱门</h2><p><del>（爱门✝）</del></p>
<p>先将它放进ida64反编译，进入main点击F5进行编译。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938312.png" alt="main"></p>
<p>我们可以看到，获取flag的前置步骤是解出byte_4060，点进sub_134A函数，我们可以见到byte_4060被一定的规矩转换成了byte_40A0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sub_134A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = byte_4060[i];</span><br><span class="line">    byte_40A0[i] = v0 + aTheresa[i % <span class="built_in">strlen</span>(aTheresa)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而参与了转换的函数为aTheresa<del>（一只德莉莎？）</del>，双击这个字符数组我们可以看到aTheresa的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aTheresa        db <span class="string">&#x27;Theresa&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>转换为C++我们可以知道：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string aTheresa=<span class="string">&quot;Theresa&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>我们只知道这样一个类似维吉尼亚密码的密钥没有任何实质性作用，我们需要找出被加密后的字符串。点进main中的sub_1281函数，可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1281</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = byte_4020[i];</span><br><span class="line">    <span class="keyword">if</span> ( byte_40A0[i] != (_BYTE)result )</span><br><span class="line">      dword_403C = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以见到，这边要得到byte_40A0，则需要先知道byte_4020是如何定义的，点开byte_4020我们可以看到它所在的那行是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte_4020       db <span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span></span><br></pre></td></tr></table></figure>
<p>它只有七个数据，但是byte_40A0需要26个数据，怎么办呢？</p>
<p>结合指针知识，数组的数据是存储在连续的地址里面的，如果一个指针指向一个数组，当指针指向的数组下标超过了数组范围时，它就会指向数组最后一个元素所在地址后面紧接着的地址，所以我们放大视野，就可以看到下面的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938044.png" alt="data (2)"></p>
<p>刚刚好有26个数据，且跟其他的数据的地址没有冲突，所以用C++写下列代码进行解密的尝试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;</span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a1[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，我们可以得出下面一个看似合理的“flag”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Elysia_is_dead????&#125;</span><br></pre></td></tr></table></figure>
<p><del>爱莉希雅死了？？？？</del></p>
<p>提交发现是错的，肯定是我们忽略了什么。</p>
<p>我们唯一没看过的就是左边的函数列了</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938479.png" alt="function_list"></p>
<p>这里有很多不知道是什么的函数，我们一个一个看，可以发现函数sub_12CE里面有修改上面的数组中数据的代码（变量命名对应）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sub_12CE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(byte_4060, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">  result = <span class="built_in">memset</span>(byte_40A0, <span class="number">0</span>, <span class="keyword">sizeof</span>(byte_40A0));</span><br><span class="line">  byte_4030 = <span class="number">-45</span>;</span><br><span class="line">  byte_4031 = <span class="number">-103</span>;</span><br><span class="line">  byte_4032 = <span class="number">-39</span>;</span><br><span class="line">  byte_4033 = <span class="number">-46</span>;</span><br><span class="line">  byte_4034 = <span class="number">-59</span>;</span><br><span class="line">  byte_4035 = <span class="number">-71</span>;</span><br><span class="line">  byte_4036 = <span class="number">-55</span>;</span><br><span class="line">  byte_4037 = <span class="number">-55</span>;</span><br><span class="line">  byte_4038 = <span class="number">-109</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用此处代码对上述解密代码进行修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a2[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后又给出了一个看似合理的“flag”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Elysia_isn&#x27;t_dead!&#125;</span><br></pre></td></tr></table></figure>
<p><del>爱莉希雅没有死！</del></p>
<p>提交发现，他还是错的。似乎我们还是有所遗漏。</p>
<p>继续把我们的目光放到函数列上，我们会发现，在main函数后，还有一个名为sub_144F的函数，它跟sub_12CE发挥的效果是相似的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_144F</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  byte_4027 = <span class="number">-121</span>;</span><br><span class="line">  byte_402B = <span class="number">-106</span>;</span><br><span class="line">  byte_402E += <span class="number">10</span>;</span><br><span class="line">  byte_402F -= <span class="number">31</span>;</span><br><span class="line">  byte_4030 = <span class="number">-106</span>;</span><br><span class="line">  byte_4031 = <span class="number">-34</span>;</span><br><span class="line">  byte_4032 -= <span class="number">8</span>;</span><br><span class="line">  byte_4034 -= <span class="number">3</span>;</span><br><span class="line">  byte_4035 = <span class="number">-64</span>;</span><br><span class="line">  byte_4036 = <span class="number">-47</span>;</span><br><span class="line">  byte_4037 = <span class="number">-69</span>;</span><br><span class="line">  byte_4038 = <span class="number">-41</span>;</span><br><span class="line">  dword_403C = <span class="number">1</span>;</span><br><span class="line">  sub_1281();</span><br><span class="line">  <span class="keyword">if</span> ( dword_403C == <span class="number">1</span> )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Nice, job! U find it!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;What wrong with U? U didn&#x27;t find it! where is it?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且我们可以发现它还判断了变量dword_403C的大小，通过前面的阅读，我们可以发现，dword_403C只有在输入的字符串是正确的flag的时候才是1，参考上面的代码对解密代码进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//一次修改后</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">-121</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">-106</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">199</span>, <span class="number">188</span>, <span class="number">-106</span>, <span class="number">-34</span>, <span class="number">-47</span>, <span class="number">-46</span>, <span class="number">-62</span>, <span class="number">-64</span>, <span class="number">-47</span>, <span class="number">-69</span>, <span class="number">-41</span>, <span class="number">226</span>&#125;;<span class="comment">//二次修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a3[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，我们可以得到如下flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;3lys1a_sT1ll_aliVe&#125;</span><br></pre></td></tr></table></figure>
<p><del>爱莉希雅还活着</del></p>
<p>提交发现这个是真正的flag，至此，我们就解决了这道题。</p>
<hr>
<h2 id="Block-Chain"><a href="#Block-Chain" class="headerlink" title="Block Chain"></a>Block Chain</h2><hr>
<h2 id="easy-契约"><a href="#easy-契约" class="headerlink" title="[easy]契约"></a>[easy]契约</h2><p>这题利用的是合约创建字节码泄露。</p>
<p><del>需要挂梯子</del></p>
<p>进入网站：<a target="_blank" rel="noopener" href="https://sepolia.etherscan.io/">TESTNET Sepolia (ETH) Blockchain Explorer (etherscan.io)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938033.png" alt="Exploer"></p>
<p>在搜索框中输入题中给出合约并搜索：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938458.png" alt="heyue"></p>
<p>点进合约对应的交易之后找到“Input data”一栏，在“View input as”处选择“UTF-8”就可以看到这样一坨：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111935175.png" alt="flag"></p>
<p>里面蕴含了我们要的flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;W3lc0me_2_Blockch4in!!!&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在提交的时候，flag的最后可能有一个不可见字符，需要删掉。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://triodelzx.github.io">Triode_Lzx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://triodelzx.github.io/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/">https://triodelzx.github.io/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" title="Triode的RSA学习笔记（1）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Triode的RSA学习笔记（1）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Triode_Lzx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Crypto"><span class="toc-number">1.</span> <span class="toc-text">Crypto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B%EF%BC%88%E8%A7%A3%E9%A2%98%E6%88%90%E6%9C%AC%E6%9C%80%E9%AB%98%E7%9A%84%E4%B8%80%E9%81%93%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">简单丢番图方程（解题成本最高的一道）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E8%BF%99%E6%98%AF%E8%A6%81%E8%AE%B2%E7%9A%84%E5%90%97%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">打开虚拟机（这是要讲的吗）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%89%93%E5%BC%80%E9%9D%B6%E6%9C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">在虚拟机中打开靶机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">求解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag"><span class="toc-number">2.3.1.</span> <span class="toc-text">flag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.4.</span> <span class="toc-text">建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#baby-RSA"><span class="toc-number">3.</span> <span class="toc-text">baby_RSA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">flag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E6%83%B3"><span class="toc-number">3.1.</span> <span class="toc-text">感想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%88%B1%E6%B7%B1%E5%A4%A7%E5%90%97"><span class="toc-number">4.</span> <span class="toc-text">你爱深大吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%80%9D%E8%B7%AF"><span class="toc-number">4.2.</span> <span class="toc-text">解题过程及思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">解码结果：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-%E5%81%8F%E7%A7%BB%E5%80%BC%E4%B8%BA666%EF%BC%88%E5%8D%B316%EF%BC%89%E7%9A%84%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81-gt-18%E5%B1%82%E7%9A%84W%E5%9E%8B%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81-gt-%E5%AF%86%E9%92%A5%E4%B8%BA%E2%80%9Dloveszu%E2%80%9D%E7%9A%84%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AAAEEESSS"><span class="toc-number">5.</span> <span class="toc-text">AAAEEESSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qsdz%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E8%A1%94%E6%8E%A5%E8%AF%BE%EF%BC%88%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%8E%B0%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">qsdz的密码学衔接课（赛后复现）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">同余方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">6.2.</span> <span class="toc-text">同余方程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88"><span class="toc-number">6.4.</span> <span class="toc-text">结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-2"><span class="toc-number">6.4.1.</span> <span class="toc-text">flag</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pwn"><span class="toc-number">7.</span> <span class="toc-text">Pwn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-nc"><span class="toc-number">8.</span> <span class="toc-text">[Basic]nc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-3"><span class="toc-number">8.0.1.</span> <span class="toc-text">flag</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-%E5%AF%B0%E5%AE%87%E8%9D%97%E7%81%BE"><span class="toc-number">9.</span> <span class="toc-text">[Advanced]寰宇蝗灾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-4"><span class="toc-number">9.0.1.</span> <span class="toc-text">flag</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reverse"><span class="toc-number">10.</span> <span class="toc-text">Reverse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-%E6%B6%88%E5%A4%B1%E7%9A%84%E5%8E%9F%E7%A5%9E"><span class="toc-number">11.</span> <span class="toc-text">[Basic]消失的原神</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-5"><span class="toc-number">11.0.1.</span> <span class="toc-text">flag</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-148464"><span class="toc-number">12.</span> <span class="toc-text">[Basic]148464</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-%E7%88%B1%E9%97%A8"><span class="toc-number">13.</span> <span class="toc-text">[Advanced]爱门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block-Chain"><span class="toc-number">14.</span> <span class="toc-text">Block Chain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#easy-%E5%A5%91%E7%BA%A6"><span class="toc-number">15.</span> <span class="toc-text">[easy]契约</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/12/%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/" title="若尔当标准型与矩阵离散对数问题">若尔当标准型与矩阵离散对数问题</a><time datetime="2024-07-12T15:04:20.000Z" title="Created 2024-07-12 23:04:20">2024-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/" title="XYCTF2024-疯狂大杂烩！九转功成复现WP">XYCTF2024-疯狂大杂烩！九转功成复现WP</a><time datetime="2024-04-28T10:27:31.000Z" title="Created 2024-04-28 18:27:31">2024-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/" title="PicoCTF2024 Crypto部分WP">PicoCTF2024 Crypto部分WP</a><time datetime="2024-03-29T14:02:04.000Z" title="Created 2024-03-29 22:02:04">2024-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="向量空间（Vector Space）学习笔记">向量空间（Vector Space）学习笔记</a><time datetime="2024-03-24T15:26:39.000Z" title="Created 2024-03-24 23:26:39">2024-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/" title="连分数（Continued Fractions）笔记">连分数（Continued Fractions）笔记</a><time datetime="2024-03-09T04:23:07.000Z" title="Created 2024-03-09 12:23:07">2024-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Triode_Lzx</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>